import React from 'react';
import L1c1 from '../L1C1/L1C1'

const lesson1 = {
    info : {
        name: "Подвижный замок",
        subname: ["Libra Move игровой курс ", "*на основе Libra move Commit 61649eb"],
        intro: " В существующей системе блокчейне, бит - монета запрограммирует \"валюту\", а \"применение\" запрограммировано\"Эфириум\", в то же время по сравнению с тем, что Libra запрограммирует\"активы\"  \n\n в Libra мы можем определить некоторые виды активов, которые более сложны, чем валюта, и такие ресурсы называются  “ресурсами” .  Libra  использует язык Move для ограничения операций с ресурсами, чтобы предотвратить нежелательные изменения и тем самым повысить безопасность активов.  \n\n Move обеспечивает надежную и программируемую основу для блокчейна Libra, метод  программирования на \"активы\" и строгого ограничения на безопасность делают его удобным для выпуска цифровых валют, обработки операций по блокчейну и управления документацией.  \n\nв этом уроке мы используем язык Move для строительства замка и реализации его экспансии и военных функций, чтобы помочь начинающим быстрее изучать этот язык.  ", 
        goback: "←Возвращение",
        editor: "Редактор",
        lesson: "Урок",
        copyAnswer: "Копировать ответ",
        learnmore: "Изучать больше",
        start: "Начать учиться",
        indexpage:"https://www.learnlibramove.com",
        learninide:["Код данного  курса может быть скомпилирован и принят в ChainIDE","к ChainIDE"],
        practice: "сейчас",
    },
    local:{
        hint: "Подсказка",
        previous: "Предыдущий",
        next: "Следующий",
        catalog: "Оглавление",
        checkcode: "Проверять код",
        showAnswer: "Показать ответ",
        hideAnswer: "Скрыть ответ",
        contitle: ["Поздравлять с завершением этой главы  ~", "Поздравлять с завершением этого урока~", "блестящие вещи продолжаются"],
        concontent: ["Нажать “продолжение”，идти навстречу новым вызовам！", "этот урок закончен，нажать “возвращение” на возглавлене！Нажмите «следующий урок», чтобы продолжить изучать новые знания о Весах!", "Hi~Поздравлять с завершением всего содержания данного урока~больше уроков будет показано вам скоро. Сейчас ，давайте составим соглашение с Libra Move на ChainIDE！"],
        concontinue: ["Продолжение веред", "возвращение", "к ChainIDE", "Следующий урок"],
        shut: "Закрыть окно",
        target: "Введение урока",
        keypoint: "Важный момент",
        detail: "Подробное"
    },
    lessonserial: " Урок 1",
    title: "",
    intro: [" В первом уроке мы покажем вам как закладывать фундамент своего замка, ваш замок имеет исключительный уникальный внешний вид и неожиданное животное внутри. ", " как заключить соглашение; блоки в Move; main в Move (); переменные и типы данных ;процесс в Move "],
    key: 1,
    total: 5,
    chapters: [
        {
            title: "Глава 1Краткий обзор ",
            instruction: `##  Глава 1Краткий обзор\n\n В первом уроке мы будем изучать как строить замок.\n\n- Мы будем строить замок  блоками\n- наш замок будет сохраняться в базе данных（блокчейн Libra）\n\n В последующих главах, функци нашего замки будут постепенно увеличиваться, как, например, укреплять свой сил, бороться с другими игроками замков, но до этого, мы должны, в первую очередь, реализовать функцию строительства замка.  \n\n### Какие характеры имеет замок \n\n каждый замок имеет имя, серийный номер, ранг, экономическую мощь и военную мощь.  Среди них серийный номер определяет внешний вид замка и его биологическую расу, ранг определяет ценность замка, экономическая мощь и военная мощь влияют на поведение замка во взаимодействии с другими замками.  \n\n### Как серийный номер влияет на замок？\n\n серийный номер определяет внешний вид замка и его биологическую расу, серийный номер- восьмизначное целое число, например：83451029。\n\n каждое число серийного номер соответствует одному характеру замки, подробное показано как в  следующем：\n\n|  1   |  2   |  3   |    4     |    5     |    6     |  7   |    8     |\n| :--: | :--: | :--: | :------: | :------: | :------: | :--: | :------: |\n| размер | модель| цвет | модель знаки| цвет знаки| местоположение знаки| раса | особенная отметка|\n\n из увлекательности игра, серийный номер производится вероятно на основе глубины блоки при строительстве замки, а не решается самим пользователем, конечно, это не означает, что внешний вид замка неопределенный, так как при создании замка серийный номер является фиксированным.  имя каждого вновь построенного замка вводится пользователем, начальное значение является уровнем 1, исходная экономическая мощь и военная мощь определяются порядком в расовом положении, соответствующем следующим ：\n\n|  раса  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| экономическая мощь|  6   |  8   |  3   |  7   |  4   |\n| военная мощь|  6   |  3   |  8   |  4   |  7   |\n\n### военные учения\n\n1. Перетащите ползунок во правой стороны страницы и проверьте внешний вид замка разного серйного номера。\n\n\n **прочитав эти основные элементы, нажмите на следующую главу и продолжите изучать язык Move **。\n\n`,
            type: 1, 
            show(){
                return <L1c1 lang="4"/>
            }
        },
        {
            title: "Глава 2 соглашение и модуль",
            instruction: `##  Глава 2 соглашение и блок\n\n соглашение- это компьютерная программа, работающая на блокчейне, и мы выполняем целый ряд операций на блокчейне, таких как перевод, покупка товаров и т.д.  \n\n Общий код Move соглашения разделен на две части ：\n\n- с началом\`modules:\`часть модулей в начале\n- с началом\`script:\` \`main()\`\n\n Мы будем представлять в данной главе\`modules\`часть，представлять в следующей главе\`script\`часть。\n\n### модуль\n\n часть модулей содержит модули, необходимые для выполнения всего соглашеня（\`Module\`），модуль является основной пакетной единицей соглашения Move, и все модули, размещенные на Libra, являются общими.  \n\n В  модуле можно определить конструкцию  (\`Struct\`)、русурс(\`Resource\`) и процесс (\`Procedure\`），эти концепции мы изложим в последующих разделах.  \n\n Модуль похож на смарт – соглашение в Ether, а также на класс языка Java.  Мы можем рассматривать модуль как общий блок кода с определенными функциями, которая получает внутренную информацю модуля через интерфейс. \n\nНапример，\`LibraCoin\`модуль был официально опубликован как модуль монет Libra.  Этот модуль включает определение монет «Libra» и процесс осуществления операций по переводу, пополнению и т.д.  После внедрения этого модуля разработчиками можно выполняться соответствующие функции через интерфейс.  \n\n#### как строить модуль\n\nчерез\`module имя модули{ }\`строить модуль\n\n#### как проводить модуль\n\nпохож на метод цитирования“имя пакета+ имя класса в Java，в Move через “адрес+имя модули” цитировать\`import\`модуль，например:\n\n\`import 0x0.LibraCoin\`\n\nздесь \`LibraCoin\`является имени модули，\`0x0\`является адресом аккаунта, который опубликовал данный модуль. каждый пользователь может публиковать свой модуль на блокчейне, а также цитировать другие модули таким образом.  Все адреса модуля, опубликованные официально в Libra являются \`0x0\`。\n\nможно прямо использовать при ввода модулей одного файла\`import Transaction.имя модули\`，например\n\n\`import Transaction.LibraCoin\`\n\n### воееные учения\n\nчтобы построить наш замок сначала надо составлять модуль с имени\`BuildCastle\`，в этом модуле мы постепенно осуществляем ряд функций по строительству замка .\n\n1. Составлять одну пустой модуль\`BuildCastle\`\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//вводить код ",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "Глава 3  main в соглашении()",
            instruction: `## Глава 3 в соглашении\`main()\`\n\nВ предыдущей главе мы научились создавать модуль, дальше мы должны совершенствовать содержание соглашения на основе этого модуля.  \n\n Мы можем вложить код в контракт, который будет выполнен один раз, и этот код называется сценарием перевода（Transaction Script），и не могут быть вызваны другими кодами. \`script:\`использовано как идентификатор начала сценарии перевода.\n\n\`main()\`является входом исполнения сценарии перевода.мы называем код в форуме \`main()\`как “процесс”，мы будем подробно излагать концепцию процесса в последующих разделах.  \`main()\`являетя особым процессом, который может быть вызван только один раз и не может быть вызван другими процессами.  \n\nпринимая во внимание，включая\`main()\`каждый процесс надо закончить с концем\`return\`，транслятор Move очень буквально: он переводит исходный код непосредственно, не делая ничего другого, например вставляя пропущенное\`return\`'。\n\n При подготовке соглаения Move мы обычно записываем все операции в обычный процесс (кроме \ 'main () \' ), а записываем обычные процессы в модуль , и наконец, вводить модули в часть \ 'script \', использовать  \`main()\` как вход, совершать ряд операций через процессы мдули, целые идеи показаны как в следующем. \n\n<img src=${require("../../static/images/lesson1/pic_1_2_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n Обратите внимание, когда необходимо вводить другие модули в модуль,вводимые фразы должны появиться в первой строке внутри модуля, то есть в следуюшей строке\`module имя модули\`.при введения модули в часть\`script\`，вводимые фразы должны проявляться в первой строке в части \`script\`, то есть в следуюшей строке\`script: \`，в предыдущей строке\`main()\`。\n\n с учетом вышесказанного, следующий - самый основной пустой контракт. ： \n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### практика\n\n на основе построенного модули \`BuildCastle\`，составлять одно пучтое соглашение. \n\n1.  Сначала добавлять \`modules: \`и \`script: \`；\n2. В следующей строке\`script\` добавлять  \`main()\`，помните в  \`main()\`добавлять фразу\`return\`；\n3. В части \`script\`через \`import\`вводить модуль（в предыушей строке\`main()\`）。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//вводить код здесь\nmodule BuildCastle {\n\n}\n//водить код здесь\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: "Глава 4 переменные привязки и типы данных ",
            instruction: `## Глава 4 переменные привязки и типы данных \n\n### **переменные привязки**\n\n привязка переменных означает привязку некоторых значений к одной переменной, что позволяет использовать их позже.  \n\n как и в языке Rust, язык Move привязывает переменные через ключевые слова let , как показана в следующей форме：\`let имя переменной: тип переменной ;\`  например：\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\n После привязки переменных можно инициализировать и использовать знак равенства \`=\` для инициализации, например：\n\n\`\`\`\nx = 5;\n\`\`\`\n\nСледует отметить, что во всех процессах привязки переменных должны начинаться с самого начала, то есть все фразы\`let\ должны быть помещены в самом начале, а вставить \`let\`между блоками кода может привести к сбою компиляции.\n\n### тип данных\n\nВ настоящее время язык Move поддерживает следующие типы данных ：\n\n- булев（\`boolean\`）\n- 64 - битное целое число  без знака（\`uint64\`）\n- адрес（\`address\`）\n-байтовый массив （\`bytes\`）\n-сткуктура（\`struct\`）\n- ресурс（\`resource\`），это особенный тип языка Move \n\n среди них，тип\`boolean\`использует ключевые слова\`bool\`，тип \`uint64\`использует ключевые слова \`u64\`，тип \`address\`использует ключевые слова\`address\`，\`bytes\`использует ключевые слова\`bytearray\`。Мы можем показать различные типы переменных следующим образом：\n\n\`\`\`\nmain() {\n    //привязка переменных\n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //иницилиализация переменных\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h "123abc";\n    return;\n}\n\`\`\`\n\nтоже можно показать ресурсы и структуру：\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\nсреди них，\`f1\`и\`f2\`являются именами переменных。\n\n Следует отметить, что, поскольку приказание Move не будет автоматически инициализирована, мы не можем использовать переменные без инициализации.\n\n### практика \n\n серийный номер замков будет состоять из 8 - битного числа, поэтому мы будем ограничивать случайные серийные номера 8 - битным числом через MOD\`%\`,  до этого нам сначала нужна переменная именем\` SerialDigits\`, с помощью которой обозначить серийного номера является задачей настоящей главы.  в \ \ \ main () \ процесс \ 'Serial Digits \' определяется как тип u 64 данных и присваивается 8.  \n\n в процессе\`main()\`определять\`SerialDigits\` как тип данных u64, и давать значение 8. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //вводить код здесь \n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "Глава 5 процесс",
            instruction: `## Глава 5 процесс\n\n как говорится во второй главе, в модуле мы можем определить процесс, который аналогичен функциям других языков. \n\n###заявление процесса \n\n при заявлении процесса мы должны указать его видимость, название, параметры и возвращаемые значения и возвращаемое значение в следующем формате:  \n\n\`видимость имя процесса (имя параметра): тип возвращаемого значения\`\n\n  надо отметить：без параметров в процессе не надо указать имя параметра; в случае отсутствия возвращаемоых значений не требуется указывать тип возвращения.  \n\n процесс в модуле имеет две видимости: \n\n- общий(public): общественный процесс может быть вызван другими модулями, общественный процесс может быть вызван другими модулями \ n -частный (private): частный процесс может быть вызван только тем же модульным процессом.  Ресурсы в модуле являются частными, и доступ в другие модули можно получить только через общий процесс\n\n, когда отсутствуют параметров и возвращаемых значений мы используем следующий способ для заявления：\n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\n если процесс заявления имеет параметры, то изменить его следующим образом：\n\n\`\`\`\npublic Procedure(a: u64, b: u64) { //  когда параметр является другим или имеет больше (меньше) параметров, форма аналогична \n    return;\n}\n\n\`\`\`\n\n Следует отметить, что сам процесс может быть введен в другие процессы в качестве параметра.  \n\nесли в процессе заявления существует возвращаемое значение, то изменить его следующим образом：\n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 { //когдавозвращаемое значение является другим типом, форма аналогична\n    return 1;\n}\n\n\`\`\`\n\n В приведенном выше примере все процесы, которые мы определяем, являются общественными(public), если заявлять частные процессы,  можно прямо удалить \ 'public \'. \n\n### вызов процесса\n\nпроцесс может быть вызован через метод\`имя модули.имя процесса\`，если выовать процесс общего модули, то можно через метод \`Self.имя процесса\` .\n\n пример заявления и вызова показан ниже：\n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { // заявлять общий процесс, имя процесса являетсяProcedure\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); // процесс вызова，среди них Contract является именем модули \n    return;\n}\n\n\`\`\`\n\n### практика\n\n В предыдущих главах мы говорили о том, что превращать серийный номер в 8-битное целое число с помощью MOD\`%\`, в частности, цифровой модуль 10 <sup>n</sup> получает n-битное целое число, поэтому здесь мы должны вычислить10<sup>8</sup> через процесс .\n\n1. В модули\`BuildCastle\` создать модуль математического вычисления\`Math\`，Он включает все математические операции в этом уроке .\n2. указать процесс\`pow()\`степенной операции в новом модуле，подробное показано как в следующем：\n   - параметр：типu64включает основание степени x и показательn\n   - возвращаемое значение：результат степенной операции типа u64  \n   -содержание процесса：пока свободен, чтобы компиляция прошла, мы пока даем ему возвращаемое значение1.  Мы выполним его функцию в следующей главе.  \n3. перед\`main()\`вводить модуль математических операций\`Math\`，и после \`SerialDigits\`заявлять переменную\`u64\`именем \`SerialLimit\`，он представляет ограничение битов серийного номера.\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \n//вводить код здесь \n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//вводить код здесь\n\nmain() {\n    let SerialDigits: u64;\n    //вводить код здесь\n\n    SerialDigits = 8;\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },    
    ]
};

const lesson2 = {
    lessonserial: "урок 2",
    title: "",
    intro: ["Во первом уроке мы изучали операции, связанные с переменными, и успешно показали серийные номеры замка, заложив первый камень для строительства замка.  Во втором уроке мы покажем вам, как построить каркас замка и построить свой собственный замок.  "," право собственности; структура программы в Move; создание и использование конструкции; часто используемые операторы в Move; процесс многих возвращаемых зачений в Move "],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "Глава1право собственности",
            instruction: `## Глава1право собственности\n\n### использование права собственности\n\n В предыдущих главах мы ссылались на слово "Привязка", на самом деле, привязка означает привязка права собственности,  только если идентификатор имеет право собственности на какое-то значение, мы можем получить доступ к этому значению через этот идентификатор.  \n\n когда мы привязываем значение к какому - либо имени (идентификатор), то к этому идентификатору привязывается право собственности на это значение (ресурс). Например：\n\n\`\`\`\nlet x: u64;\nx = 3;\n\n\`\`\`\n\n Когда мы привязываем идентификатор \ 'x \' и\`u64\`, а также ресурс, имеющий значение 3, \ 'x \' имеет право собственности на 3.  В период привязки этот идентификатор является единственным владельцем ресурса, который может получить доступ к этому ресурсу и изменить его, но после передачи привязки другим идентификаторам он больше не будет иметь права собственности на него.  \n\n### передача права собственности\n\n  когда мы хотим передать право собственности, мы должны использовать\`move()\`для передачи права собственности в интересах безопасности памяти, а не непосредственно использовать\`=\`。\n\n Иными словами, в языке Move для соединения между идентификаторами не может быть использовано\`=\`, только идентификаторы и значения могут быть соединены \`=\` .  Например, следующий код является ошибочным：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //error\n\n\`\`\`\n\n  дальше мы используем конкретный код для описания передачи права собственности: ：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); //передать(move) право собственности на значение3 с идентификатораx до идентификатора y\nz = move(x); //error:  при этом идентификатор x уже утратил право собственности и стал переменной без инициализации，поэтому move(x)провалился\nz = move(y); ///передать(move) право собственности на значение3 с идентификатораy до идентификатораz\nx = 3; 	//вновь осуществлять инициализацию идентификатораx\nz = move(x); //в данный момент можно передать move право собственности на значение3 с идентификатораx до идентификатораz\n\n\`\`\`\n\n### копирование рава собственности\n\n В некоторых случаях, мы надеемся, что при отсутствии передачи право собственности можно установить значение идентификатора, эквивалентно значению другого идентификатора, и в этом случае необходимо использовать процесс\`copy()\`，через\`copy\`，идентификатор еще может быть доступным. Например：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); //копировать（copy）право собственности на значение 3 с идентификатора x до идентификатора y\nz = move(x); //передать（move）право собственности на значение 3 с идентификатора x до идентификатора z\n\n\`\`\`\n\n Следует отметить, что, когда мы называем процесс и вводим параметр, нельзя непосредственно использовать имя параметра, а нужно использовать\`move(имя параметра)\`или\`copy(имя параметра)\`, чтобы передать право собственности на процесс, надо по ситуации использования код над параметром или после параметра определять использовать\`move\`или\`copy\`.\n\n### практика\n\n в прошлом уроке мы показали\`SerialLimit\`，в этой главе мы надеемся, что значение \`SerialLimit\`равно 10 <sup>SerialDigits</sup>。Таким образом, нам надо использовать процесс\`pow()\` для инициализации\`SerialLimit\`，параметрами данного процесса являются 10 и \`SerialDigits\`。\n\n Эта задача требует передачи переменной в качестве параметра на процесс\ 'pow () \, что касается передачи права собственности, а \' SerialDigits \ 'может быть вновь использовано в последующем содержании и поэтому нужно использовать\`copy()\`.  При этом процесс \ 'pow () \' все еще пуст, и мы выполним его в следующей главе.  \n\nв \`main()\`через использоание процесса\`pow()\`осуществлятьинициализацию\`SerialLimit\`，метод вызова процесса\`имя модули.имя процесса\`， это было описано в предыдущей главе, если забыли, можно повторить.  \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //вводить код здесь\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Глава 2 структура программы",
            instruction: `## Глава 2 структура программы\n\n как и на других языках, в языке Move также существует обычная программная структура, например, выбор и цикл .\n\n мы можем через фразу\`if-else\`осуществлять простую структуру выбора，конкретные правила показаны как ниже：\n\n1. Разветвленные фразы должны быть заключены в квадратные скобки\`{}\`и даже только одно предложение должно быть заключено, следующие примеры являются ошибочными ：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;	//здесь x = 3 нужны квадратные скобки\n       return;\n   }\n   \`\`\`\n\n2. знак деления  разветвленной фразы\`;\` добавляется в конце каждого предложения, не требуется после квадратных скобок, а приводимые ниже примеры являются ошибочными. ：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;\n       else {\n           x = 5\n       };	// знак деления здесь должен появляться в конце предыдущей строки\n       return;\n   }\n   \`\`\`\n\n3. Если инициализация идентификатора происходит в разветвленной фразе, то когда разветвленная фраза не содержит всех случаев, после окончания ветви этот идентификатор не может быть доступен, следующий пример является ошибочным.：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       }	// Здесь только в ветвях if осуществлять инициализацию переменной x, а в ветвях else,соответственно , средняя переменная x не была инициализирована, поэтому мы не можем использовать copy для доступа       assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n   И если ветвь содержит все случаи, то после окончания ветви можно получить доступ к идентификатору, следующий пример является правильным：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } else {\n           x = 43;\n       }	// Здесь две ветви содержат true и false, то есть, в любом случае, переменная x будет инициализирована, так что мы можем использовать copy\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n4. при использовании\`move()\` в ветве, обязательно обратите внимание на вопросы собственности, в ветке идентификатор, который был\`move()\` , не должен быть вновь доступен после окончания ветки, следующий пример является ошибочным.：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       let y: u64;\n       x = 0;\n       if (true) {\n           y = move(x);	//В этой ветви мы передаем право собственности с переменной x на переменную y, поэтому в следующем коде мы не можем получить доступ к переменной x\n через copy (x)       }\n       assert(copy(x) == 0, 42);\n       return;\n   }\n   \`\`\`\n\n Мы также можем достичь циклической структуры через\`loop\`, которая по причинам объема не описывается подробно в настоящей главе и будет описана в последующих разделах.  \n\n### практика\n\n наиболее распространенный способ реализации функции степени - это рекурсия, ниже приводится пример функции степени в языкеC. ：\n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\n\`\`\`\n\n Следуйте вышеизложенным процедурам для осуществления конкретного содержания \`pow()\`в модули\`Math\` , обратите внимание на вопросы собственности на переменные и надлежащим образом используйте\`copy\`и\`move\`。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //вводить код здесь \n        \n        return 1; //удалять эту фразуreturn\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Глава 3 конструкция",
            instruction: `## Глава 3 конструкция \n\n структура языка Move аналогична структуре других языков и состоит из набора данных, имеющих одинаковые или разные типы данных. Через \`struct имя конструкции {данные1: тип, данные2: тип, ...}\`заявлять，например：\n\n\`\`\`\nmodule Test {\n	//пустая конструктура \n  	struct Empty1 { }\n  	//конструкция, имеющая два члена\n  	struct T { a: u64, b: u64, }\n}\n\n\`\`\`\n\n обратите внимание：\n\n-  структура может быть заявлена только перед модулем, а не в процессе \n-конструкция может быть\`copy\`или\`move\`\n\n  Что касается более широкого использования конструкции, то мы будем представлять их в последующих разделах при использовании.  \n\n### практика \n\n в модули\`BuildCastle\` заявлять конструкцию\`Castle\`，которая иммет 5 членов：\`name(bytearray)\`, \`SerialNum(u64)\`, \`level(u64)\`, \`economic(u64) \`и\`military(u64)\`。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//вводить код здесь \n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: " Глава 4 операции ",
            instruction: `## Глава 4 операции\n\n В предыдущих главах мы уже использовали некоторые базовые операции, такие, как сложение, умножение и т.д., и в этой главе мы конкретно узнаем несколько операций, которые уже осуществляются Move. \n\n Move язык в настоящее время выполняет следующие математические операции ：сложение \`+\`  вычитание \`-\`умножение\`*\`деление\`/\`MOD\`%\`， конкретные примеры использования показаны ниже：\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\n\`\`\`\n\nа также осуществляет операцию сравнения：больше чем\`>\`、меньше чем\`<\`、равно\`==\`、больше или равно\`>=\`、меньше или равно\`<=\`、не равно\`!=\` ，конкретные примеры  показаны ниже：\n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\n\`\`\`\n\n Кроме того, Move осуществляет несколько операций и булевых операций, которые не были подробно описаны в настоящей главе по причинам объема, и мы будем представлены в последующих разделах.  \n\n### практика \n\n Мы хотим создать случайный серийный номер замка по глубине текущего модули.   \n\n алгоритм генерации самых элементарных случайных чисел реализуется с помощью MOD \n\n  Ниже приведен пример кода, который позволяет получить простые псевдослучайные числа на языке C , и очевидно, что эта программа получает случайные последовательности чисел в зависимости от выбора начальных значений \`next\`. \n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\n\`\`\`\n\n На основе этой программы мы несколько модифицируем программу для создания программы случайного числа по семенам\`seed\：\n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\n\`\`\`\n\n Мы можем создать случайные числа в пределах заданного диапазона, точно так же, как и другие языки, с помощью MOD.  В частности, для создания случайных чисел от \`m\`до\`n\` можно использовать следующие коды: \n\n\`\`\`c\nmyrand(seed) % (n - m + 1) + m;\n\n\`\`\`\n\n1. по аналогии с вышеуказанными программами генерации случайных чисел добавьте процесс \`myrand()\` образования случайных чисел в модуль\`Math\`, и выполните его конкретные функции.  \n2. Добавьте и осуществите общий процесс \`generateSerial()\` в модуль \`BulidCastle\`，процесс вызывает процесс \`myrand\`в модули \ 'Math \' по глубине блока для создания случайных 8 - битных серийных номеров （то есть создать случайные числа с 10<sup>7</sup>до10<sup>8</sup>-1），параметр – ограничение битов серийных номеров  \`SerialLimit\`，возвращаемое значение \`u64\`。\n   - Глубина блока может быть получена методом \`get_current_height()\` в модули \`Block\`. \n   - \`Block\`адрес модули является  \`0x0\`。\n   - вводите в правильном месте модуль\`Math\`и модуль\`Block\`。\n3. В \`main()\` заявлять \`SerialNum\`  и через \`generateSerial()\` процесс осуществлять инициализацию。\n\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //вводить код здесь \n    \n}\nmodule BuildCastle {\n    //вводить код здесь\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //вводить код здесь\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //вводить код здесь\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //вводить код здесь\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Глава 5 процесс многих возвращаемых значений",
            instruction: `##  Глава 5 процесс многих возвращаемых значений\n\n в главе 5 содержится описание процесса и приводятся примеры того, как следует использовать процесс, имеющий возвращаемое значение.  Однако во многих случаях, мы часто надеемся, что один процесс может иметь несколько возвращаемых значений, в этой главе мы покажем, как подготовить процесс с несколькими возвращаемыми значениями.  \n\n Как известно в соответствии с главой 5, процесс одного возвращаемого значения может быть описан так ：\n\n\`\`\`\npublic имя процесса (имя параметра 1，имя параметра 2，...) : тип возвращаемого значения {...}\n\n\`\`\`\n\n Аналогично, мы возьмем пример двухвозвращаемых значений, метод заявления процесса многих возвращаемых значений показан как ：\n\n\`\`\`\npublic имя процесса (имя параметра 1，имя параметра 2，...) : тип возвращаемого значения*тип возвращаемого значения{...}\n\n\`\`\`\n\n метод вызова：\n\n\`\`\`\n переменная 1, переменная 2, ...  = имя модули.имя процесса (параметр 1，параметр 2，...))\n\n\`\`\`\n\n при использовании процесса многих возвращаемых значений надо обратить внимание на такие моменты：\n\n1. когда процесс с несколькими возвращаемыми значениями выполняется с одним возвращаемым значением, фактически происходит операция между только последным возвращаемым значением процесса многих возвращаемых значений и возвращаемым значением процесса одного возвращаемого значения.  \n\n    например, в приведенном ниже примере Line 2 имеет процесс с несколькими возвращаемыми значениями, когда Line 18 вызывает его, первые два возвращаемых значений являются результатом операции, а третьему возвращаемому значению нужна операция с процессом \`bar()\`. \n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\n\`\`\`\n\n2. процесс с несколькими возвращаемыми значениями может быть непосредственно использован в качестве параметра другого процесса с несколькими параметрами.  \n\n   например, в следующем коде два процесса возвращаемого  значения Line 2 непосредственно становятся первыми двумя параметрами процесса с тремя параметрами в Line 23. \n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\n\`\`\`\n\n3. Если фраза возврата процесса с несколькими параметрами появляется в разделефразы, проверьте совпадают ли тип и количество возвращенных значений в каждой ветви. \n\n   например в коде ниже，возвращаемые значения процесса \`bar()\` появляются в Line 6 ~ Line 10, и возвращаемое значение двух фраз return составляет u64, что соответствует заявленному типу процесса.  \n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\n\`\`\`\n\n### практика \n\n в модули \`BuildCastle\`добавлять процесс\`racial_judgment()\`，и осуществлять фукции：по серийному номеру замка, который соответствует расе, возвращаться к исходной экономической мощи и военной мощи.\n\n1. извлечь расовых разрядов из серийных номеров с помощью операций Мод и деления (седьмой разряд серийных номеров) ；\n2. экономический сил и военный сил в соответствии с разряду расы определяются через разветвленные фразы, соотношение между разрядом и мощью показано ниже：\n\n|  разряд расы  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| экономический сил |  6   |  8   |  3   |  7   |  4   |\n| военный сил |  6   |  3   |  8   |  4   |  7   |\n\n3. Это процесс имеет два \`u64\`возвращенных значений，один является значением экономического сила, другой является значением военного сила.\n\nподсказка：\n\n как перехватить m - ый разряд из n - значного числа ？\n\n- n - значное число Num，если хотить  перехватить первые x биты, можно использовать целочисленное делениеNum / 10<sup>x</sup>，результат операции - номеры, соответствующие первым x битам , например，54312 / 10<sup>5-2</sup>=54；\n- n - значное число Num，если хотить  перехватить последние x биты, можно использовать MODNum / 10<sup>n-x</sup>，остаток, полученный в результате этой операции -  цифры, соответствующие конечным x битам ，например，54312 / 10<sup>2</sup>=12；\n- n - значное число Num， если необходимо перехватить промежуточные x биты, то сначала надо превращать вопрос в получеие первых x биты или последние x биты, а затем проводить вычисление.  \n\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //вводить код здесь \n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Глава 6 совершенствование конструкции замка ",
            instruction: `## Глава 6 совершенствование конструкции замка \n\n в главе 3 мы узнали, как обозначить структуру, и в этой главе мы будем продолжать изучать, как инициализировать структуру и использовать ее в процессе \`main()\`. \n\nКак показано ниже, мы часто инициализируем структуры через создание процесса, и записываем заявления о структуре и процесс инициализации в тот же модуль. Тип возвращаемых значений, который соответствует процессу инициализации структуры, является типом структурного тела, и инициализируем его, возвращая переменный член в структуру исходного значения.  \n\n<img src=${require("../../static/images/lesson2/pic_2_6_1_en.png")} style="width:80%;position:relative;left:10%">\n\n например：\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\n\`\`\`\n\n  в этом примере в модуле\`Bar\`, мы описываем структуру\`T\`, а также инициализируем переменные членов структуры в параметры процесса через процесс\`new\`.  \n\n  в процессе\`new\`Мы возвращаем структуру\`T\`, значение переменной члена\' baz \ 'является параметром процесса\`m\`.  \n\n Следует отметить, что в указанном коде формы Line 6 - Line 8 похожи на определение структуры, но это только выражение\`return\` и поэтому в конце предложения есть точка с запятой. \n\n  когда мы хотим использовать структуру\`T\` в процессе\`main()\` или других процессах, можно указать переменные как типы структуры через ключевые слова\`let\`, и осуществлять инициализацию путем процессом\`new\`.\n\n например： Нижеследующий код инициализирует переменную \`x\` в структуру \`T\`с переменной члена, значение которой равно 10：\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\n\`\`\`\n\n### практика \n\n В предыдущих главах мы изучали, как * * создать соглашение * *, * * модуль в Move * *, переменные , типы данных и их право собственности * *, * *процессы в Move и процессы многих возвращаемых значений* *,* * программную структуру в Move * * , * *построение и использование структуры * *, * *часто используемые операторы в Move* * ит.д. Теперь мы завершили несколько важных этапов, необходимых для строительства замка.  Затем нужно собрать их и осуществлять строительство замки в процессе\`main()\`.\n\n1. в модуль\ 'BuildCastle \'  добавлять процесс\ 'newCastle \' для инициализации переменной типа структуры \`Castle\`, данный процесс имеет два параметра ：\n\n   - \`_name (bytearray)\`：имя замки\n   - \`_SerialNum (u64)\`：серийный номер замки \n\n   обратите внимание：для отличия  \`name\`от \`SerialNum\`в\`main()\`，Мы сделали подчёркнутый перед именем параметра .\n\n   данный процесс имеет один возвращамое значение, тип является \`Self.Castle\`.\n\n   Подражайте примерам, приведенным в уроке, в процессе осуществляйте инициализацию данных о замке в соответствии с вышеупомянутыми параметрами（\`_name\`, \`_SerialNum\`）\n\n   подсказка：название замка и его серийный номер инициализированы в соответствие с параметрами, ранг замка был инициализирована как 1, экономическая и военная мощь замка была инициализирована как вычисленное значение вызов в процессе вызова\`racial_judgment()\`.\n\n2.  В процессе\`main()\` название замка должно быть введено пользователем, поэтому параметр \' name \ ' введен извне, и нам нужно добавить в процесс\`main()\`параметр именем \`name\` , тип является \`bytearray\`.\n\n3. В\`main()\` добавлять переменную\`castle\` и инициализировать ие, помните, что слова \' let \ ' должны быть вставлены перед ними.  \n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //вводить код здесь \n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n// исправлять \nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //вводить код здесь\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //вводить код здесь\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial: " Урок 3",
    title: "",
    intro: [" В предыдущих занятиях мы строили основную структуру замки,  в следующем третьем уроке мы добавим кирпич к замку, чтобы он выглядел более безопасным.", "Понимать концепцию \"Ресурс\"; как создавать и уничтожать ресурсы; как создавать мультифайловую структуру "],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "Глава 1 ресурсы",
            instruction: `## Глава 1 ресурсы\n\n  В существующей системе блокчейне, бит - монета программирует "валюту", Эфириум программирует  "приложение", по сравнению с тем, что Libra программирует "активы", которые называются "ресурсами" и представляют собой более сложный тип активов, чем валюта.  \n\n Move требует,что использованию ресурсов надо отвечать двум условиям：\n\n- ** обеспечение дефицитности * *: общий объем ресурсов должен контролироваться, пользователь не может копировать, повторно использовать или выбрасывать ресурсы по своему усмотрению.  \n- **ограничение на доступ* *: посещение ресурсов должно соответствовать определенным заранее установленным правилам.  \n\n  Для выполнения этих двух условий в договоре Move ресурсы могут создаваться или уничтожаться только модулями, определяющими ресурс, и могут бытьуправлены только \ 'move () \' , иными словами, мы не можем использовать\ 'copy () \' для скопирования ресурсов.  \n\n транслятор Move статически проверяет соблюдение вышеупомянутых требований безопасности с помощью битового кода, и он будет отказывать в выполнении кода программы, который не был проверен через байт.\n\n для начинающих можно временно понимать ресурсы как ограниченные структуры. \n\n заявление ресурса налогично структуре, указано через \`resource имя ресурсов{данные1: тип, данные2: тип, ...}. \n\n В следующем показан пример заявления на ресурс монет Libra：\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### практика \n\n  из безопасности нам необходимо преобразовать эту структуру замка в ресурс.\n\n1. Преобразуйте тип\`Castle\`из структуры в ресурс。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	// исправлять struct\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: " Глава 2 Создание ресурсов ",
            instruction: `## Глава 2 Создание ресурсов \n\n для того чтобы использовать ресурсы, сначала мы должны осуществлять процесс создания ресурсов, тип возвращатного значеня которого является типом ресурсов. \n\n например，следующий код - это процесс создания\`LibraCoin\`, о котором говорилось в предыдущем уроке, в ходе которого была создана переменная ресурса\`T\`, значение которой составляет 0.  \n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\n  Очевидно, что создание ресурсов очень напоминает инициализацию конструкций.  \n\n### практика \n\n Затем мы осуществим процесс создания ресурсов.  \n\n В этой главе мы введем понятие аккаунта, каждый игрок имеет один аккаунт, этот аккаунт имеет его соответствующий замок, мы надеемся, что через аккаунт замок будет ассоциирован с игроком.  \n\n в последующих занятиях мы расскажем о конкретных функциях и операциях со аккаунтами, и эта глава пока будет создана только для модулей и ресурсов, связанных со аккаунтами.  \n\n1. В модули \`BuildCastle\` создать модуль именем \`CastleAccount\`. \n\n2. В новом модули указать ресурс \`CastleAccount\`，из цели практики，данный ресурс только имеет одну переменную\`u64\`，название ресурса \`a\`，мы будем совершенствовать этот ресурс позднее, когда он будет использован.  \n\n3. При создании ресурсы\`CastleAccount\` осуществлять поцесс \`newAccount\`，в этом процессе инициализировать переменную \`a\` как 0。 \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//создать новый модуль здесь\n//заявлять ресурсы аккаунта в модули\n//осуществлять процесс сздания аккаунта в модули\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Глава 3 уничтожение ресурсов ",
            instruction: `## Глава 3 уничтожение ресурсов\n\n Поскольку в языке Move не существует механизма утилизации отходов, после использования ресурсов их необходимо значительно уничтожить.  \n\n  в коде Move мы обычно достигаем уничтожения ресурсов путем опорожнения ресурсов на пустое место через \`Move()\`.\n\n Давайте рассмотрим простой пример，это процесс уничтожения \`LibraCoin\`：\n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n        T { value } = move(coin);\n        return;\n}\n\`\`\`\n\nв этом процессе сначала мы должны указать местную ресурсную переменную\`T\` с переменной члена \`value(u64)\` внутри процесса，дальше вновь привязать\`coin\`, которое мы уничтожим через\`move()\`к местной ресурсной переменной \`T\`。после окончании процесса，местная ресурсная переменная\`T\`будет автомотически уничтожена，а ресурс\`coin\`становится ресурсом без привязки и не может быть посещен. Из-за того, что систем будет извлечь ресурс без привязки, таким образом ресурс\`coin\`будет уничтожен. \n\n### практика \n\n Мы уже совершаем создание ресурсов\`Castle\` и  \`CastleAccount\`，дальше осуществим процесс уничтожения.\n\n1. В модули\`BuildCastle\`создать процесс \`desCastle\`, и совершать данный процесс с помощью примера в уроке，назваие параметра данного процесса\`castle\`，название временной переменной в процессе совпадает с названием, использанным в  предыдущей учебной программе .\n2. В модули \`CastleAccount\`создать процесс \`desAccount\`，и совершать данный процесс с помощью примера в уроке, название параметра\`account\`，название временной переменной в процессе\`num\`。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    //осуществлять процесс уничтожения ресурсы Castle \n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //осуществлять процесс уничтожения ресурсы CastleAccount \n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Глава 4 использование ресурсов ",
            instruction: `## Глава 4 использование ресурсов \n\n после создания ресурсов, мы сможем их использовать. \n\n ресурсы используются практически так же, как и структура, но разница в том, что мы должны уничтожить ресурсов после их использования.  \n\n В этой главе мы исходим из того, что ресурсы будут использоваться только в текущем сценарии операций и пока не будут отправляться на какой - то адрес , поэтому надо уничтожить русурсы до совершения \`main()\`.\n\n Далее мы приведем пример для того, чтобы понимать использование ресурсов и повторять их создание и уничтожение. \n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\n в примере мы заявляем один модуль\`MoneyHolder\`，в данном модули есть ресурс\`T\`，этот ресурс был создан через процесс Line 5 и уничтожен через процесс Line 8.  \n\n Следует отметить, что член переменной ресурса T также является ресурсом.  Поэтому для уничтожения \`T\` необходимо произвести два уничтожения （то есть Line 10 и Line 11），среди них во втором уничтожении использовать процесс \`LibraCoin.destroy_zero()\`при уничтожении \`coin\`в модули \`LibraCoin\`.  эти элементы являются важными, о которых идет речь в двух предыдущих главах, и в случае их забвения просим своевременно повторить их.  \n\n дальше надо посмотреть часть \`script\`，в первых двух строках процесса \`main()\`указаны две переменные ресурса ，один является \`LibraCoin.T\`，другой  является  \`MoneyHolder.T\`, который был указан нами сами。 После заявления переменных мы будем инициализировать переменные, так как они не могут быть использованы без инициализации.  \n\n в Line 21\` LibraCoin.zero()\`является процессом инициализации для ресурсы \`LibraCoin.T\`，данный процесс официально определяется в модули \`LibraCoin\`Libra，здесь не бедет анализировать.\n\n в Line 22 \`MoneyHolder.new(move(coin))\`является определенным нами процессом создания ресурсов, после инициализации\`money_holder\` можно использовать эту переменную.  \n\nобратите внимание：здесь параметр является \`move(coin)\`，а не\`copy(coin)\`，дае в следующем хотим использовать переменную \`coin\`, мв не моем использовать \`copy()\`，потому что\`coin\`является ресурсом，а ресурс только может быть \`move()\`，а не\`copy()\`。\n\n В данном примере мы не осуществим операцию для \`money_holder\`，поэтому дальше надо уничтожить его чтобы закончить соглашение. Обратите внимание，здесь в процессе параметр может быть\`move()\`，а не \`copy()\`。\n\n в общем，для совершения полного процесса использования ресурсов, сначала надо указать ресурсную переменную через\`let\`, а затем с помощью процесса создания ресурсов инициализировать данную переменную, после использования использовать процесс создания ресурсов уничтожить переменную, как показано ниже.  \n\n<img src=${require("../../static/images/lesson3/pic_3_4_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n### практика \n\n В предыдущих главах мы завершили процесс строительства и уничтожения замка, но пока этот соглашение не может быть успешно скомпилирован, так как нам нужно еще совершенствовать процесс создания и уничтожения ресурсов в \`main()\`. \n\nпримечание：из-за того, что русурс аккаунта не имеет практических действий, мы не используем его в\`main()\`. Если нужно использовать ресурс \`CastleAccount\`，мы можем через\`newAccount\`и \`desAccount\` создать и уничтожить его。\n\n1. в\`main()\`дабавляется фраза уничтожения ресрсы\`Castle\`.\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //вводить код здесь\n\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "Глава 5 разбивка файла",
            instruction: `## Глава 5 разбивка файла\n\n  когда до этого урока, верим, что вы заметили, что наш файл кода становится все длиннее и длинее, мы хотим разделить его на несколько файлов, чтобы облегчить управление и повысить удобочитаемость кода.  \n\n Итак, в этой главе мы вычистили код справа, и теперь вы можете видеть, что в начале редактора есть несколько вкладок, которые вы можете щёлкнуть на вкладке для переключения файлов.  \n\n Как видите, вкладка разделена на активную и на фиксированную, среди которых активная вкладка может быть отредактирована и исправлен и проверян в практике, но фиксированная вкладка только для чтения, которую мы можем просмотреть в процессе обучения, но не можем редактировать.  \n\n В общем, мы поместим один модуль в одном файле, и вводить его в этот модуль при необходимости через \`import адрес.имя модули\`，Это было описано в главе II первого урока.  Таким образом, мы можем легко поддерживать, управлять и обновлять различные модульные функции.  \n\n###  практика \n\n  мы создали многофайловую структуру и завершили разделение модулей, дальше просим добавить в файл раздел, посвященный сценарию операций, который был завершен раньше.  \n\n1. Просматривайте установленные модули и завершайте содержание сценарий операцийи на текущей вкладке.  \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//вводить код здесь",
                    answer:"import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code:"module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code:"module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code:"module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lessons = [lesson1, lesson2, lesson3];

export default lessons;


