import React from 'react';
import L1c1 from '../L1C1/L1C1'

const lesson1 = {
    info : {
        name: "움직이는 캐슬",
        subname: ["Libra Move의 게이미피케이션", "*Libra move Commit 61649eb를 기초로 하여"],
        intro: "현존하는 블록체인 시스템 내에서 비트코인은 “화폐”, 이더리움은 “애플리케이션”에 대해 각각 컴퓨터 프로그램을 작성하였는데 이에 비해 Libra는 “자산” 프로그램을 작성하였다. \n\n Libra 내에서 화폐보다 더욱 복잡한 자산 종류에 대한 정의를 내릴 수 있는데 이와 같은 자산은 “자원”이라고 한다. Libra는 Move언어를 이용하여 자원 사용을 제한함으로써 부적합한 변경을 방지하여 자산의 안전성을 제고한다. \n\n Move는 Libra 블록체인 시스템에게 안전하고 프로그램 작성이 가능한 기초를 제공해 주는데 해당 언어는 “자산” 프로그램의 제작 방식 및 그 안전성에 대해 엄격히 제한함으로써 디지털 화폐 발행, 블록체인 시스템 내의 거래 및 서버에 대한 관리에 특히 적합하도록 한다. \n\n본 수업에서 Move언어를 이용하여 캐슬을 세우고 해당 캐슬의 확장 및 대결 등 기능을 설정함으로써 초보자들이 해당 언어를 더욱 빠르게 습득하도록 한다.",
        goback: "← 뒤로가기",
        editor: "에디터",
        lesson: "레슨",
        copyAnswer: "정답 복사",
        learnmore: "자세히 알아보기",
        start: "시작하기",
        indexpage:"https://www.learnlibramove.com",
        learninide:["과정의 코드는 ChainIDE에서 컴파일 할 수 있습니다","ChainIDE로 가기"],
        practice: "지금부터",
    },
    local:{
        hint: "힌트",
        previous: "앞글로 돌아가기",
        next: "다음 글로 가기",
        catalog: "목차",
        checkcode: "코드검사",
        showAnswer: "정답 보기",
        hideAnswer: "정답 숨기기",
        contitle: ["본 장의 내용을 수료하였습니다~", "본 수업을 수료하였습니다~", "더욱 다양한 내용이 기다리고 있습니다"],
        concontent: ["“계속하기”를 클릭하여 새로운 도전을 시작하세요！", "본 수업은 여기까지입니다, “돌아가기”를 클릭하여 목차 페이지로 가십시오!\"다음 레슨\"을 클릭하여 천칭 자리에 대한 새로운 지식을 계속 배우십시오!", "Hi~축하드립니다. 현재 모든 수업 내용을 수료하셨습니다~곧 더욱 많은 수업으로 다시 찾아 올 예정입니다. 지금 바로 ChainIDE로 가서 자기만의 Libra Move계약서를 작성하시지오"],
        concontinue: ["계속하기", "돌아가기", "ChainIDE로 가기", "다음 수업"],
        shut: "닫기",
        target: "수업 소개",
        keypoint: "키포인트",
        detail: "자세히 보기"
    },
    lessonserial: "제1과",
    title: "",
    intro: ["제1과에서 자기만의 캐슬을 짓는데 기초를 잡고 유일무이한 외형 및 의외의생물이 그 안에 거주하도록 방향을 가르쳐 준다. ", "계약 작성 방식; Move 중인 모듈;Move 중인 main();변량 및 데이터 종류;Move 중인 프로세스"],
    key: 1,
    total: 5,
    chapters: [
        {
            title: "제1장 소개",
            instruction: `## 제1장 소개\n\n제1과에서 우리는 캐슬을 건설하는 방법에 대해 배울 예정입니다. \n\n- 모듈을 이용하여 새로운 캐슬을 건설할 것이다.\n- 세워진 캐슬은 데이터 베이스에 저장될 것이다.（Libra블록체인 시스템）\n\n이후의 수업 내용에서 세워진 캐슬들의 기능은 점차 높아지게 된다. 예를 들면 스스로의 실력을 높이거나 기타 게이머들의 캐슬들과 전쟁이 발생하는 등이 있는데 우선 성의 기능을 강화해야 한다. \n\n### 이러한 캐슬은 어떤 특징을 갖고 있는가?\n\n각각 성마다 이름, 시리얼넘버, 레벨, 경제력 및 군사력을 갖고 있다. 그 중에서 시리얼넘버는 성의 외형 및 성 안에 있는 생물의 종족, 레벨은 성의 가치를 각각 결정하고 경제력과 군사력은 해당 성이 기타 성과 교류할 때의 표현에 영향을 미치게 된다.\n\n### 시리얼넘버는 구체적으로 어떻게 캐슬을 영향하게 되는가? \n\n성의 외관과 종족은 시리얼넘버에 의해 결정되고 시리얼넘버는 여덟자리 수의 자연수로 이루어 진다. 예를 들면 83451029。\n\n시리얼넘버의 자릿수마다 캐슬의 한 가지 특징과 대응된다. 구체적으로는 아래와 같다. \n\n|  1   |  2   |  3   |    4     |    5     |    6     |  7   |    8     |\n| :--: | :--: | :--: | :------: | :------: | :------: | :--: | :------: |\n| 사이즈 | 모양 | 컬러 | 로고 모양 | 로고 컬러 | 로고 위치 | 종족 | 특별 표기 |\n\n게임의 취미성을 고려하여 시리얼넘버는 캐슬을 건축할 때의 블록의 깊이에 따라 무작위로 생성되며 사용자 스스로 결정된 것이 아니다. 물론 이로 인해 성의 외형이 불확실하다는 것은 아니다. 왜냐하면 캐슬을 건축하는 동시에 생성된 시리얼넘버가 이미 하나의 고정값이기 때문이다.  새로 건축된 캐슬의 명칭은 사용자가 직접 입력하고 레벨 고유값은 레벨 1이며 최초의 경제력 및 군사력은 시리얼넘버 중의 종족의 지위에 의해 결정된다. 구체적인 대응 관계는 아래와 같다. \n\n|  종족의 지위  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| 경제력 |  6   |  8   |  3   |  7   |  4   |\n| 군사력 |  6   |  3   |  8   |  4   |  7   |\n\n### 실전연습\n\n1. 화면 오른쪽의 슬라이드 버튼을 움직여 부동한 시리얼넘버가 각각 대응하고 있는 캐슬의 외형들을 구체적으로 살펴 보십시오.\n\n\n **이와 같은 기초 내용에 대해 학습한 후, 다음 장의 내용을 클릭하여 계속해서 Move언어에 대해 배워보세요**。\n\n`,
            type: 1, 
            show(){
                return <L1c1 lang="5"/>
            }
        },
        {
            title: "제2장 계약 및 모듈",
            instruction: `## 제2장 계약 중의 모듈\n\n계약은 블록체인 시스템에서응용되는 컴퓨터 프로그램이다. 계약을 응용함으로써 블록체인 시스템에서 계좌이체, 상품 구매 등 다양한 내용을 실현할 수 있다. \n\nMove계약의 코드 전체는 두 개 부분으로 나뉜다.\n\n- \`modules:\`로 시작하는 모듈 부분\n- \`script:\`로 시작하는\`main()\`\n\n본 장의 내용에서\`modules\`부분에 대해 소개하고 다음 내용에서 \`script\`부분의 내용에 대해 소개할 것이다.\n\n### 모듈\n\n모듈 부분에는 계약 전체에 필요되는 모듈이 포함되었다. （\`Module\`），모듈은 Move계약의 기본 캡슐화 단원으로서 Libra에 분포된 모듈은 모두 전체에 작용된다.\n\n모듈 내에서 구조(\`Struct\`), 자원(\`Resource\`)및 절차(\`Procedure\`）에 대해 정의를 내릴 수 있는데 이와 같은 정의에 대해서는 이후의 내용에서 소개해 드릴 것이다.\n\n모듈은 이더리움 중의 스마트 계약과도 유사성이 있고 Java언어 중의 일부 타입과도 비슷하다. 모듈을 전체적으로 일정한 기능을 가진 코드 덩어리로 볼 수 있는데 인터페이스를 통하여 모듈의 내부 정보를 찾아낼 수 있다.\n\n예를 들면 \`LibraCoin\`모듈은 Libra에서 공식적으로 발표한 Libra화폐 모듈이다. 해당 모듈에는 Libra화폐의 개념 및 Libra화폐의 계좌이체, 충전 등 사용 절차가 포함된다. 개발자들이 해당 모듈을 도입한 후, 인터페이스를 빌어 관련 기능을 실현할 수 있다. \n\n#### 모듈 설치 방식\n\n \`module 모듈 명칭 { }\`의 방식으로 모듈을 설치한다. \n\n#### 모듈 도입 방식\n\nJava에서 “패키지 명칭 + 타입 명칭”이라는 도입방식과 마찬가지로 Move에서는 “주소+모듈 명칭”의 방식으로 \`import\`모듈을 도입한다. 예를 들면\n\n\`import 0x0.LibraCoin\`\n\n여기서 \`LibraCoin\`는 모듈 명칭, \`0x0\`는 해당 모듈을 발표한 계정 주소이다. 사용자들은 모두 블록체인 시스템 내에서 자신의 모듈을 발표할 수 있고 동일한 방식으로 다른 사람들이 발표한 모듈을 도입할 수도 있다. Libra에서 공식적으로 발표한 모듈 주소는 모두 \`0x0\`이다. \n\n동일한 파일에 포함된 모듈을 도입할 경우에는 \`import Transaction.모듈 명칭\`을 직접 사용할 수 있다. 예를 들면 \n\n\`import Transaction.LibraCoin\`\n\n### 실전연습\n\n캐슬을 건립하려면 우선 \`BuildCastle\`라는 모듈을 만들어야 하는데 해당 모듈 내에서 캐슬의 다양한 기능을 점차 구현해 나갈 것이다. \n\n1. 빈 모듈 만들기\`BuildCastle\`\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//코드 입력",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "제3장 계약의 main()",
            instruction: `## 제3장 계약의 \`main()\`\n\n앞 부분 내용에서 모듈을설치하는 방법에 대해 소개하였고 이어서 해당 모듈을 기초로 하여 계약 내용을 보충하는데 대해 소개하고자 한다.\n\n계약에 일회성 실행 코드를 추가할 수 있는데 이와 같은 코드를 트랜잭션 스크립트라고 부르며（Transaction Script）기타 코드와 교체하여 사용할 수 없다. 트랜잭션 스크립트는 \`script:\`를 시작 단계의 식별명으로 한다. \n\n\`main()\`는 트랜잭션 스크립트를 이행하는 입구이다. \`main()\`형식의 코드 덩어리를 “과장”이라고 하며 그 정의에 대해서는 다음 장의 내용에서 구체적으로 소개해 드릴 것이다.\`main()\`은 특별한 조작방법에 속하는데 단 한 차례만 다른 곳으로 전송되어 사용할 수 있으며 기타 조작방법에서는 사용할 수 없다. \n\n여기서 주의할 점은 \`main()\`을 포함한 모든 조작방법은 마지막에 \`return\`로 끝난다. Move컴파일러는 특히 표면적이기에 소스 코드를 직접 번역하기만 할 뿐 없어진 \`return\`'을 삽입하는 것과 같은 기타 내용은 처리하지 못 한다.\n\nMove계약을 창작할 때, 흔히 모든 내용을 일반 과정에 입력하여 모듈을 추가한 후, （\`main()\`를 제외한 과정）마지막으로 \`script\`부분에 모듈을 도입시키고 \`main()\`를 연결부로 하여 모듈 내의 조작방법의 위치를 바꾸어 다양한 내용을 구현한다. 총체적인 방식은 아래 그림에서 보여준 바와 같다. \n\n<img src=${require("../../static/images/lesson1/pic_1_2_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n주의할 점은 모듈에 기타 모듈을 도입시켜야 할 경우, 도입된 글은 모듈 내부의 맨 윗줄에 나타나야 된다. 즉  \`module 모델명칭\`아랫줄에 나타나야 한다. \`script\`부분에 모듈을 도입시킬 경우, 해당 글은\`script\`부분의 첫 줄, 즉 \`script: \`의 아랫줄, \`main()\`의 앞줄에 위치해야 한다.\n\n통틀어 말하자면 가장 기본적인 빈 계약은 다음과 같다. \n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### 실전연습\n\n이미 설치된 \`BuildCastle\`모듈을 기초로 빈 계약을 만든다.\n\n1. 우선 \`modules: \`과 \`script: \`를 첨부；\n2. \`script\`의 아랫줄에 \`main()\`첨부，\`main()\`에 \`return\`글귀를 추가；\n3. \`script\`에 \`import\를 통하여 모듈 도입\`（\`main()\`의 앞줄）。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//코드 입력\nmodule BuildCastle {\n\n}\n//코드 입력\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: "제4장 변량 지정 및 데이터 타입",
            instruction: `## 제4장 변량 지정与데이터 타입\n\n### **변량 지정**\n\n변량 지정이란 어떤 값을 하나의 변량에 지정하여 사용하는 것이다. \n\n는 Rust언어와 유사성이 있는데 Move언어는 let퀴워드를 이용하여 변량을 지정한다. 구체적인 방식은 아래와 같다.\`let 변량 명칭: 변량 타입;\`  예：\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\n변량을 지정한 후, 초기화를 진행할 수 있다. 직접 \`=\`같음표를 사용하여 초기화할 수 있다. 예：\n\n\`\`\`\nx = 5;\n\`\`\`\n\n여기서 주의할 점은 모든 절차에서 우선 변량 지정을 진행해야 한다. 즉 모든 \`let\`글은 제일 앞쪽에 위치해야 하고 코드 덩어리 중간에 \`let\`글을 추가하게 되면 컴파일에 실패하게 된다. \n\n### 데이터 타입\n\n현재 Move언어는 아래와 같은 데이터 타입들을 지원한다.：\n\n- 불린（\`boolean\`）\n- 64비트 부호가 포함되지 않은 자연수（\`uint64\`）\n- 주소（\`address\`）\n- 바이트（\`bytes\`）\n- 구조체（\`struct\`）\n- 자원（\`resource\`），Move언어만의 타입들이다.그 중에서 \`boolean\`타입에서는 \`bool\`키워드，\`uint64\`타입에서는\`u64\`키워드，\`address\`타입에서는\`address\`키워드，\`bytes\`에서는 \`bytearray\`키워드를 사용한다. 아래와 같은 방식으로 부동한 타입의 변량을 나타낼 수 있다. \n\n\`\`\`\nmain() {\n    //변량 지정 \n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //변량 초기화\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h "123abc";\n    return;\n}\n\`\`\`\n\n자원 및 구조체 표시: \n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\n그 중에서 \`f1\`과 \`f2\`는 변량 명칭이다. \n\n 주의할 점은 Move지령은 스스로 초기화할 수 없기에 초기화를 거치지 않은 변량을 사용할 수 없다.\n\n### 실전연습\n\n캐슬의 시리얼넘버는 여덟 자리 숫자로 구성되었기에 \`%\`를 계산하여 임의로 생성되는 시리얼넘버를 여덟 자리로 제한시켜야 한다. 그러나 우선, \` SerialDigits\` 이라는 변량이 필요되는데 이 변량을 이용하여 시리얼넘버의 자릿수를 표시하는데 이것이 바로 본 장의 내용이다. \n\n\`main()\`절차에  \`SerialDigits\` 를 u64 데이터 타입으로 규정하고 그 값을 8로 입력한다. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //코드 입력\n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "제5장 절차",
            instruction: `## 제5장 절차\n\n제2장에서 소개했다시피 모듈 내에서 절차를 규정할 수 있고 동시에 기타 언어의 함수와 유사성을 갖고 있다. \n\n### 절차 표시\n\n어떤 절차를 표시할 때 그 시각성, 명칭, 매개 변수 및 반환값을 표기해야 한다. 그 격식은 아래와 같다. \n\n\`시각성 절차 명칭( 매개 변수 명칭 ) : 반환값 타입\`\n\n주의: 절차 내에 매개 변수가 없을 경우에는 매개 변수명칭을 표기할 필요가 없고 반환값이 없을 경우, 반환 타입을 표기하지 않아도 된다. \n\n모듈에 포함된 절차에는 두 가지 시각성이 포함된다. \n\n- 공유적 절차（public）：공유 절차는 기타 모듈로 이동하여 사용할 수 있다. \n- 사적의 절차（private）：사적 절차는 오직 동일한 모듈 내의 절차에 사용할 수 있다. 모듈 내의 모든 자원은 사적 소유이고 공유 절차를 거쳐야만 기타 모듈에서 방문이 가능하다.\n\n표시하고자 하는 절차에 매개 변수가 없고 반환값도 없을 경우에는 아래와 같은 방식을 사용한다. \n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\n해당 절차에 매개 변수가 있을 때에는 아래와 같은 형식으로 바꿔 쓴다. \n\n\`\`\`\npublic Procedure(a: u64, b: u64) { //매개 변수가 기타 타입이거나 또는 매개 변수가 더욱 많거나 적을 때에 그 형식은 거의 비슷하다.\n    return;\n}\n\n\`\`\`\n\n주의할 점은 절차 자체도 역시 매개 변수로서 기타 절차에 도입될 수 있다.\n\n해당 절차에 반환값이 있을 경우에는 아래와 같은 형식으로 고쳐 쓴다. \n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 { //반환값이 기타 타입일 경우, 그 형식은 비슷하다.\n    return 1;\n}\n\n\`\`\`\n\n이상의 실례에서 나타난 개념들은 모두 공유 절차에 속한다. public），사유 절차일 경우 직접 \`public\`를 삭제하면 된다. \n\n### 절차의 차용\n\n절차는 \`모듈 명칭. 절차 명칭\`의 형식으로 차용된다. 동일한 모듈 내의 절차를 차용할 경우, \`Self.절차 명칭\`을 사용한다. \n\n아래 내용이 바로 절차를 표시하고 차용하는 구체적인 예시이다. \n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //공유 절차임을 표시, 절차 명칭은 Procedure\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //차용 절차, 그 중에서Contract는 모듈 명칭\n    return;\n}\n\n\`\`\`\n\n### 실전연습\n\n앞 부분 내용에서  \`%\`패턴 계산을 통하여 시리얼넘버를 여덟 자릿수로 바꾸는데 대해 소개하였다. 구체적으로 말하면 하나의 숫자 패턴10<sup>n</sup>의 결과는 n자릿수 이다. 그러므로 절차를 통하여 10<sup>8</sup>를 계산해야 한다. \n\n1. \`BuildCastle\`모듈에 수학적 계산 모듈\`Math\설치하는데 본 수업의 모든 수학적 계산 과정을 포함하고 있다. \n2. 새로 만들어진 모듈 내에 멱 계산의 과정을 표시하기\`pow()\`，구체적인 방식은 아래와 같다. \n   - 매개 변수：u64타입의 밑수 x와 지수 n\n   - 반환값：u64타입의 멱 계산 결과\n   - 절차 내용: 잠시 비어 있음, 편역하기 위하여 잠시 그 반환값을 1로 설정한다. 다음 장 내용에서 그 기능을 실현하도록 한다.\n3. \`main()\`앞에 수학적 계산 모듈\`Math\`을 추가하고 \`SerialDigits\`뒤에\`SerialLimit\`라고 하는 \`u64\`변량을 표시하는데 이는시리얼넘버의 자릿수 제한을 대표한다. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \n//코드 입력\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//코드 입력\n\nmain() {\n    let SerialDigits: u64;\n    //코드 입력\n\n    SerialDigits = 8;\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },    
    ]
};

const lesson2 = {
    lessonserial: "제2과",
    title: "",
    intro: ["제1과에서 변수와 관련된 내용에 대해 소개하였고 캐슬의 시리얼넘버를표시함으로써 캐슬 건축에 첫 번째 기초를 마련하엿다. 제2과에서 캐슬의 프레임을 세우고 자기만의 캐슬을 만들수 있도록 그 방식을 알려주고자 한다. ","소유권;Move의 프로그램 구조;구조체의 설정 및 사용;Move에서 흔히 사용되는 연산자;Move의 반환값이 1개 이상인 절차"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "제1장 소유권",
            instruction: `## 제1장 소유권\n\n### 소유권의 사용\n\n앞 부분 내용에서 “지정”이라는 단어를 제기하였는데 사실 지정이란 소유권의 지정을 가리킨다. 오직 어떠한 식별명이 모 값의 소유권을 가질 경우에만 해당 식별명을 이용하여 해당 값을 사용할 수 있다. \n\n어떤 값을 하나의 명칭（식별명）에 지정했을 때, 해당 값（자원）의 소유권을 그 식별명에 지정한 것이다. 예:\n\n\`\`\`\nlet x: u64;\nx = 3;\n\n\`\`\`\n\n\`let\`키워드로 식별명\`x\`과 \`u64\타입\`、값이 3인 자원을 지정하게 되면 \`x\`는 3에 대한 소유권을 갖게 된다. 지정 지간 동안, 해당 식별명은 해당 자원에 대한 소유권을 독자적으로 보유하고 있다. 방문하고 해당 값을 변경할 수 있지만 기타 식별명으로 변경시키기 되면 해당 식별명은 더이상 그 값에 대한 소유권을 가지고 있지 않는다. \n\n### 소유권의 변경\n\n소유권을 변경하고자 할 때, 내장 메모리의 안전을 고려하여 직접 \`=\`를 사용하지 않고 \`move()\`을 통하여 소유권을 변경할 수 있다. \n\n즉 Move언어 중에서 식별명 사이에서 \`=\`를 사용할 수 없고 오직 식별명과 값 사이에 \`=\`를 사용할 수 있다. 예를 들면 아래 코드들이 바로 잘못된 예시이다. \n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //error\n\n\`\`\`\n\n이어서 구체적인 코드를 실례로 하여 소유권의 변경에 대해 얘기해 보도록 한다.\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); //3의 소유권을 식별명x로부터 (move)식별명y\nz = move(x)로 변경; //error: 이때 식별명x는 소유권을 잃었고 초기화를 거치지 않는 변량으로 돌아 왔기에 move(x)실패\nz = move(y); //3의 소유권을 식별명y로부터 (move)식별명z\nx = 3로 변경; 	//식별명x\nz 다시 초기화 = move(x); //이때 move를 통하여 3의 소유권을 식별명x로부터 식별명z\n\n\`\`\`\n\n### 소유권의 복사\n\n어떤 경우에는 소유권을 변경하지 않는 조건 하에서 어떤 식별명의 값이 다른 한 식별명과 같은 값을 갖도록 하고자 한다. 이럴 경우에 \`copy()\`절차를 이용할 수 있다. 한 식별명을 \`copy\`하게 되면 여전히 방문이 가능하게 된다. 예：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); //3의 소유권을 가진 식별명x를 복사하여 （copy）식별명y\nz = move(x)에 붙여 준다; //3의 소유권을 식별명x로부터（move）변경하여 식별명z\n\n\`\`\`\n\n주의할 점은 절차를 이동하여 매개 변수로 옮겨 갈 때, 직접 매개 변수의 명칭을 사용할 수 없고 \`move(매개 변수 명칭)\`또는 \`copy(매개 변수 명칭)\`의 형식으로 소유권을 변경해야 한다. 매개 변수가 코드 앞, 뒤에서의 사용 내용에 따라 \`move\`또는 \`copy\`를 결정해야 한다.\n\n### 실전연습\n\n지난 수업에서 \`SerialLimit\`에 대해 소개하였다. 이어서 \`SerialLimit\`의 값을 10<sup>SerialDigits</sup>로 설정하고자 한다. 그렇다면 \`pow()\`절차를 이용하여 \`SerialLimit\`에 대해 초기화해야 한다 . 해당 절차에서의 매개 변수는 각각 10과 \`SerialDigits\`이다. \n\n상술한 바와 같이 변수를 매개 변수로서 \`pow()\`절차에 이동해야 하기에 소유권의 변경과 연관성이 있다. \`SerialDigits\`는 뒷 부분 내용에서 다시 사용할 수 있기에  여기서는 \`copy()\`를 사용해야 한다. 현재 \`pow()\`절차는 여전히 비어 있지만 다음 장의 내용에서 소개할 예정이다. \n\n \`main()\`에서  \`pow()\`를 차용하여 \`SerialLimit\`를 초기화하고 그 방식은 \`모듈 명칭.절차 명칭\`이다. 이는 지난 수업에서 소개했던 내용인데 기억이 잘 나지 않으면 제때에 복습하길 바란다. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //코드 입력\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "제2장 프로그램 구조",
            instruction: `## 제2장 프로그램 구조\n\n기타 언어와 마찬가지로 선택과 순환 등 Move언어에서 흔히 쓰이는 프로그램 구조가 있다. \n\n\`if-else\`로 심플한 선택 구조를 표현할 수 있다. 구체적인 규칙은 아래와 같다. \n\n1. 조건문은 단 한마디일 지라도 반드시 대괄호\`{}\`로 표기해야 한다. 아래와 같은 예시가 바로 잘못된 사용방식이다. \n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;	//여기서  x = 3 에 대괄호로 표기해야 한다. \n       return;\n   }\n   \`\`\`\n\n2. 조건문의 반구절점\`;\`구절 마지막 부분에 사용하고 대괄호 뒤에 반구절점을 표기할 필요가 없다. 아래의 예시 역시 잘못된 사용방식이다. \n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;\n       else {\n           x = 5\n       };	//여기서 반구절점은 윗줄 마지막 부분에 나타나야 한다. \n       return;\n   }\n   \`\`\`\n\n3. 어떤 식별명의 초기화가 조건문에 따라 진행되었고 해당 조건문은 모든 경우를 포함하지 않을 경우, 이 과정이 종료되면 해당 식별명은 더이상 방문이 불가능하다. 아래는 잘못된 사용법에 대한 예시이다. \n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       }	//여기서 오직 if라는 조건 하에서 변수 x에 대해 초기화를 진행하였고 else조건하에 대응되는 경우에서 변수 x는 초기화를 거치지 않았기에 copy를 응용하여 x\n       assert(copy(x) == 42, 42)를 방문할 수 없다;\n       return;\n   }\n   \`\`\`\n\n   그러나 만약 모든 경우를 포함하는 경우에 그 과정이 종료된 후에도 해당 식별명을 방문할 수 있다. 아래는 정확한 방식에 대한 예시이다. \n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } else {\n           x = 43;\n       }	//여기서 두 가지 조건인 true와 false는 모든 경우를 다 포함하고 있기에 그 어떤 조건 하에서도 변수 x는 모두 초기화될 것이다. 그러므로 다음 단계에서 copy\n       assert(copy(x) == 42, 42)은 성립된다;\n       return;\n   }\n   \`\`\`\n\n4. 조건문에서 \`move()\`을 진행할 때 반드시 소유권에 대해 주의해야 한다. 조건에서 \`move()\`된 식별명은 해당 과정이 끝난 후에는 재방문이 불가능하다. 아래는 잘못된 사용법에 대한 예시이다. \n\n   \`\`\`\n   main() {\n       let x: u64;\n       let y: u64;\n       x = 0;\n       if (true) {\n           y = move(x);	//해당 조건 하에서 변수 x의 소유권을 변수 y로 변경해 주었기에 그 후의 코드에서 더이상 copy(x)로 변수x\n       }\n       assert(copy(x) == 0를 방문할 수 없다, 42);\n       return;\n   }\n   \`\`\`\n\n\`loop\`로 순환 구조를구축할 수도 있는데 오늘은 시간관계 상 구체적으로 소개하지 않고 다음 부분의 내용에서 소개하기로 한다. \n\n### 실전연습\n\n멱 함수의 가장 흔히 볼 수 있는 실현방식이 바로 귀납이다. 다음은 C언어에서 멱 함수에 관한 실례이다. \n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\n\`\`\`\n\n이상 프로그램을 모방하여 \`Math\`모듈 내에서 \`pow()\`의 구체적 내용을 표현하세요. 유의할 점은 변수의 소유권 문제 및 \`copy\`과 \`move\`를 알맞게 사용해야 한다\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //코드 입력\n        \n        return 1; // 이 구절을 삭제return\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第三章 구조체",
            instruction: `## 제3장 구조체\n\nMove언어에서의 구조체는 기타 언어와 마찬가지로 동일한 타입 또는 부동한 타입의 여러가지 데이터로 구성된 데이터 집합체이다. \`struct 구조체 명칭{데이터1: 타입, 데이터2: 타입, ...}\`의 형식으로 나타낸다. 예：\n\n\`\`\`\nmodule Test {\n	//빈 구조체\n  	struct Empty1 { }\n  	//두 가지 요소가 포함된 구조체\n  	struct T { a: u64, b: u64, }\n}\n\n\`\`\`\n\n주의\n\n- 구조체는 반드시 모듈의 맨 처음에 나타내야만 하고 중간에 나타내서는 안 된다. \n- 구조체는 \`copy\`또는 \`move\`\n\n할 수도 있다. 구조체에 대한 더욱 많은 사용법은 다음 장의 내용에서 소개하기로 한다. \n\n### 실전연습\n\n \`BuildCastle\`모듈 내에서 구조체 표현\`Castle\`，5가지 요소를 포함：\`name(bytearray)\`, \`SerialNum(u64)\`, \`level(u64)\`, \`economic(u64) \`和\`military(u64)\`。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//코드 입력\n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "제4장 계산방식",
            instruction: `## 제4장 계산방식\n\n앞 부분 내용에서 덧셈, 곱셈 등 초 계산법에 대해 소개해었다. 이어서 Move에서 이미 선보인 몇 가지 계산법에 대해 구체적으로 소개하고자 한다. \n\nMove언어에서 현재 아래와 같은 계산법이 사용 가능하다. 더하기 \`+\`  빼기 \`-\` 곱하기\`*\`나누기\`/\`모\`%\`，구체적인 사용방식은 아래와 같다：\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\n\`\`\`\n\n비교법도 가능하다：크기\`>\`、작기\`<\`、같다\`==\`、크거나 같다\`>=\`、작거나 같다\`<=\`、같지 않다\`!=\` ，구체적인 사용방식은 아래와 같다：\n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\n\`\`\`\n\n이외에도 Move에서는 몇 가지 이진법 계산 및 불린 계산법 등을 실현하였는데 시간관계 상 다음 편에서 소개하기로 한다. \n\n### 실전연습\n\n현재 모듈의 깊이에 따라 임의의 캐슬 시리얼넘버를 형성하고자 한다.\n\n가장 기초적인 난수 생성법은 모 계산법을 통해 얻어 낸 것이다.\n\n아래는 C언어에서 간단한 의사 난수를 형성하는 예시인데 보시다시피 이와 같은 프로그램에서  얻어낸 난수열은 \`next\`최초값의 선택에 의해 결정된다.\n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\n\`\`\`\n\n해당 프로그램을 기초로 하고 약간의 변화를 거치면 다음과 같이 \`seed\`로부터 난수를 계산해내는 프로그램을 만들 수 있다. \n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\n\`\`\`\n\n기타 언어와 똑같은 방식으로 모 계산법을 이용하여 해당 코드로 지정 범위 내의 난수를 최종적으로 얻어내도록 할 수 있다. 구체적으로 말하자면 \`m\`부터 \`n\`까지의 난수를 얻어 내자면 아래와 같은 코드를 사용할 수 있다. \n\n\`\`\`c\nmyrand(seed) % (n - m + 1) + m;\n\n\`\`\`\n\n1. 상술한 난수 생성 프로그램으로 \`Math\`모듈 내에 난수를 생성하는 \`myrand()\를 추가하고 그 구체적인 기능을 구현하도록 하세요. \n2. \`BulidCastle\`모듈 내에 공적 절차\`generateSerial()\`를 추가 및 사용이 가능하도록 하시오. 해당 절차는 블록 깊이에 따라 \`Math\`모듈의 \`myrand\`절차를 차용하여 임이로 여덟 자릿수의 시리얼넘버를 생성（즉10<sup>7</sup>부터 10<sup>8</sup>-1사이의 난수），매개 변수는 시리얼넘버의 자릿수 제한\`SerialLimit\`，반환값은\`u64\`。\n   - 블록 깊이는 \`Block\` 모듈의 \`get_current_height()\` 방식으로 찾아낼 수 있다. \n   - \`Block\`모듈의 주소는 \`0x0\`。\n   - 적합한 곳에 \`Math\`모듈 및 \`Block\`모듈을 도입하시오/ \n3. \`main()\`에 \`SerialNum\` 를 추가 및 \`generateSerial()\`절차를 통하여 초기화를 실현 \n\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //코드 입력\n    \n}\nmodule BuildCastle {\n    //코드 입력\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //코드 입력\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //코드 입력\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //코드 입력\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "제5장 반환값이 1개 이상인 절차",
            instruction: `## 제5장 반환값이 1개 이상인 절차\n\n제5장에서 여러가지 절차에 대해 소개하였고 예를 들어 반환값이 있는 절차를 어떻게 사용할 지에 대해 설명하였다. 그러나 흔히 하나의 절차 내에서 1개 이상의 반환값을 필요로 하는데 지금부터 반환값이 1개 이상인 절차를 작성하는지에 대해 소개하도록 한다. \n\n 제5장 내용에서 알 수 있다시피 반환값이 1개인 절차는 아래와 같다.\n\n\`\`\`\npublic 절차 명칭(매개 변수 명칭1，매개 변수 명칭2，...) : 반환값 타입 {...}\n\n\`\`\`\n\n마찬가지로 반환값이 두개인 절차를 예로 들어 설명하자면 ：\n\n\`\`\`\npublic 절차 명칭(매개 변수 명칭1，매개 변수 명칭2，...) : 반환값 타입 * 반환값 타입{...}\n\n\`\`\`\n\n차용 방식：\n\n\`\`\`\n변수1, 변수2, ...  = 모듈 명칭.절차 명칭( 매개 변수1, 매개 변수2, ...)\n\n\`\`\`\n\n반환값이 1개 이상일 경우, 아래와 같은 점에 유의해야 한다. \n\n1. 반환값이 1개 이상인 절차와 반환값이 1개인 절차가 계산을 진행할 때, 실제로 계산 과정에 포함되는 것은 반환값이 1개 이상인 절차의 마지막 반환값과 반환값이 1개인 절차의 반환값이다. \n\n   아래의 예를 보면 Line 2에는 1개 이상의 반환값이 있는데 Line 18에서 이를 차용할 때, 처음 두 개의 반환값은 모두 해당 절차를 통해 얻어낸 결과이다. 그러나 세번째 반환값은 \`bar()\`를 통해 계산해야 한다. \n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\n\`\`\`\n\n2. 반환값이 1개 이상은 절차는 직접 다른 하나의 매개 변수가 1개 이상인 절차의 매개 변수로 될 수 있다. \n\n   예를 들면 아래의 코드에서 Line 2에는 2개의 반환값을 가진 절차가 직접 Line 23에서 3개의 매개 변수를 가진 절차의 처음 두 개의 매개 변수로 되었다. \n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\n\`\`\`\n\n3. 1개 이상의 반환값을 가진 절차의 반환구가 조건문에 나타났을 경우, 반드시 각 분점의 반환값 타입과 수량이 일치한지 확인해야 한다. \n\n   아래의 코드에서 \`bar()\`절차의 반환값이 Line 6 ~ Line 10에 나타났고 두 개의 return구의 반환값은 모두 u64로서 절차에서 표시한 반환 타입과 일치하다. \n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\n\`\`\`\n\n### 실전연습\n\n\`BuildCastle\`모듈에 \`racial_judgment()\`절차를 추가하고 그 기능을 구현하도록 하시오. 시리얼넘버에 따라 캐슬이 대응하고 있는 종족을 판단하고 고유의 경제력과 군사력으로 반환하시오. \n\n1. 모 계산법과 나눗셈을 이용하여 시리얼넘버로부터 종족 자릿수를 선별.（시리얼넘버 7번째 자릿수）；\n2. 조건문으로부터 종족 자릿수가 대응하고 있는 경제력과 군사력 수치를 판단. 종족 자릿수와 실력값의 대응관계는 아래 도표에서 제시한 바와 같다. \n\n|  종족 자릿수  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| 경제력 |  6   |  8   |  3   |  7   |  4   |\n| 군사력 |  6   |  3   |  8   |  4   |  7   |\n\n3. 해당 절차에는 두 개의 \`u64\`반환값이 존재한다. 즉 각각 경제력값과 군사력값이다. \n\n힌트：\n\n n자릿수에서 m번째 자릿수를 찾아낼 것인가？\n\n- n자릿수는 Num，처음 x자릿수를 찾아내려면 단수처리 나눗셈으로 계산할 수 있다. Num / 10<sup>x</sup>，해당 계산법으로 얻어낸 결과가 바로 처음 x자릿수가 대응하는 숫자이다. 예: 54312 / 10<sup>5-2</sup>=54；\n- n자릿수Num，마지막 x자릿수를 찾아내려면 모 계산법을 사용할 수 있다. Num / 10<sup>n-x</sup> 해당 계산법으로 얻어낸 나머지가 바로 마지막 x자릿수가 대응하는 숫자이다. 예: 54312 / 10<sup>2</sup>=12；\n- n자릿수Num，중간 x자릿수를 찾아 내려면 우선 상술한 계산법으로 처음 x자릿수 또는 마지막 x자릿수를 찾아내는 것과 동일한 방식으로 계산하면 된다. \n\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //코드 입력\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "제6장 캐슬 디자인 추가",
            instruction: `## 제6장 캐슬 디자인 추가\n\n제3장에서 구조체를 나타내는데 대해 소개하였고 이어서 구조체를 초기화하는 방식 및 \`main()\`에서 이를 사용하는 방법에 대해 소개하고자 한다. \n\n아래 그림에서 볼 수 있다시피 흔히 어떤 절차를 만들어 구조체의 초기화를 완성하고 구조체 및 그 초기화 절차를 동일한 모듈 내에 기록한다. 그리고 구조체 초기화에 사용된 절차가 대응하고 있는 반환값 타입이 바로 구조체 타입이며 하나의 구성원 변수를 고유값으로 반환함으로써 구조체의 초기화를 완성한다. \n\n<img src=${require("../../static/images/lesson2/pic_2_6_1_en.png")} style="width:80%;position:relative;left:10%">\n\n예：\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\n\`\`\`\n\n여기서 모듈\`Bar\`에서 구조체\`T\`를 나타냈고 \`new\`이라는 절차를 통하여 구조체의 구성원 변수를 해당 절차의 매개 변수로 초기화시켰다. \n\n \`new\`과정에서 구조체\`T\`를 반환시켰고 그 구성원 변수\`baz\`의 값은 해당 절차의 매개 변수\`m\`이다. \n\n주의할 점: 상술한 코드에서 Line 6 ~ Line 8는 형식적으로 구조체의 정의와 비슷하지만 \`return\`구이기에 구절 끝부분에 반구절점이 있다. \n\ \`main()\`과정 또는 과정에서 구조체\`T\`를 사용하려는 경우, \`let\`키워드를 통하여 변수를 구조체 타입으로 표기하고 \`new\`절차를 차용하여 초기화할 수 있다. \n\n예: 아래의 코드에서 변수\`x\`를 구성원 변수값이 10인 구조체로 초기화시키세요.\`T\`：\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\n\`\`\`\n\n### 실전연습\n\n앞 부분 내용에서 **계약 작성 방식**，**Move중의 모듈**、**변수와 데이터 타입 및 그 소유권**，**Move중의 절차 및 반환값이 1개 이상인 절차*，**Move중의 프로그램 구조**，**구조체의 생성 및 사용**，**Move에서 흔히 사용하는 연산자** 등에 대해 강의하였다. 이로써 캐슬을 구축하는데 필요한 몇 가지 중요한 절차를 파악하였고 그것들을 조합시켜 \`main()\`절차에서 캐슬을 구축해야 한다. \n\n1. \`BuildCastle\`모듈 내에 \`newCastle\`를 추가함으로써 구조체\`Castle\`타입의 변수를 초기화하는데 사용해야 한다. 해당 절차에는 두 가지 매개 변수가 포함된다：\n\n   - \`_name (bytearray)\`：캐슬 명칭\n   - \`_SerialNum (u64)\`：캐슬 시리얼넘버\n\n   주의：\`main()\`중의 \`name\`및 \`SerialNum\`과 구별하기 위하여 매개 변수 명칭 앞에 밑줄을 추가하였다. \n\n   해당 절차에는 반환값이 1개이고 타입은 \`Self.Castle\`이다. \n\n  예시에 따라 해당 절차에서 상술한 매개 변수（\`_name\`, \`_SerialNum\`）를 이용하여 캐슬 데이터의 초기화를 실현하시오. \n\n   힌트：캐슬의 명칭과 시리얼넘버를 매개 변수가 대응하는 값으로 초기화시키고 캐슬의 레벨은 1로 초기화, 캐슬의 경제력과 군사력은 \`racial_judgment()\`를 이용하여 계산해는 값으로 초기화시킨다.\n\n2. \`main()\`에서 캐슬의 명칭은 사용자가 직접 입력하기에 \`name\`이라는 매개 변수는 외부 입력에 속한다. \`main()\`절차에 \`name\`이라는 매개 변수, 타입 \`bytearray\`를 추가해야 한다. \n\n3. =\`main()\`에 \`castle\`변수를 설정하고 초기화해야 한다. 주의: \`let\`구를 맨 앞에 삽입해야 한다는 점을 잊지 말 것. n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //코드 입력\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n//이 부분을 새로 고침\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //코드 입력\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //코드 입력\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial: "제3과",
    title: "",
    intro: ["앞 부분 내용에서 기초로 되는 캐슬 구조를 구축하였다. 이어서 제3과에서는 캐슬에 다양한 요소를 추가하여 안전성을 높여주고자 한다. ","자원의 정의;자원을 구축하고 없애는 방식;복수 파일 구조를 구축하는 방식"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "제1장 자원",
            instruction: `## 제1장 자원 \n\n현존하는 블록체인 시스템에서 비트코인은 “화폐”, 이더리움은 “애플리케이션”에 대해 각각 컴퓨터 프로그램을 작성하였는데 이에 비해 Libra는 “자산” 프로그램을 작성하였다. 이와 같은 자산을 “자원”이라고 한다. 자원은 화폐보다 더욱 복잡한 자산 유형이다. \n\nMove의 규정에 따르면 자원을 사용할 때 반드시 아래와 같은 두 가지 제한 조건에 부합되어야 한다. \n\n- **희소성을 보장**：자원의 총량은 반드시 제한을 받아야 하고 사용자들이 마음대로 복사, 재활용 또는 폐기해서는 안 된다. \n- **방문제한**：자원을 방문할 때에는 반드시 앞서 정해진 규칙에 부합되어야 한다. \n\n상술한 두 가지 제한조건에 부합되기 위하여 Move계약에서 자원은 오직 해당 자원에 정의를 내린 모듈에 의해서만 만들어지거나 없앨 수 있으며 \`move()\`절차만 효력이 발생한다. 즉 \`copy()\`로 자원을 복사할 수 없다는 것이다. \n\nMove컴파일러는 바이트 코드로 상술한 안전성 조건에 부합되는지 정적 검증을 진행하며 바이트 코드 검증을 통과하지 못 한 프로그램 코드를 거부한다. \n\n초보자들에게 있어서 초기에는 자원을 제한성이 있는 구조체로 이해해도 된다. \n\n자원 표기는 구조체와 유상성이 있는데 \`resource 자원 명칭{데이터1: 타입, 데이터2: 타입, ...}\`의 형식으로 표기한다. \n\n아래는 Libra코인이라는 자원 표기에 대한 예시이다.\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### 실전연습\n\n안전성을 고려하여 캐슬이라는 구조체를 자원으로 변경시켜야 한다. \n\n1. \`Castle\`의 타입을 구조체로부터 자원으로 변경시키시오.\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//修改这里的struct\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "제2장 자원의 구축",
            instruction: `## 제2장 자원의 구축\n\n자원을 이용하기 위하여 우선 자원을 구축해야 한다. 해당 절차의 반환값 타입은 자원이다. \n\n예: 아래의 코드가 바로 지난 수업에서 얘기했었던 \`LibraCoin\`의 구축 절차이다. 해당 절차를 통하여 값이 0인 자원 변수를 구축. \`T\`。\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\n자원의 구축은 구조체의 초기화와 매우 흡사하다는 점을 보아낼 수 있다. \n\n### 실전연습\n\n이어서 자원 구축의 절차를 실현해야 한다. \n\n본 장의 내용에서 계정이라는 개념을 도입할 것인데 게이머들은 모두 계정을 갖게 된다. 해당 계정은 대응하는 캐슬이 있으며 계정을 빌어 캐슬과 게이머들을 연결시키고자 한다. \n\n계정의 구체적인 기능 및 사용법에 대해서는 이후에 소개하도록 하고 본 장의 수업 내용에서는 우선 계정과 관련된 모듈 및 자원을 구축하는데 대해서만 소개하도록 한다. \n\n1. \`BuildCastle\`모듈 내에 \`CastleAccount\`이라는 모듈를 추가. \n\n2. 새로 추가한 모듈 내에 \`CastleAccount\`자원을 표기. 연습용으로 해당 자원은 단 하나의 \`u64\`변수를 갖게 되고 변수 명칭은 \`a\`，이후 해당 자원을 사용하기 전에 다른 내용을 보충하도록 한다. \n\n3. \`CastleAccount\`자원을 생성하는 절차\`newAccount\`를 추가，해당 절차는 자원 중의 변수\`a\`를 0으로 초기화시킨다. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//이곳에 새로운 모듈 추가\n//모듈 내에 계정 자원을 표기\n//모듈 내에서 계정을 설치하는 절차를 추가\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "제3장 자원의 폐기",
            instruction: `## 제3장 자원의 폐기\n\n Move언어에는 쓰레기 회수 시스템이 없기에 자원을 사용한 후, 반드시 명시적으로 폐기시켜야 한다. \n\n Move코드 내에서 흔히 \`Move()\`를 사용하여 자원의 귀속성을 해지시킴으로써 자원 폐기를 완성한다. \n\n \`LibraCoin\`의 폐기 절차를 간단히 예를 들자면 아래와 같다. \n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n        T { value } = move(coin);\n        return;\n}\n\`\`\`\n\n 해당 과정에서 우선 내부에서 한 구성원의 변수가 \`value(u64)\`의 일부 자원 변수\`T\`로 한다, 이어서 폐기하려는 \`coin\`을 \`move()\`를 통하여 다시 부분 자원 변수\`T\`로 지정한다. 이 과정이 끝나면 부분 자원 변수\`T\`는 자동으로 폐기된다. 동시에 \`coin\`자원은 더이상 귀속성이 없고 재방문하여 사용할 수도 없는 자원으로 된다.  시스템에서 어디에서 귀속되지 않은 자원을 회수하기에 자원 \`coin\`은 폐기된다. \n\n### 실전연습\n\n \`Castle\`자원 및 \`CastleAccount\`자원을 구축하였고 이어서 그들을 폐기하는 과정을 실행해야 한다. \n\n1. \`BuildCastle\`모듈 내에 \`desCastle\`절차를 추가하고 강의 내용 중의 예시를 모방하여 해당 절차를 추가한다. 해당 절차의 매개 변수 명칭은 \`castle\`，절차 중의 임시 변수 명칭은 그 전의 수업에서 사용했던 것과 동일하다. \n2. \`CastleAccount\`모듈 내에 \`desAccount\`절차를 추가하고 강의 내용 중의 예시를 모방하여 해당 절차를 추가한다. 해당 절차의 매개 변수 명칭은 \`account\`，절차 중의 임시 변수 명칭은\`num\`。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    //여기서 자원 Castle을 폐기하는 절차를 완성\n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //여기서 자원 CastleAccount를 폐기하는 절차를 완성\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "제4장 자원의 이용",
            instruction: `## 제4장 자원의 이용\n\n자원을 구축한 후, 그 자원을 이용할 수 있다. \n\n자원을 이용하는 방식은 구조체와 거의 비슷한데 한 가지 차이점은 자원을 이용한 후, 해당 자원을 폐기해야 한다는 것이다. \n\n본 장의 내용에서 현재의 거래 시스템 내에서만 자원을 이용하고 기타 주소로 전송하지 않는다고 가정한다. 그러므로 \`main()\`이 종료하기 전에 자원을 폐기해야 한다. \n\n이어서 실례를 들어 자원 이용에 대해 진일보 이해하고 자원의 구축 민 폐기에 대해 복습하도록 한다. \n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\n해당 예시에서 \`MoneyHolder\`모듈을 표기하였다. 해당 모듈에는 자원 \`T\`가 포함되어 있는데 이 자원은 Line 5를 통하여 구축되었고 Line 8을 통해 페기되었다. \n\n주의할 점은 자원 T의 구성원 변수도 역시 하나의 자원이다. 그러므로 \`T\`를 폐기하는 동시에 2차 폐기를 진행해야 한다. （즉 Line 10과 Line 11），그중에서 2차 폐기는 \`LibraCoin\`모듈 내의 \`coin\`을 폐기하는 절차\`LibraCoin.destroy_zero()\`를 차용했기 때문이다. 상술한 내용은 모두 앞 부분 내용에서 소개해 드렸던 내용들이다. 기억이 잘 나지 않는다면 제때에 복습해야 한다. \n\n계속해서 \`script\`에 대한 예시를 보도록 한다. \`main()\`절차 중의 처음 두 줄은 각각 두 개의 자원 변수를 표기한 것이다. 그 중 하나는 \`LibraCoin.T\`이고 다른 하나는 우리가 직접 표기한 \`MoneyHolder.T\`이다. 변수를 표기한 후, 변수를 초기화시켜야 한다. 그 원인은 초기화를 거치지 않은 변수는 사용이 불가능하기 때문이다. \n\nLine 21중의 \` LibraCoin.zero()\`는 \`LibraCoin.T\`이라는 자원의 초기화 절차이다. 해당 절차는 Libra의 공식적인 \`LibraCoin\`모듈 내에 속해 있기에 진일보 분석하지 않겠다. \n\nLine 22중의 \`MoneyHolder.new(move(coin))\`는 우리가 직접 정한 자원 구축의 절차이다. 해당 절차를 통하여 \`money_holder\`를 초기화한 후, 해당 변수를 이용할 수 있다. \n\n주의: 여기서 매개 변수는 \`move(coin)\`，\`copy(coin)\`이 아니다. 뒷 부분 내용에서도 여전히 \`coin\`이라는 변수를 사용하려고 해도 사용할 수 없게 된다. 그 원인은 \`coin\`은 자원이고 자원은 오직 \`move()\`가 가능하고 \`copy()\`할 수 없기 때문이다. \n\n 이 예시 내용에서 더이상 \`money_holder\`를 이용하지 않을 것이기 때문에 폐기시켜 계약을 종료해야 한다. 주의: 이 절차 내의 매개 변수 역시 \`copy()\`가 아니라 \`move()\`를 이용해야 한다. \n\n바꾸어 말하면 자원을 이용하는 전체 과정은 우선 \`let\`를 통하여 자원 변수를 표기하고 자원 구축의 절차를 차용하여 해당 변수를 초기화시킨다. 그리고 이용을 마친 후, 자원을 폐기하는 절차를 차용하여 변수를 폐기해야 한다. 아래의 이미지를 참고할 수 있다. \n\n<img src=${require("../../static/images/lesson3/pic_3_4_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n### 실전연습\n\n앞 부분의 내용에서 우리는 캐슬의 구축과 폐기 절차를 완성하였다. 그러나 \`main()\`에서 자원의 구축과 폐기를 보충하기 전까지 해당 계약은 여전히 성공적으로 컴파일할 수 없다. \n\n주의: 계정 자원이 현재 실질적인 역할을 발휘하지 않기에 \`main()\`에서 그것을 차용하지 않도록 한다. \`CastleAccount\`자원을 이용해야 한다면 \`newAccount\` 및 \`desAccount\`을 이용하여 구축 및 폐기할 수 있다. \n\n1. \`main()\`에 \`Castle\`자원을 폐기하는 구절을 추가\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //코드 입력\n\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "제5장 파일 분해",
            instruction: `## 제5장 파일 분해\n\n여기까지 이르면 대부분 코드 파일이 점차 길어졌음을 발견하게 된다. 그 파일을 여러 개의 파일로 나누어 관리하는데 있어서 더욱 편리하고 코드의 가독성을 높이고자 한다. \n\n 그러므로 지금부터 오른쪽 아랫 부분에 위치해 있던 코드를 없애기로 한다. 볼 수 있다시피 에디터의 윗 부분에 여러 개의 옵션이 추가되었고 로고를 클릭하여 파일을 바꿀 수 있다.  \n\n 뿐만아니라 옶션은 이동 옵션과 고정 옵션으로 나뉘는데 그 중에서 이동 옵션이 편집이 가능하다. 이는 실전연습 중에서 새로 고치고 검사하게 될 파일이기도 하다. 이에 반해 고정 옵션은 읽기 전용이다. 학습 과정에서 보고 확인할 수는 있지만 고치지는 못 한다. \n\n一般来说，일반적으로 모듈마다 하나의 파일에 저장하고 사용할 때에는 \`import 주소.모듈 명칭\`의 형식으로 해당 모듈을 빌려 온다. 이 내용은 제1과 제2장에서 소개했었다. 이로써 모듈의 다양한 기능을 쉽게 보호하고 관리하며 업데이트할 수 있다. \n\n### 실전연습\n\n 우리는 이미 복수 파일의 구조를 구축하였고 모듈의 분해를 완성하였다. 이어서 그 전에 완성했던 거래 시스템 부분을 파일에 추가하도록 한다. \n\n1. 구축 완료한 모듈을 확인하고 현재 이용 중인 옵션 중에서 거래 시스템의 내용을 보충하시오. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//코드 입력",
                    answer:"import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code:"module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code:"module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code:"module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lessons = [lesson1, lesson2, lesson3];

export default lessons;


