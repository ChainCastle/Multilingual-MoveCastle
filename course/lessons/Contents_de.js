import React from 'react';
import L1c1 from './L1C1/L1C1'

const lesson1 = {
    info : {
        name: " Die bewegliche Burg ",
        subname: ["Gamification-Kurs von Libra Move ", "*aufgrund Libra move Commit 61649eb"],
        intro: " Im bestehenden Blockchain-System programmiert Bitcoin “Währung” und Ethereum “Anwendungen”, im Vergleich dazu programmiert  Libra “Kapital”.\n\n In Libra können wir einige Kapitalien definieren, die komplexer als Währungen sind und als „Ressourcen“ bezeichnet werden. Libra verwendet Move-Sprache für die Beschränkung der Bedienung von Ressourcen, um die unangemessenen Modifikationen zu verhüten, damit sich die Sicherheit der Kapital verbessern könnte.\n\n Move bietet eine sichere und programmierbare Grundlage für die Libra-Blockchain. Dank ihrer Programmierungsform zu \"Kapital\" und ihrer stengen Sicherheitsbeschränkungen ist diese Sprache ganz geeignet für die Ausgabe digitaler Währungen, die Behandlung vom Blockchain-Handel und die Verwaltung von Verifizierer.\n\n In diesem Kurs verwenden wir Move-Sprache, um eine Burg zu bauen sowie um ihre Funktionen von Ausbau dieser Burg und Kampf zu erzielen, damit die Anfänger diese Sprache schneller erlernen können.",
        goback: "← Zurück",
        editor: "Editor",
        lesson: "Kurs",
        copyAnswer: "Lösungen kopieren",
        learnmore: "Mehr zu erfahren",
        start: "Anfangen",
        indexpage:"https://www.learnlibramove.com/index-cn.html",
        learninide:["Dieser Code kann in ChainIDE benutzt werden.","Zu ChainIDE"],
        practice: "Ab sofort",
    },
    local:{
        hint: " Tipps ",
        previous: "Das letzte Kapitel",
        next: " Das nächste Kapitel ",
        catalog: "Katalog",
        checkcode: "Code überprüfen",
        showAnswer: "Lösungen darstellen",
        hideAnswer: " Lösungen verstecken",
        contitle: ["Herzlichen Glückwunsch zum Abschluss dieses Kapitels ~", "Herzlichen Glückwunsch zum Abschluss dieser Lektion ~", "Es gibt immer noch etwas Schönes"],
        concontent: ["Klicken Sie auf\" Weiter \", um neue Herausforderungen anzunehmen!" , "Diese Lektion wird hier endetn. Klicken Sie auf\" Zurück \", um zur Katalogseite zurückzukehren.", "Hallo ~ Herzlichen Glückwunsch, dass Sie den gesamten Inhalt des Kurses bis jetzt schon abgeschlossen haben~ Weitere Kurse werden sich in Kürze präsentieren.  Jetzt gehen wir zu ChainIDE, um unseren eigenen Libra Move-Vertrag zu programmieren! "],
        concontinue: ["Weiter gehen", "Zurück", "Zu ChainIDE"],
        shut: "Arbeitsfenster schließen",
        target: "Einführung vom Kurs",
        keypoint: "Schwerpunkt",
        detail: "Details"
    },
    lessonserial: " Die erste Lektion ",
    title: "",
    intro: ["In der ersten Lektion werden wir Sie anleiten, die Grundlage für Ihre eigene Burg zu etablieren, die eine einzigartige Erscheinung hat und darin leben die unerwarteten Kreaturen." ,"Wie man einen Vertrag abschließen: die Module in Move; main in Move (); Variablen sowie Datentypen; Prozesse in Move"],
    key: 1,
    total: 5,
    chapters: [
        {
            title: "Das erste Kapitel  Einführung",
            instruction: `## Das erste Kapitel  Einführung \n\n In der ersten Lektion lernen wir eine Burg zu bauen.\n\n- Durch die Module bauen wir die neue Burg\n- Unsere Burg wird in Datenbank( Libra-Blockchain) gespeichert \n\n In den nächsten Kapiteln werden sich die Funktionen unserer Burg erhöhen, wie die Steigerung eigener Kräfte, Kampf mit anderen Burgen usw. Aber wir müssen zuerst die Funktionen unserer Burg anlegen. \n\n### Welche Eigenschaften besetzt eine Burg? \n\n Jede Burg besetzt Name,  Seriennummer, Stufe, wirtschaftliche- und militärische Stärke. Dazwischen ist die Seriennummer entscheidend für die Erscheinung der Burg und die biologische Rasse der Kreaturen in der Burg. Die Stufe entscheidet den Wert der Burg, während die wirtschaftliche- und militärische Stärke die Äußerung der Burg beim Kontakt mit der anderen beeinflüssen. \n\n### Wie kann die Seriennummer die Burg beeinflüssen? \n\n Die Seriennummer entscheidet die Erscheinung und die Typ der Burg, die Seriennummer ist eine 8-Bit-Ganzzahl, z.B.：83451029。\n\n Jedes Bit von Seriennummer vertretet eine Eigenschaft der Burg, wie das Folgende：\n\n|  1   |  2   |  3   |    4     |    5     |    6     |  7   |    8     |\n| :--: | :--: | :--: | :------: | :------: | :------: | :--: | :------: |\n| Größe | Form | Farbe | Form von Logo | Farbe von Logo | Stelle von Logo | biologische Rasse | Spezielle Kennzeichnung |\n\n In Anbetracht von Spaß beim Spiel haben wir die Seriennummer so gesetzt, dass die Seriennummer zufällig nach der Tiefe des Blocks beim Aufbau der Burg auftauchen wird, sondern nicht von Spielern selbst entscheidet wird. Jedoch bedeutet das nicht eine unbestimmte Erscheinung der Burg, denn die Seriennummer ist schon ein bestimmter Wert gleichzeitig beim Aufbau der Burg. Der Name jeder neu gebauteten Burg wird vom Spieler festgestellt. Der Anfangsstufe ist Stufe 1, die anfängliche wirtschaftliche- und militärische Stärke werden vom „Biologischen Rasse – Bit“ in Seriennumer entscheidet. Die entsprechende Beziehung ist wie das Folgende：\n\n|  Biologischen Rasse – Bit  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| Wirtschaftliche Stärke |  6   |  8   |  3   |  7   |  4   |\n| Militärische Stärke |  6   |  3   |  8   |  4   |  7   |\n\n### Praxis \n\n1. Ziehen Sie den Schieberegler auf der rechten Seite, um die entsprechende Erscheinung der Burg von verschiedenen Seriennummern zu suchen.\n\n\n ** Nachdem Sie solche grundlegende Kenntnisse gewusst haben, klicken Sie bitte auf das nächste Kapitel, um die Move-Sprache weiter zu lernen. **。\n\n`,
            type: 1, 
            show(){
                return <L1c1 lang="3"/>
            }
        },
        {
            title: "Das zweite Kapitel   Vertrag und Module ",
            instruction: `## Das zweite Kapitel  Die Module im Vertrag \n\n Vertrag ist ein Computerprogramm, das in einer Blockchain funktioniert. Dadurch wir einen Vertrag ausführen, dass wir in der Blockchain eine Reihe von Bedienungen erzielen können, z.B. Überweisung und Einkaufen. \n\n Der Gesamtcode des Move-Vertrags teilt sich in zwei Teilen: \n\n- dem mit \`modules:\`anfangenen Teil \n- mit \`script:\`anfangenen \`main()\`\n\n In diesem Kapitel werden wir den Teil von \`modules\`vorstellen，im nächsten Kapitel den Teil von \`script\`.\n\n### Module \n\n Der Teil von Modulen enthält alle Module（\`Module\`）, die verfügbar für den ganzen Vertrag sind, das Modul ist das Basis-Package Cell des Move-Vertrags und alle in Libra eingesetzte Module gehen ums Ganze.\n\n In den Modulen kann man Struktur(\`Struct\`)、Resourcen(\`Resource\`) und Prozess(\`Procedure\`）definieren, diese Begriffe werden wir in den nächsten Kapiteln vorstellen. \n\n Das Modul ähnelt dem Smart-Vertrag in Ethereum sowie den Klassen in der Java-Sprache. Wir können das Modul für Codeblock mit bestimmten Funktionen halten und durch die Schnittstelle die internen Informationen des Moduls erwerben. \n\n Zum Beispiel, das Modul \`LibraCoin\` ist das von Libra offiziell freigegebene Libra-Coin Modul. Dieses Modul enthält die Prozesse von der Definition von Libra-Coin sowie der Bedienung der Überweisung und der Aufladung von Libra-Coin. Nachdem die Entwickler das Modul eingeführt haben, können die Funktionen durch die Schnittstelle verfügbar sein.\n\n#### Wie kann man das Modul bauen \n\n Durch \`module Modulname { }\`können wir ein Modul bauen.\n\n#### Wie kann man das Modul einführen \n\n Ganz ähnlich wie die Einfuhr von “Cellname + Klassenname” in Java, durch „Adresse + Modulname“ kann Move ein Modul einführen \`import\`, z.B.:\n\n\`import 0x0.LibraCoin\`\n\n Hier ist \`LibraCoin\`der Modulname，\`0x0\`ist die Kontoadresse von dem freigegebenen Modul. Jeder Spieler kann sein eigenes Modul auf der Blockchain freigeben oder durch diese Einfuhrsmethode die von anderen freigegebenen Module einführen. Alle von Libra ofiziell freigegebenen Moduladressen sind \`0x0\`.\n\n Beim Import von Modulen in dieselbe Datei kann man einfach direkt \`import Transaction.Modulname\`benutzen,    z.B. \n\n\`import Transaction.LibraCoin\`\n\n### Praxis \n\n Um unsere Burg zu bauen, sollen wir zuerst ein \`BuildCastle\` Modul，in diesem Modul werden wir eine Reihe von Funktionen des Aufbaus einer Burg erzielen. \n\n1. Ein Leermodul bauen \`BuildCastle\`\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//Hier geben Sie Code ein. ",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "Das dritte Kapitel   main() im Vertrag",
            instruction: `## Das dritte Kapitel   \`main() im Vertrag \`\n\n Im letzten Kapitel haben wir gelernt, wie man ein Modul bauen kann. Jetzt sollen wir aufgrund dieses Moduls den Inhalt des Vertrags verbessern. \n\n Wir können einen Code in den Vertrag einbetten, der nur einmalig ausgeführt werden kann, der der Transaktionsskript heißt und von anderen Code nicht aufgerufen werden kann. Der Transaktionsskript fängt mit \`script:\` an. \n\n\`main()\` ist der Eingang vom Transaktionsskript. Die Codeblocks mit der Form wie \`main()\` werden als „Prozesse“ gekennzeichnet, in den nächsten Kapiteln werden wir den konkreten Begriff von Prozessen vorstellen. \`main()\`gehört zu einem speziellen Prozess, denn es wird nur einmal aufgerufen und kann nicht von anderen Prozessen aufgerufen werden. \n\n Achtung, jeder Prozess einschließlich \`main()\`muss endet mit \`return\`, der Move-Editor ist ganz wörtlich: Er übersetzt nur den Quellcode und erledigt kein anderes, z.B. die Einfügung vom verlorenen \`return\` .\n\n Bei der Programmierung des Move-Vertrag schreiben wir oft alle Bedienung in normalen Prozessen（die Prozesse außer \`main()\`）, dann setzen wir die normale Prozesse ins Modul, schließlich werden wir das Modul in \`script\` einführen. \`main()\` gilt als Eingang，die Prozesse im Modul werden aufgerufen, um eine Reihe von Funktionen zu verwirklichen, der ganze Gedankengang ist wie das Folgende. \n\n<img src=${require("../static/images/lesson1/pic_1_2_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n Achtung, wenn wir andere Module ins Modul einführen, sollen die Einführungsanweisungen in der ersten Zeile im Innern des Moduls präsentieren, das heißt, in der nächsten Zeile von \`module Modulname\`. Aber wenn wir die Module in \`script\` einführen，sollen die Einführungsanweisungen in der ersten Zeile von \`script\`, das heißt, in der nächsten Zeile von \`script: \`, der letzten Zeile von \`main()\`.\n\n Alles in allem, ein grundlegender Leervertrag ist wie das Folgende: \n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### Praxis\n\n Aufgrund des schon gebauten Modul \`BuildCastle\`bauen wir einen Leervertrag.\n\n1. Zuerst \`modules: \`和 \`script: \` anlegen；\n2. in der nächsten Zeile von \`script\`  \`main()\`anlegen und in \`main()\`sollen wir Anweisung \`return\`anlegen；\n3. in \`script\` durch \`import\`die Module einführen（in der letzten Zeile von \`main()\`）。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//Hier geben Sie Code ein\nmodule BuildCastle {\n\n}\n// Hier geben Sie Code ein \n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: "Das vierte Kapitel   Bindung der Variable und Datentyp ",
            instruction: `## Das vierte Kapitel   Bindung der Variable und Datentyp \n\n### ** Bindung der Variable **\n\n Bindung der Variable bedeutet, einige Werte mit einer  Variable zu binden, damit danach diese Werte verfügbar sind. \n\n Ganz ähnlich wie Rust-Sprache, durch let-Schlagwort bindet die Move-Sprache die Variablendie Form ist wie das Folgende：\`let Variablename: Variabletyp;\`  z.B.：\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\n Nach der Bindung der Variable kann die Initialisierung starten, wir können Gleichheitszeichen \`=\` benutzen, z.B.：\n\n\`\`\`\nx = 5;\n\`\`\`\n\n Achtung, die Bindung der Variable von allen Prozessen muss am Anfang beginnen, das heißt, alle \`let\` Anweisungen müssen an der Spitze gelegt werden, die \`let\` Anweisung zwischen dem Codeblock können zum Scheitern führen. \n\n### Datentyp \n\n Zur Zeit, die Move-Sprache kann die folgenden Datentypen unterstützen: \n\n- Boolesche Variable（\`boolean\`）\n- 64-Bit-Ganzzahl ohne Vorzeichen（\`uint64\`）\n- Adresse（\`address\`）\n- Byte-Array（\`bytes\`）\n- Struktur（\`struct\`）\n- Resourcen（\`resource\`），das gehört zur speziellen Typ von Move-Sprache. \n\n Inzwischen benutze Typ \`boolean\` Schlagwort \`bool\` , Typ \`uint64\` Schlagwort \`u64\`, Typ \`address\` Schlagwort \`address\` und Typ \`bytes\` Schlagwort \`bytearray\`.Durch folgende Methode können wir die Variablen von verschiedenen Typen erklären: \n\n\`\`\`\nmain() {\n    //Bindung der Variable \n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    // Initialisierung der Variable \n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h "123abc";\n    return;\n}\n\`\`\`\n\n Resourcen und Struktur können auch erklärt werden:\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\n Inzwischen sind \`f1\`和\`f2\`die Variablemanen.\n\n Achtung, denn die Move-Anweisung wird nicht automatisch initialisiert, deshalb können wir keine nicht initialisierten Variablen verwenden. \n\n### Praxis\n\n Die Seriennummer unserer Burg besteht aus einer 8-Bit-Ganzzahl, deshalb müssen wir die zufällig präsentierte Seriennummer durch die Zahlentheorie \`%\` auf eine 8-Bit-Ganzzahl beschränken. Aber zuerst brauchen wir eine Variable \` SerialDigits\` das Bit zu zeigen. Das ist die Aufgabe von diesem Kapitel. \n\n In \`main()\`sollen wir  \`SerialDigits\` die Datentyp von u64 definieren und den Wert 8 zuweisen. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //Hier geben Sie Code ein \n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "Das fünfte Kapitel   Prozess ",
            instruction: `## Das fünfte Kapitel   Prozess \n\n Im zweite Kapitel haben wir gesagt, dass wir im Modul die Prozesse definieren können, dieser Prozess ist ähnlich wie die Funktion in anderen Sprachen. \n\n### Erklärung der Prozesse \n\n Bei der Erklärung eines Prozess sollen wir die Sichtbarkeit- Name, Parameter und Rückgabewert, die Form: \n\n\`Sichtbarkeit Prozessname( Parametername ) : Rückgabewertstyp \`\n\n Achtung: Bei einem ohne Parameter Prozess brauchen wir den Parametername nicht zu erklären; bei einem ohne Rückgabewert Prozess brauchen wir den Rückgabewertstyp nicht zu erklären. \n\n Es gibt zwei Sichbarkeiten im Prozess vom Modul: \n\n- öffetlich（public）：Der öffentliche Prozess kann von anderen Modulen aufgerufen werden \n- privat（private）：Der private Prozess kann nur von Prozessen aus dem gleichen Modul aufgerufen werden. Die Resourcen im Modul sind alle privat, nur durch öffentlichen Prozess können sie von anderen Modulen besucht. \n\n Wenn der zu erklärende Prozess weder Parameter noch Rückgabewert hat, können wir es auf der folgenden Weise erklären: \n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\n Bei einem zu erklärenden Prozess mit Parameter auf der folgenden Weise: \n\n\`\`\`\npublic Procedure(a: u64, b: u64) { // Bei den Parametern von anderen Typen oder mehreren(weniger) Parametern sind die Formen ähnlich \n    return;\n}\n\n\`\`\`\n\n Achtung, der Prozess selbst kann auch als Parameter in anderen Prozess eingeführt werden. \n\n Bei einem zu erklärenden Prozess mit Rückgabewert auf der folgenden Weise: \n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 { //Bei den Rückgabewerten von anderen Typen sind die Formen ähnlich. \n    return 1;\n}\n\n\`\`\`\n\n In den oberen Beispielen definieren wir öffentlichen Prozess（public）. Wenn wir den privaten Prozess erklären möchten, können wir einfach \`public\` löschen. \n\n### Aufruf von Prozess \n\n Durch  \`Modulname.Prozessname\` kann der Prozess aufgeruft werden. Durch \`Self.Prozessname\` kann man die Prozesse vom dieselben Modulaufrufen.\n\n Das Folgende ist ein Beispiel von Erklärung und Aufruf: \n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //Ein öffentlicher Prozess zu erklären, der Prozessname ist Procedure\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //Aufrufsprozess, Contract ist der Modulname\n    return;\n}\n\n\`\`\`\n\n### Praxis\n\n In den letzten Kapiteln haben wir gesagt, mit der Zahlentheorie \`%\` die Seriennummer in eine 8-Bit-Ganzzahl zu versetzen，genauer gesagt，ein digitales Modell 10<sup>n</sup> hat ein Ergebnis von n-Bit-Ganzzahl, deshalb hier müssen wir durch den Prozess 10<sup>8</sup> kalkulieren.\n\n1. Im Modul \`BuildCastle\`bauen wir ein Modul \`Math\` zu kalkulieren, das alle Kalkulierungsprozesse in diesem Kurs enthält. \n2. Im neu gebauten Modul den Prozess der Potenzoperation \`pow()\` zu erklären:\n   - Parameter: Basis x und Index n vom Typ u64 \n   - Rückgabewert：Das Ergebnis der Potenzoperation vom Typ u64 \n   - Prozessinhalt：vorläufig leer，um zu programmieren, weisen wir vorläufig den Rückgabewert 1 zu. Im nächsten Kapitel werden wir die Funktionen verwirklichen.\n3. Bevor \`main()\`wird Operationsmodul \`Math\` eingeführt und nach \`SerialDigits\` wird eine \`u64\`Vabriale mit Name \`SerialLimit\` erklärt, die die Beschränkung vom Bit der Seriennummer bedeutet. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \n//Hier geben Sie Code ein\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n// Hier geben Sie Code ein \n\nmain() {\n    let SerialDigits: u64;\n    // Hier geben Sie Code ein \n\n    SerialDigits = 8;\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },    
    ]
};

const lesson2 = {
    lessonserial: "Die zweite Lektion",
    title: "",
    intro: [" In der ersten Lektion haben wir die Bedienungen über Variablen gelernt und die Seriennummer unserer Burg erfolgreich erklärt, was für den Aufbau der Burg den ersten Grundstein legt. In der zweiten Lektion werden wir Sie geleitet, die Struktur der Burg zu errichten und eigene Burgwelt selbst bearbeiten. "," Eigentum; Die Programmierungsstruktur in Move; Der Aufbau und die Verwendung der Struktur; Die übliche Operatoren in Move; Prozess mit mehreren Rückgabewerten in Move "],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "Das erste Kapitel   Eigentum",
            instruction: `## Das erste Kapitel   Eigentum \n\n### Die Verwendung vom Eigentum\n\n Vorher haben wir “binden” erwähnt. Tatsächlich bedeutet das die Bindung vom Eigentum, nur wenn ein Bezeichner Eigentum eines Werts besetzt, können wir durch diesen Bezeichner diesen Wert besuchen. \n\n Wenn wir einen Wert mit einem Name(Bezeichner) binden, binden wir das Eigentum vom Wert(Resourcen) mit diesem Bezeichner. Z:B.: \n\n\`\`\`\nlet x: u64;\nx = 3;\n\n\`\`\`\n\n Nachdem wir durch Schlagwort \`let\` den Bezeichner \`x\` mit Resourcen vom Typ \`u64\` mit Wert von 3 gebunden haben, besetzt \`x\` das Eigentum von 3. Während der Bindung besetzt der Bezeichner selbst die Ressource und kann sie besuchen und verändern. Aber sobald die Bindung auf einen anderen Bezeichner übertragen wurde, besetzt der Bezeichner das Eigentum des Werts nicht mehr. \n\n### Übertragung vom Eigentum \n\n Wenn wir das Eigentum übertragen möchten, aufgrund der Sicherheit von Speichern müssen wir \`move()\` verwenden, sondern nicht \`=\`. \n\n Das heißt, in der Move-Sprache kann \`=\` zwischen Bezeichnern nicht verwendet werden, nur zwischen Bezeichnern und Werten kann \`=\` verwendet werden. Der folgende Code ist ein falsches Beispiel:\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //error\n\n\`\`\`\n\n Dann werden wir durch konkreten Code die Übertragung des Eigentums vorrstellen: \n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); //Übertragen(move) Sie das Eigentum von 3 vom Bezeichner x auf den Bezeichner y \nz = move(x); //error: Jetzt hat der Bezeichner x das Eigentum verloren und wird zu einer nicht initialisierten Variable. Daher scheitert move (x). \nz = move(y); //Übertragen(move) Sie das Eigentum von 3 vom Bezeichner y auf den Bezeichner z \nx = 3; 	//Den Bezeichner x wieder initialisieren \nz = move(x); // Jetzt kann das Eigentum von 3 durch move vom Bezeichner x auf den Bezeichner z übertragen werden. \n\n\`\`\`\n\n### Kopien vom Eigentum \n\n Unter einigen Umständen möchten wir den Wert eines Bezeichners mit dem Wert eines anderen gleichsetzen, ohne das Eigentum zu übertragen. Jetzt müssen wir den Prozess \`copy()\`verwenden, nach \`copy\` kann ein Bezeichner noch besucht werden. Z.B.: \n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); // Kopieren（copy） Sie das Eigentum von 3 aus dem Bezeichner x in den Bezeichner y \nz = move(x); //Übertragen（move） Sie das Eigentum von 3 vom Bezeichner x auf den Bezeichner z \n\n\`\`\`\n\n Achtung, wenn wir das Prozess aufrufen und die Parameter übergeben, können wir den Parameternamen nicht direkt verwenden, sondern durch \`move(Parametername)\` oder \`copy(Parametername)\`.Welche Form zu verwenden, das kommt auf die Verwendung der Parameter vor und nach dem Code an. \n\n### Praxis\n\n In der letzten Lektion haben wir \`SerialLimit\` erklärt. In diesem Kapitel möchten wir den Wert von \`SerialLimit\` gleich wie 10<sup>SerialDigits</ sup> sein. Dazu brauchen wir den Prozess \`pow()\` aufzurufen, um \`SerialLimit\` zu initialisieren, die die Parameter 10 und \`SerialDigits\` hat. \n\n Für die obere Aufgabe muss eine Variable als Parameter in den Prozess \`pow()\` übergeben werden, deshalb steht er im Zusammenhang mit der Übertragung des Eigentums. In zukünftigen Inhalten kann \`SerialDigits\` vielleicht wieder verwendet werden, deswegen verwenden wir  \`copy()\`. Jetzt ist der Prozess \`pow()\` noch leer, und wir werden sie im nächsten Kapitel verwirklichen. \n\n In \`main()\` initialisieren \`SerialLimit\` durch Aufruf des Prozesses \`pow()\` , die Methode zum Aufruf des Prozesses \`Modulname. Prozessname\`, die im letzten Kapitel vorgestellt wurde. Wenn Sie sie schon vergessen haben, können Sie sie überprüfen. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //Hier geben Sie Code ein\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Das zweite Kapitel  Programmierungsstruktur",
            instruction: `## Das zweite Kapitel  Programmierungsstruktur \n\n Ganz ähnlichwie die anderen Sprachen, es gibt in Move-Sprache auch übliche Programmierungsstruktur, z.B. Auswahl und Zirkulation.\n\n Durch Anweisung \`if-else\` können wir einfache Auswahlstruktur verwirklichen, die konkrete Regel ist wie das Folgende: \n\n1. Verzweigungsanweisungen müssen in doppelte Klammern \`{}\` eingeschlossen werden, auch wenn nur ein Satz. Das folgende Beispiel ist falsch: \n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;	// Hier benötigt x = 3 Klammern \n       return;\n   }\n   \`\`\`\n\n2. Fügen Sie Semikolon \`;\`der Verzweigungsanweisungen nach dem Ende jedes Satzes hinzu, sondern nicht nach den Klammern. Das folgende Beispiel ist auch falsch: \n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;\n       else {\n           x = 5\n       };	// Das Semikolon hier sollte am Ende der letzten Zeile erscheinen. \n       return;\n   }\n   \`\`\`\n\n3. Wenn die Initialisierung eines Bezeichners in einer Verzweigungsanweisung erscheint, kann dieser Bezeichner nach dem Ende der Verzweigung nicht besucht werden, wenn die Verzweigungsanweisung nicht alle Bedingungen enthält. Das folgende Beispiel ist auch falsch: \n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       }	//Hier wird die Variable x nur in der if-Verzweigung initialisiert, und in der else- Verzweigung ist die mittlere Variable x nicht initialisiert, deshalb können wir später copy nicht verwenden, um das Folgende zu besuchen: x\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n   Jedoch wenn die Verzweigung alle Bedingungen enthält, kann der Bezeichner nach dem Ende der Verzweigung besucht werden. Das folgende Beispiel ist richtig: \n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } else {\n           x = 43;\n       }	//Die beiden Verzweigungen hier enthalten true und false, das heißt, dass die Variable x unter allen Umständen initialisiert wird, deshalb können wir sie später verwenden: copy\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n4. Achten Sie bei der Verwendung von \`move ()\` in einer Verzweigungsanweisung unbedingt auf das Eigentum. Der Bezeichner mit \`move ()\` in der Verzweigung sollte nach dem Ende der Verzweigung nicht wiedermal besucht werden. Das folgende Beispiel ist falsch: \n\n   \`\`\`\n   main() {\n       let x: u64;\n       let y: u64;\n       x = 0;\n       if (true) {\n           y = move(x);	//In dieser Verzweigung übertragen wir das Eigentum der Variable x auf die Variable y, deshalb dürfen wir im nächsten Code nicht mehr durch copy (x) die Variable besuchen: x\n       }\n       assert(copy(x) == 0, 42);\n       return;\n   }\n   \`\`\`\n\n Wir können auch durch \`loop\` die Zirkulationstruktur verwirklichen. Aus Platzgründen wird es in diesem Kapitel nicht detailliert vorgestellt, sondern in den folgenden Kapiteln. \n\n### Praxis \n\n Die häufigste Implementierung einer Potenzfunktion ist die Rekursion. Das folgende Beispiel zeigt eine Potenzfunktion in C-Sprache: \n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\n\`\`\`\n\n Bitte imitieren Sie das obere Programm und implementieren Sie den spezifischen Inhalt von \`pow()\` im Modul \`Math\`. Achten Sie auf das Eigentum von Variablen und verwenden Sie geeignet \`copy\` und \`move\`.\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        // Hier geben Sie Code ein.\n        \n        return 1; // Löschen Sie diese Anweisung return\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Das driite Kapitel   Struktur",
            instruction: `## Das driite Kapitel   Struktur \n\n Die Struktur in der Move-Sprache ist ganz ähnlich wie in anderen Sprachen: sie besteht aus einer Datensammlung desselben Typs oder verschiedener Typen. Durch \`struct Strukturname {Daten 1: Typ, Daten 2: Typ, ...}\` zu erklären, zum Beispiel: \n\n\`\`\`\nmodule Test {\n	// Leerstruktur \n  	struct Empty1 { }\n  	// Struktur mit zwei Mitgliedern \n  	struct T { a: u64, b: u64, }\n}\n\n\`\`\`\n\n Achtung:\n\n- Strukturen können nur an der Spitze vom Modul erklärt werden, sondern nicht in der Mitte. \n- Strukturen können auch mit \`copy\`oder \`move\`bearbeitet. \n\n Weitere Informationen zur Verwendung von Strukturen werden Wir Sie in den folgenden Kapiteln vorstellen. \n\n### Praxis \n\n Im Modul \`BuildCastle\` die Struktur \`Castle\` zu erklären, die fünf Mitglieder enthält.: \`name(bytearray)\`, \`SerialNum(u64)\`, \`level(u64)\`, \`economic(u64) \` und \`military(u64)\`。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	// Hier geben Sie Code ein \n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Das vierte Kapitel  Operation",
            instruction: `## Das vierte Kapitel  Operation \n\n In den vorherigen Kapiteln haben wir einige grundlegende Operationen wie Addition, Multiplikation usw. verwendet. In diesem Kapitel werden wir die verschiedenen Operationen detaillierter kennlernen, die in der Move-Sprache schon implementiert hat. \n\n Zur Zeit hat die Move-Sprache die folgenden mathematischen Operationen implementiert: Addition \`+\`  Subtraktion \`-\` Multiplikation \`*\` Division \`/\` Modus \`%\`，zum Beispiel: \n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\n\`\`\`\n\n Außerdem werden auch Vergleichsoperationen implementiert: größer als \`>\`, kleiner als \`<\`, gleich \`==\`, größer oder gleich \`> =\`, kleiner oder gleich \`<=\`, ungleich \` ! = \`, z.B.: \n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\n\`\`\`\n\n Darüber hinaus hat die Move-Sprache  auch mehrere Bitoperationen und Boolesche Operationen usw. implementiert. Aus Platzgründen wird das in diesem Kapitel nicht detaillerter vorgestellt, sondern in den folgenden Kapiteln. \n\n### Praxis\n\n Wir hoffen, eine zufällige Seriennummer der Burg basierend auf der Tiefe des aktuellen Blocks aufzutauchen. \n\n Der grundlegendste Operation zur Erzeugung von Zufallszahlen wird durch Modul-Operationen implementiert. \n\n  Das Folgende ist ein Beispiel eines Codes, der eine einfache Pseudozufallszahl in der C-Sprache implementiert. Offensichtlich kommt die durch ein solches Programm erhaltene Zufallszahlen auf die Wahl des Anfangswerts von \`next\` an. \n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\n\`\`\`\n\n Basierend auf diesem Programm können wir das Programm verarbeiten, um eine Zufallszahl basierend auf dem Samen \`seed\` zu bekommen: \n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\n\`\`\`\n\n Wie in anderen Sprachen, wir können Modul-Operationen verwenden, damit die Zufallszahlen schließlich aus diesem Code innerhalb eines bestimmten Bereichs auftauchen. Genau gesagt, damit eine Zufallszahl von \`m\` bis \`n\` auftauchen kann, können Sie den folgenden Code verwenden: \n\n\`\`\`c\nmyrand(seed) % (n - m + 1) + m;\n\n\`\`\`\n\n1. Bitte machen Sie nach dem oberen Programm der Erzeugung von Zufallszahlen nach: den Prozess der Erzeugung einer Zufallszahl \`myrand()\` im Modul \`Math\` hinzuzufügen und dessen spezifische Funktion zu verwirklichen. \n2. Bitte fügen Sie den öffentlichen Prozess \`generateSerial()\` im Modul \`BulidCastle\` hinzu und sowie sie verwirklichen. Dieser Prozess erzeugt basierend auf der Blocktiefe eine zufällige 8-Bit-Seriennummer, indem er den Prozess \`myrand\` des Moduls \`Math\` aufruft. (dh. eine Zufallszahl zwischen 10<sup>7</sup> bis 10<sup>8</sup>-1), der Parameter ist die Beschränkung des Bits der Seriennummer \`generateSerial()\`und der Rückgabewert ist \`u64\`. \n   - Die Blocktiefe kann kann durch die Methode \`get_current_height()\` im Modul \`Block\` bekommen. \n   - Die Adresse vom Modul \`Block\` ist \`0x0\`。\n   - Bitte führen Sie im richtigen Ort die Module \`Math\` und \`Block\` ein。\n3. Im \`main()\` \`SerialNum\` zu erklären und durch \`generateSerial()\`zu initialisieren。\n\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    // Hier geben Sie Code ein \n    \n}\nmodule BuildCastle {\n    // Hier geben Sie Code ein \n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    // Hier geben Sie Code ein \n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    // Hier geben Sie Code ein \n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    // Hier geben Sie Code ein \n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: " Das fünfte Kapitel   Prozess mit mehrere Rückgabewerte ",
            instruction: `## Das fünfte Kapitel   Prozess mit mehrere Rückgabewerte \n\n Im fünften Kapitel  haben wir den Prozess vorgestellt und durch Beispiele gezeigt, wie man den Prozess mit Rückgabewerten verwenden kann. Jedoch hoffen wir in vielen Situationen, ein Prozess mehrere Rückgabewerte zu haben. In diesem Kapitel werden wir Ihnen vorstellen, wie Sie den Prozess mit mehreren Rückgabewerten programmieren sollten. \n\n Gemäß des fünften Kapitel wieesen wir, dass der Prozess mit einem Rückgabewert wie folgt erklärt werden kann: \n\n\`\`\`\npublic Prozessname(Parametername 1, Parametername 2, ...): Rückgabewerttyp {...}\n\n\`\`\`\n\n In ähnlicher Weise nehmen wir den Prozess mit zwei Rückgabewerten als Beispiel. Der Prozess mit mehreren Rückgabewerten wird wie folgt erklärt: \n\n\`\`\`\npublic Prozessname(Parametername 1, Parametername 2, ...): Rückgabewerttyp * Rückgabewerttyp {...}\n\n\`\`\`\n\n Die Aufrufsmethode: \n\n\`\`\`\n Variable 1, Variable 2, ... = Modulname. Prozessname (Parameter 1, Parameter 2, ...) \n\n\`\`\`\n\n Bei Verwendung des Prozesses mit mehreren Rückgabewerten sind folgende Punkte zu beachten: \n\n1. Wenn der Prozess mit mehreren Rückgabewerten und der Prozess mit einzeinem Rückgabewert ausgeführt werden, werden nur der letzte Rückgabewert des Prozesses mit mehreren Rückgabewerten und der Rückgabewert des Prozesses mit einzelnem Rückgabewert wirklich erzeugt. \n\n   Im folgenden Beispiel besetzt Line 2 über einen Prozess mit mehreren Rückgabewerten, wenn Line 18 diesen Prozess aufruft, sind die ersten beiden Rückgabewerte das Ergebnis der Operation und der dritte Rückgabewert muss wiedermal durch \`bar()\` verarbeitet werden. \n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\n\`\`\`\n\n2.  Ein Prozess mit mehreren Rückgabewerten kann direkt als Parameter für einen anderen Prozess mit mehreren Parametern verwendet werden. \n\n   Beispielsweise wird im folgenden Code der Prozess mit zwei Rückgabewerten in Line 2 zu den ersten beiden Parametern des Prozesses mit drei Parametern in Line 23. \n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\n\`\`\`\n\n3. Wenn die return-Anweisung eines Prozesses mit mehreren Rückgabewerten in einer Verzweigungsanweisung präsentiert ist, müssen wir es überprüfen, ob der Typ und die Nummer des Rückgabewerts jeder Verzweigung einheitlich sind. \n\n   Beispielsweise im folgenden Code wird der Rückgabewert des Prozesses \`bar()\` in den Line 6 bis Line 10 präsentieren und der Rückgabewert beider return-Anweisungen ist u64, was mit dem Rückgabetyp der Prozesserklärung übereinstimmt. \n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\n\`\`\`\n\n### Praxis \n\n im Modul \`BuildCastle\`den Prozess \`racial_judgment()\` hinzufügen und die Funktionen verwirklichen: Anhand der Seriennummer wird die Rasse der Burg beurteilt und die entsprechende anfängliche wirtschaftliche- und militärische Stärke werden zurückgegeben.\n\n1. Durch Modul-Operation und Division das Rasse-Bit von der Seriennummer (Bit 7 der Seriennummer) abfangen；\n2. Durch die Verzweigung die wirtschaftliche Stärke und die militärische Stärke zu bestimmen, die des Rasse-Bits entsprechen. Die Beziehung zwischen dem Rasse-Bit und dem Stärkewert ist wie folgt: \n\n|  Rasse-Bit  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| wirtschaftliche Stärke |  6   |  8   |  3   |  7   |  4   |\n| militärische Stärke |  6   |  3   |  8   |  4   |  7   |\n\n3. Der Prozess hat zwei \`u64\` -Rückgabewerte, einer ist der Wert für die wirtschaftliche Stärke und der andere ist der Wert für die militärische Stärke. \n\n Tipps: \n\n Wie kann man das m-te Bit von den n Ziffern abfangen? \n\n- Zu einer N-stellige Zahl Num, wenn Sie das erste x-Bit nehmen möchten, können Sie das durch Abrundungsdevision Num / 10<sup>x</sup> bearbeiten, das Ergebnis dieser Operation ist die Zahl, die den ersten x Bits entspricht, zum Beispiel, 54312 / 10<sup>5-2</sup>=54；\n- Zu einer N-stellige Zahl, wenn Sie die letzten x Bits nehmen möchten, können Sie das durch die Modul-Operation Num / 10<sup>n-x</sup>bearbeiten. Der Rest, der durch diese Operation erhalten wird, ist die Zahl, die den letzten x Bits entspricht, zum Beispiel, 54312 / 10<sup>2</sup>=12；\n- Zu einer N-stellige Zahl, wenn Sie das mittlere x-Bit nehmen möchten, können Sie das Problem zuerst durch die obere Operation in das erste x-Bit oder das letzte x-Bit versetzen und berechnen Sie dann weiter. \n\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    // Hier geben Sie Code ein \n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Das sechste Kapitel   Verbesserung des Designs der Burg",
            instruction: `## Das sechste Kapitel   Verbesserung des Designs der Burg \n\n Im dritten Kapitel  haben wir gelernt, wie man eine Struktur erklären sollte. In diesem Kapitel werden wir weiter lernen, wie man eine Struktur initialisieren und im Prozess \`main()\` sie verwenden kann. \n\n Wie im folgenden Beispiel dargestellt, initialisieren wir die Struktur häufig durch den Aufbau eines Prozesses und programmieren wir die Erklärung der Struktur und den Initialisierungsprozess im diesselben Modul. Der Rückgabewerttyp, der dem zur Initialisierung der Struktur verwendeten Prozess entspricht, ist der Strukturtyp; und die Struktur wird initialisiert, indem eine Struktur zurückgegeben wird, deren Mitgliedsvariable der Anfangswert ist. \n\n<img src=${require("../static/images/lesson2/pic_2_6_1_en.png")} style="width:80%;position:relative;left:10%">\n\n Z.B.: \n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\n\`\`\`\n\n In diesem Beispiel erklären wir eine Struktur \`T\` im Modul \`Bar\` und durch den Prozess \`new\` initialisieren wir die Mitgliedsvariablen der Struktur zu den Parametern des Prozesses \n\n Im Prozess \`new\` haben wir eine Struktur \`T\` zurückgegeben，der Wert seiner Mitgliedsvariablen \`baz\` ist der Parameter des Prozesses \`m\`. \n\n Achtung, dass Line 6 ~ Line 8 im oberen Code der Definition einer Struktur sehr ähnlich ist, jedoch ist er eine \`return\` -Anweisung, deshalb steht ein Semikolon am Ende des Satzes. \n\n  Wenn wir die Struktur \`T\` in dem Prozess \`main()\` oder in anderen Prozessen verwenden möchten, können wir die Variable durch das Schlagwort \`let\` als Strukturtyp erklären und \`new\` aufrufen, um  den Prozess zu initialisieren. \n\n Zum Beispiel: Der folgende Code initialisiert die Variable \`x\` zu einer Struktur \`T\` mit einem Mitgliedsvariablenwert von 10: \n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\n\`\`\`\n\n### Praxis \n\n In den vorherigen Kapiteln haben wir gelernt, wie man einen Vertrag abschließen **, ** Module in der Move-Sprache **, ** Variablen und Datentypen und das Eigentum **, ** Prozess und Prozess mit mehreren Rückgabewerten in Move-Sprache **, ** Programmierungsstruktur in Move **, ** Struktur bauen und verwenden **, ** übliche Operatoren ** und andere Schwerpunkte. Jetzt haben wir einigen notwendigen Schrittweisen zum Aufbau einer Burg abgeschlossen, dann sollen wir sie kombinieren und die Burg im Prozess \`main()\`zu bauen. \n\n1. Im Modul \`BuildCastle\`fügen wie den Prozess \`newCastle\` hinzu，um eine Variable vom Typ einer Struktur \`Castle\` zu initialisieren. Dieser Prozess hat zwei Parameter: \n\n   - \`_name (bytearray)\`：Burgname \n   - \`_SerialNum (u64)\`：Burgseriennummer \n\n   Achtung: Um ihn von \`name\` und \`SerialNum\` in \`main()\` zu unterscheiden, haben wir den Parameternamen unterstrichen. \n\n   Dieser Prozess hat einen Rückgabewert und der Typ davon ist \`Self.Castle\`.\n\n   Bitte imitieren Sie die Beispiele im Kurs: Im Prozess gemäß dem Parameter（\`_name\`, \`_SerialNum\`）die Daten einer Burg zu initialisieren. \n\n   Tipps: Der Name und die Seriennummer der Burg werden mit den den Parametern entsprechenden Werten initialisiert. Die Stufe der Burg wird mit 1 initialisiert. Die wirtschaftliche- und militärische Stärke der Burg werden mit dem Wert initialisiert, der durch Aufruf des Prozesses \`racial_judgment()\` berechnet wird. \n\n2. In dem \`main()\` -Prozess wird der Name der Burg vom Spieler eingegeben, deshalb ist der Parameter \`name\` eine externe Eingabe. Wir müssen im Prozess \`main()\` einen Parameter \`name\` hinzufügen, dessen Typ \`bytearray\` ist. \n\n3. Fügen Sie die Variable \`castle\` im \`main()\` hinzu sowie initialisieren Sie sie. Achtung: Fügen Sie die \`let\`- Anweisung nach vorn ein. \n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    // Hier geben Sie Code ein \n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n// Korrigieren Sie \nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    // Hier geben Sie Code ein \n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    // Hier geben Sie Code ein \n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial: "Die dritte Lektion ",
    title: "",
    intro: ["In den vorherigen Lektionen haben wir eine grundlegende Burgsarchitektur gebaut. In der nächsten drei Lektionen werden wir die Burg ausbauen, damit es sicherer aussieht." ,"Der Bgriff von Ressourcen; wie man Resourcen bauen und zerstören: Wie man eine Struktur mit mehreren Dateien bauen kann"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "Das erste Kapitel   Resourcen",
            instruction: `## Das erste Kapitel   Resourcen \n\n Im bestehenden Blockchain-System programmiert Bitcoin " Währung " und Ethereum " Anwendungen ". Im Vergleich dazu programmiert Libra "Kapital", die als „Ressourcen“ bezeichnet wird und ein komplexerer Kapitaltyp als Währung ist. \n\n Es gibt die Regel in Move-Sprache, dass die Operation der Ressource die folgenden zwei Bediingeungen erfüllen muss: \n\n-  ** Knappheitsgarantie **: Die Gesamtmenge der Ressourcen muss kontrolliert werden und die Spieler dürfen die Ressourcen nicht zwangslos kopieren, wiederverwenden oder verwerfen. \n- **Zugangskontrolle**：Der Besuch der Ressourcen muss einige vordefinierte Regeln erfüllen. \n\n Um die beiden oberen Bedingungen zu erfüllen, kann die Ressource in einem Move-Vertrag nur von einem Modul gebaut oder zerstört werden, das die Ressource definiert. Außerdem kann die Recourcen nur von \`move()\` operatiert werden. Das heißt, wir können nicht durch \`copy()\` die Ressourcen kopieren. \n\n Der Move-Editor überprüft durch Bytecode statisch, ob die oberen Bedingungen für Sicherheit erfüllt werden, sonst wird er den Programmcode nicht ausführen, der die Bytecode-Überprüfung nicht besteht. \n\n Die Anfänger können vorläufig die Ressourcen als eingeschränkte Struktur verstehen. \n\n Die Erklärung der Ressourcen ist ähnlich wie die der Struktur, die durch die Form \` resource  Ressourcennamen {Daten 1: Typ, Daten 2: Typ, ...} \` erklärt wird. \n\n Das Folgende ist ein Beispiel für eine Erklärung über Libra-Coin: \n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### Praxis \n\n Aus Sicherheitsgründen müssen wir die Struktur der Burg in Ressource verwandeln. \n\n1. Bitte verwandeln Sie den Typ von \`Castle\` von Struktur in Recource. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//Korrigieren Sie struct\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "Das zweite Kapitel   Aufbau der Resourcen",
            instruction: `## Das zweite Kapitel   Aufbau der Resourcen \n\n Um Ressourcen zu verwenden, müssen wir zuerst den Prozess zum Aufbau der Ressourcen verwirklichen. Der Rückgabetyp des Prozesses ist der Ressourcentyp. \n\n Zum Beispiel, der folgende Code ist der in der letzten Lektion erwähnte Aufbauprozess für \`LibraCoin\`, bei dem eine Ressourcenvariable \`T\`mit dem Wert 0 erzeugt wird. \n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\n Es ist zu sehen, dass der Aufbau der Ressourcen ganz ähnlich wie die Initialisierung der Strukturen ist. \n\n### Praxis \n\n Jetzt werden wir den Prozess vom Aufbau der Ressourcen verwirklichen.\n\n  In diesem Kapitel stellen wir den Begriff vom Konto vor: Jeder Spieler hat ein Konto mit der entsprechenden Burg. Wir möchten durch das Konto die Burg mit dem Spieler verbinden. \n\n In den nächsten Lektionen werden wir die detaillierten Funktionen und Bedienungen des Kontos vorstellen. In diesem Kapitel werden wir zuerst nur Module und Ressourcen bezüglich des Kontos bauen. \n\n1. Unter dem Modul \`BuildCastle\`bauen wir das Modul \`CastleAccount\`.\n\n2. Erklären Sie die Ressource \`CastleAccount\` im neu gebauten Modul. Um zu üben, verfügt die Ressource vorläufig nur über eine \`u64\` -Variable, deren Name \`a\` ist. Wenn wir in der Zukunft die Resource verwenden, werden wir sie wieder verbessern. \n\n3. Der Prozess \`newAccount\` des Aufbaus der Resource \`CastleAccount\` zu verwirklichen, der die Variable \`a\` in der Ressource mit 0 initialisiert. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//Bauen Sie hier ein neues Modul \n// Erklären Sie die Kontoressourcen im Modul \n// Verwirklichen Sie den Prozess zum Aufbau eines Kontos im Modul \n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Das dritte Kapitel   Zerstörung der Resourcen ",
            instruction: `## Das dritte Kapitel   Zerstörung der Resourcen \n\n Weil es in der Move-Sprache keinen Abfallaufbereitung-Mechanismus gibt, müssen die Ressourcen nach ihrer Verwendung explizit zerstört werden. \n\n Im Move-Code zerstören wir die Resourcen, indem wir normalerweise die Ressourcenbindung mit \`Move()\` auf leer setzen. \n\n Hier ist ein einfaches Beispiel zu sehen: der Zerstörungsprozess von \`LibraCoin\`: \n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n        T { value } = move(coin);\n        return;\n}\n\`\`\`\n\n Dabei erklären wir zuerst im Innern des Prozesses eine lokale Ressourcenvariable \`T\`, deren Mitgliedsvariable \`value(u64)\` ist, dann binden wir durch \`move()\` die zu zerstörende Ressource \`coin\` wieder an die lokale Ressourcenvariable \`T\`. Nachdem der Prozess geendet hat, wird die lokale Ressourcenvariable \`T\` automatisch zerstört und die Ressource \`coin\` wird zu einer Ressource, die nicht gebunden ist und nie mehr besucht werden kann. Weil das System die ungebundenen Ressourcen recycelt, wird die Ressource \`coin\` zerstört. \n\n### Praxis \n\n Wir haben den Aufbau der Ressourcen \`Castle\` und \`CastleAccount\` erledigt und dann werden wir sie zerstören. \n\n1. Folgen Sie dem Beispiel in der Lektion: Bauen Sie den Prozess \`desCastle\` im Modul \`BuildCastle\`. Der Parametername des Prozesses heißt \`castle\`und der temporäre Variablenname im Prozess ist einheitlich mit dem in den vorherigen Lektionen. \n2. Folgen Sie dem Beispiel in der Lektion: Bauen Sie den Prozess \`desAccount\` im Modul \`CastleAccount\`. Der Parametername des Prozesses heißt \`account\` und die temporäre Variable im Prozess heißt \`num\`. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    // Hier zerstören Sie die Ressource Burg \n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    // Hier zerstören Sie die Ressource CastleAccount \n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Das vierte Kapitel    Verwendung der Resourcen",
            instruction: `## Das vierte Kapitel    Verwendung der Resourcen \n\n Nachdem wir die Ressourcen gebaut haben, können wir die Ressourcen verwenden.\n\n Die Verwendung der Ressourcen ist fast gleich wie der Struktur, aber der Unterschied besteht darin, dass wir die Ressourcen nach der Verwendung zerstören müssen. \n\n In diesem Kapitel nehmen wir an, dass wir die Ressourcen nur im aktuellen Transaktionsskript verwenden und vorläufig die Resourcen nicht an eine Adresse senden. Deswegen müssen wir die Ressourcen vor dem Ende von \`main()\` zerstören. \n\n Jetzt nennen wir ein Beispiel, um die Verwendung von Ressourcen zu verstehen und der Aufbau und Zerstörung der Ressourcen zu überprüfen. \n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\n In diesem Beispiel erklären wir ein Modul \`MoneyHolder\` mit einer Ressource \`T\`, die durch den Prozess von Line 5 erzeugt und durch den Prozess von Line 8 zerstört wird. \n\n Achtung, dass die Mitgliedsvariable der Ressource T auch eine Ressource ist. Dewegen müssen wir bei der Zerstörung von \`T\` zweimal  arbeiten (dh. Line 10 und Line 11). Bei der zweite Zerstörung haben wir den Prozess \`LibraCoin.destroy_zero()\` von \`coin\` im Modul \`LibraCoin\`aufgerufen. Solche Inhalte sind in den vorherigen Kapiteln vorhanden. Wenn Sie sie vergessen, bitte wiederholen Sie die Schwerpunkte rechtzeitig. \n\n Jetzt betrachten wir den Teil \`script\` vom Beispiel. Die ersten beiden Zeilen vom Prozess \`main()\` erklären jeweilig zwei Ressourcenvariablen, von denen eine \`LibraCoin.T\` ist und die andere \`MoneyHolder.T\` ist, die wir selbst erklären. Nach der Erklärung der Variablen initialisieren wir die Variablen, denn die nicht initialisierte Variablen können nicht verwendet werden. \n\n \` LibraCoin.zero()\` in Line 21 ist der Initialisierungsprozess für die Ressource \`LibraCoin.T\`. Dieser Prozess wurde im offiziellen Modul \`LibraCoin\` definiert und wird hier nicht analysiert. \n\n \`MoneyHolder.new(move(coin))\` in Line 22 ist der von uns definierte Prozess für Aufbau der Ressourcen. Nachdem \`money_holder\` durch diesen Prozess initialisiert wurde, können wir diese Variable verwenden. \n\nAchtung: der Parameter hier ist \`move(coin)\`, sondern nicht \`copy(coin)\`, auch wenn wir später auch die Variable \`coin\` verwenden, können wir \`copy()\` auch nicht benutzen, denn \`coin\` ist die Resource, die nur durch \`move()\`bearbeitet wird, sondern nicht durch \`copy()\`.\n\n In diesem Beispiel werden wir \`money_holder\` nicht bearbeiten, daher müssen wir es zerstören und den Vertrag beenden. Achtung, dass die Parameter in diesem Prozess ebenfalls nur durch \`move()\`bearbeitet werden, sondern nicht durch \`copy()\`.\n\n Allgemein gesagt, besteht der vollständige Prozess der Verwendung der Ressourcen darin, die Ressourcenvariable zuerst durch \`let\` zu erklären und dann den Prozess des Aufbaus der Ressource aufzurufen, um die Variable zu initialisieren. Nach der Verwendung werden wir den Prozess für Zerstörung der Resourcen aufrufen, um die Variablen zu zerstören, wie das folgende Beispiel.\n\n<img src=${require("../static/images/lesson3/pic_3_4_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n### Praxis \n\n Im vorherigen Kapitel haben wir den Aufbau und die Zerstörung der Burg erledigt, aber jetzt kann der Vertrag noch nicht erfolgreich programmiert werden, weil wir noch den Aufbau und die Zerstörung der Ressourcen in \`main()\` verbessern müssen. \n\n Tipps: Weil die Kontoressource jetzt noch keine praktischen Auswirkungen hat, rufen wir sie nicht in \`main()\` auf. Wenn Sie die Ressource \`CastleAccount\` verwenden möchten, können Sie sie durch \`newAccount\`und \`desAccount\` bauen und zerstören. \n\n1. Fügen Sie in \`main()\` Anweisungen hin, die die Resource \`Castle\` zerstört. \n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //Hier geben Sie Code ein \n\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: " Das fünfte Kapitel   Aufteilung der Dateien ",
            instruction: `## Das fünfte Kapitel   Aufteilung der Dateien \n\n Wenn wie diese Lektion lernen, können Sie finden, dass unsere Codedateien immer länger werden. Wir hoffen, sie in mehrere Dateien aufzuteilen, um sie leicht zu verwalten und die Lesbarkeit des Codes zu erhöhen. \n\n Deswegen haben wir in diesem Kapitel den Code auf der rechten Seite bereinigt. Jetzt können Sie sehen, dass sich mehrere Registerkarten oben im Editor befinden. Versuchen Sie auf die Registerkarte zu klicken, um die Dateien zu wechseln. \n\n Es ist zu sehen, dass sich die Registerkarten in aktive und feste Registerkarten unterteilen, wobei die aktiven Registerkarten bearbeitbar sind. Die aktiven Registerkarten sind die Dateien, die wir im Praxis korriegieren und überprüfen werden, während die festen Registerkarten schreibgeschützt sind. Das heißt, während des Lernprozesses können wir sie besuchen, aber nicht ändern. \n\n Allgemein gesagt, dass wir ein Modul in eine Datei legen werden und es verwenden, indem wir durch \`import Adresse.Modulname\` dieses Modul einführen können, was wir im zweiten Kapitel der ersten Lektion schon vorgestellt haben. Auf diese Weise können wir verschiedene Modulfunktionen leichter bewahren, verwalten und aktualisieren. \n\n### Prakis \n\n Wir haben eine Struktur mit mehreren Dateien gebaut und die Aufteilung des Moduls erledigt. Jetzt fügen Sie bitte den zuvor erledigten Transaktionsskriptteil zur Datei hinzu. \n\n1. Bitte durchsuchen Sie die gebauten Module und vervollständigen Sie den Inhalt des Handelsskripts auf der aktuell aktiven Registerkarte. \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//Hier geben Sie Code ein",
                    answer:"import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code:"module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code:"module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code:"module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lessons = [lesson1, lesson2, lesson3];

export default lessons;


