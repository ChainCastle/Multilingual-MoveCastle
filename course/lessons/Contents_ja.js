import React from 'react';
import L1c1 from './L1C1/L1C1'

const lesson1 = {
    info : {
        name: "Move Castle",
        subname: ["ゲームプログラムでLibra Moveを学ぼう", "*Based on Libra move Commit 61649eb"],
        intro: "既存のブロックチェーンシステムで「通貨」と「アプリケーション」をBitcoinとEthereumでプログラムしているのに対し、Libraは「資産（アセット）」を対象にします。\nLibraでは、通貨よりも複雑な「リソース」と呼ばれるアセットを定義できます。LibraではMove言語を使用してリソースの使用を制限することで、不適切な変更を防止し、アセットのセキュリティを向上させます。\nMove言語は、安全でプログラム可能なLibraブロックチェーンの基盤を提供しています。Moveのアセットを厳格な制限付きでプログラミングする方法は、デジタル通貨の発行、ブロックチェーンのトランザクション処理や権限認証の管理などに適しています。\nこのコースでは、Move言語を使ってキャッスル（城）を作ります。キャッスルの拡張やバトル機能を実装して、初心者がより効果的に言語を学習できるようにします。",
        goback: "← 戻る",
        editor: "エディタ",
        lesson: "レッスン",
        copyAnswer: "答えをコピー",
        learnmore: "もっと詳しく",
        start: "スタート",
        indexpage:"https://www.learnlibramove.com",
        learninide:["コース内のコードはChainIDEでコンパイルできます","ChainIDEへ"],
        practice: "さっそく始める",
    },
    local:{
        hint: "ヒント",
        previous: "前のチャプタ",
        next: "次のチャプタ",
        catalog: "メニュー",
        checkcode: "コードをチェック",
        showAnswer: "答えを表示",
        hideAnswer: "答えを隠す",
        contitle: ["良くできました！このチャプタは完了です。", "本レッスンは完了です。おめでとうございます！", "Keep going!"],
        concontent: ["「次に進む」をクリックして新しいチャレンジを！", "このレッスンはここで終わりです。「戻る」をクリックしてメニューに戻りましょう。", "お疲れ様でした！すべてのレッスンを完成しました。おめでとうございます！間もなくもっと多くのレッスンを皆さんにご提供する予定です。ChainIDEで、自分のLibra Moveコントラクトを作ってみましょう。"],
        concontinue: ["次に進む", "戻る", "ChainIDEへ", "次のレッスン"],
        shut: "ウィンドウを閉じる",
        target: "レッスン内容",
        keypoint: "学習ポイント",
        detail: "詳細を見る"
    },
    lessonserial: "レッスン1",
    title: "",
    intro: ["レッスン1では、順を追って独自のキャッスルワールドを構築する方法を説明します。あなたのキャッスルはユニークな外観を持っていて、不思議なクリーチャーが住んでいます。","コントラクトの作り方;Moveのモジュール;main()関数;変数とデータ型;Moveのプロシージャ"],
    key: 1,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 イントロダクション",
            instruction: `## Chapter 1 イントロダクション\n\nこのチャプタでは、どの様に城を築くのか習いましょう。\n\n* 新しく城を築くためにmoduleを使います。\n* キャッスルはデータベース（Libraブロックチェーン）に保存されます。\n\nこの後、自分のキャッスルに「パワーの拡張」や「他の城とバトルする」などの機能を付け足していきます。しかしまず最初に、城を生成する機能を最初に実現しないといけません。\n\n### 城のプロパティは？\n\n全ての城は「名前」「シリアルナンバー」「レベル」「経済力」「軍事力」を持っています。シリアルナンバーは城の「見た目」とそこに住む「種族」を決定します。レベルは城のバリューを決め、経済力、軍事力は他のと相互作用する場合のパフォーマンスに影響します。\n\n### シリアルナンバーはどの様に城に影響するの？\n\n城の見た目（アピアランス）とその種族は、例えば「83451029」の様な、シリアルナンバーと呼ぶ8桁の整数値で決められます。シリアルナンバーの個々の数字は城のプロパティと対応します。具体的には…\n\n| 1 | 2 | 3 | 4 |5  | 6 | 7 | 8 |\n|:--|:--|:--|:--|:--|:--|:--|:--|\n| size | style | color | logo style | logo color | logo position | race digit | special ID |\n\n新しく生成されたそれぞれの城の名前はユーザによって入力されます。シリアルナンバーは現在のブロック長によってランダムに生成されます。レベルは1にイニシャライズされます。初期の経済力、軍事力はシリアルナンバーの中の「種族（race）デジット」で決まります。対応関係は次の様に定義されています。\n\n| Race digit | 0,5 | 1,6 | 2,7 | 3,8 | 4,9 |\n|:--|:--|:--|:--|:--|:--|\n| 経済力 | 6 | 8 | 3 | 7 | 4 |\n| 軍事力 | 6 | 3 | 8 | 4 | 7 |\n\n### 実習\n1. 右ページのスライダーをドラッグして、あるシリアルナンバーと城の見た目の対応関係を見てみましょう。\n\n**上記を理解したら「次へ進む」ボタンをクリックしてMoveの勉強を続けましょう。**\n\n`,
            type: 1, 
            show(){
                return <L1c1 lang="2"/>
            }
        },
        {
            title: "Chapter 2 スマートコントラクトとモジュール",
            instruction: `## Chapter 2 スマートコントラクトとモジュール\n\nスマートコントラクトはブロックチェーン上で動作するプログラムです。私たちは「送金」や「お買い物」といった一連の操作をブロックチェーン上で行うためにコントラクトを使います。\n\nMoveのコントラクトのコードは、次の二つのパートに分けられます。\n\n- 「modules:」で始まるモジュールセクション\n- 「script:」で始まる\`main()\`\n\nこのチャプタではモジュール部について説明し、次のチャプタでスクリプト部について説明します。\n\n### モジュール\n\nモジュール部はコントラクトに必要なモジュール群を含んでいます。モジュールはMoveコントラクトの基本パッケージ単位です。そして、全てのLibraに配置されたモジュールはグローバルです。\n\nモジュール内では、後のチャプタで説明する\`Structure\`（構造体）、\`Resource\`（リソース）、\`Procedure\`（プロシージャ）を定義できます。\n\nモジュールはEthereumにおけるスマートコントラクトや、あるいはJavaにおけるクラスにも似ています。モジュールは、モジュール内の情報にアクセスするインターフェースを使う特定の関数を持つコードブロックと見なせます。\n\n例えば、Libraコインを定義し、コインの転送やチャージを処理する\`LibraCoin\`モジュールはLibraによって公式にリリースされています。開発者がモジュールを紹介した後は、インターフェースを関連機能の実装に使うことができます。\n\n**モジュールの作りかた**\n\n\`module_name { }\`の形式でモジュールを作れます。\n\n**モジュールのインポートの仕方**\n\njavaにおける\`package name + class name\`の様に、Moveは\`address + module name\`をモジュールをインポートするのに使います。例えば次の様に。\n\n\`\`\`\nimport 0x0.LibraCoin\n\`\`\`\n\nここで\`LibraCoin\`はモジュール名で、\`0x0\`がモジュールを公開したアカウントのアドレスです。各ユーザは自分のモジュールをブロックチェーンに公開するか、ほかの人がこの様に公開したモジュールをインポートすることができます。リブラによって公開されたモジュールのアドレスは全て\`0x0\`です。\n\n同一のファイルからそこにあるモジュールをインポートする時には\`import Transaction.module name\`を利用できます。次の様にです。\n\n\`\`\`\nimport Transaction.LibraCoin\n\`\`\`\n\n### 実習\n\n城を作るにあたって、段階的に一連の築のクリエイト機能を実装する\`BuildCastle\`モジュールを作るところからスタートしましょう。\n\n1. 中身が空っぽの\`BuildCastle\`モジュールを作ってください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここにコードを入力",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "Chapter 3 コントラクトのmain関数",
            instruction: `## Chapter 3 コントラクトのmain関数\n\n### main()\n\n前のチャプタでは、モジュール構築の仕方を学びました。そして、このチャプタではモジュールをベースにしてコントラクトを完成させましょう。\n\n私たちは、コントラクト内に「トランザクションスクリプト」と呼ばれる、他のどのコードからもコールされない様な、ワンタイム実行コードを埋め込むことができます。トランザクションスクリプトは\`script:\`の記述から始まります。\n\n\`main()\`はトランザクションスクリプトを実行するための開始箇所です。\`main()\`の様なコードブロックは「プロシージャ」と言います。後のチャプタでこれらのコンセプトについては解説します。\`main()\`は特にスペシャルなプロシージャです。\n\n\`main()\`を含む、全てのプロシージャは\`return\`で終わることに注意してください。Moveコンパイラは\`return\`がなかったらそれを自動で補う様な、如何なる処理も行うことなくダイレクトに変換する、その名の通りの（単純な）コンパイラです。\n\nMoveのコントラクトを書くとき、私たちは\`main()\`を含む普通のプロシージャにおいて、いつも全ての操作を記述し、それをモジュールに配置します。最終的に、スクリプトセクションでモジュールをインポートし、そして、一連の操作実行のために、モジュールのプロシージャ群を開始ポイントの\`main()\`と共に呼び出します。概要を次の図で示します。\n\n<img src=${require("../static/images/lesson1/pic_1_2_1_en.png")} style="width:80%;position:relative;left:10%">\n\nモジュール内で他のモジュールをインポートする必要があるとき、インポートの記述は、例えばモジュール名の記述の次の行に書くなど、モジュールの最初に書く必要がありますので注意してください。\nそして、スクリプト部分で、モジュールをインポートする必要がある場合も、インポート記述はセクションの最初の行である必要があります。例えば、\`script:\`の次の行や\`main()\`の1行目などです。\n\nまとめに、基本的な空白のコントラクトのサンプルをお見せします。\n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### 実習\n\n城を作るために、まず\`BuildCastle\`という名前のモジュールや\`main()\`を含んだ、空のコントラクトを作る必要があります。\n\n1. 最初に\`modules:\`と\`script:\`を追加します。\n2. \`main()\`を\`script:\`の次の行に加えます。\`return\`を\`main()\`内につけることを忘れないでください。\n3. スクリプトセクションにmoduleをインポートします（\`main()\`の前の行に）。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここにコードを入力\nmodule BuildCastle {\n\n}\n//ここにコードを入力\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: " Chatper 4 変数バインディングとデータ型",
            instruction: `## Chatper 4 変数バインディングとデータ型\n\n### 変数バインディング\n\n変数バインディングは、後の利用のために、値を変数にバインディングすることです。\n\nRustの様にMoveは\`let variable: variable type;\`のフォーマットで\`let\`を変数バインディングに使います。例えば次の様にです。\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\n変数バインディングの後、\`=\`で変数をイニシャライズできます。例えば次の様に。\n\n\`\`\`\nx = 5;\n\`\`\`\n\n変数は全て処理の初めにバインドされなければならないことに注意してください。つまり、全ての\`let\`は初めの方に書かれなければならないのです。そうしないとコードブロックの中に書かれた\`let\`行はコンパイルエラーを引き起こします。\n\n### データ型\n\n現在のところ、Moveは次のデータ型をサポートしています。\n\n- ブール型（boolean）\n- 64ビット符号なし整数（uint64）\n- アドレス（address）\n- バイト配列（bytes）\n- 構造体（struct）\n- リソース（resource）これはMove独自のデータ型です。\n\nboolean型のデータは\`bool\`として、uint64型は\`u64\`、address型は\`address\`、byte型は\`bytearray\`として宣言される必要があります。例えば変数を次の様に定義できます。\n\n\`\`\`\nmain() {\n    //変数バインディング\n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //初期化\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h "123abc";\n    return;\n}\n\`\`\`\n\nまた、次の様にして、resouceやstructを定義できます。\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\nここで、f1やf2は変数名です。\n\nMoveは自動的に変数を初期化できないので、初期化なしの変数を使ってはいけないことに注意してください。\n\n### 実習\n\n城のシリアルナンバーは、8桁の数値です。そこで、私たちはランダムに生成されたシリアルナンバーを8桁の数に制限するために剰余演算子（％）を使います。\nそのまえに、シリアルナンバーの数値の表示に必要な\`SerialDigits\`と呼ぶ変数を用意しましょう。これがこの演習のメインタスクです。\n\`main()\`プロセスの中で、\`SerialDigits\`をu64として宣言し、それを8で初期化してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //ここにコードを入力\n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 プロシージャ",
            instruction: `## Chapter 5 プロシージャ\n\nチャプタ2で言及した様に、プロシージャは他のプログラミング言語における関数と同じ様に、モジュール内で定義できます。\n\n### プロシージャの定義\n\nプロシージャを宣言するために、そのビジビリティ（アクセス権）、名前、パラメータと戻り値を次のフォーマットで宣言します。\n\n\`Visibility Procedure name (parameter name): The type of return value\`\n\nプロシージャがパラメータを持たない時には、パラメータ名は宣言する必要がありません。また、戻り値がない場合には戻り値の型を宣言する必要はありません。\n\nモジュール内のプロセスは二つの種類のビジビリティを持ちます。\n\n- public:パブリックプロシージャは他のモジュールから呼ぶことができます。\n- private:プライベートプロシージャは同じモジュールのプロシージャからのみ呼ばれます。モジュール内のリソースは、プライベートであり他のモジュールからはパブリックプロシージャを通してのみアクセスされます。\n\nパラメータも戻り値も無いプロシージャは、次のようなフォーマットで宣言されます。\n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\nパラメータのあるプロシージャの場合は次の様に宣言されます。\n\n\`\`\`\npublic Procedure(a: u64, b: u64) {\n// パラメータの型が異なっている場合や、パラメータの数が異なる場合も形は同様です。\n    return;\n}\n\`\`\`\n\nプロシージャそれ自身も他のプロシージャのパラメータとして使われることがあることに注意してください。\n\nプロシージャが戻り値を持つなら、次の様に宣言されます。\n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 {\n// 戻り値の型が異なる場合でも形は同様です。\n    return 1;\n}\n\`\`\`\n\n上記の例においては、パブリックなプロシージャのみ定義しました。もしプライベートプロシージャを宣言したいなら\`public\`の表記を消すのみです。\n\n### プロシージャをコールする\n\nプロシージャは\`module name.procedure name\`によって呼ばれます。プロシージャが同じモジュール内の他のプロシージャによって呼ばれる場合は\`Self.procedure name\`というフォーマットを使います。\n\n次はプロシージャを定義してコールするサンプルです。\n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //定義部分。Procedureという名前のパブリックなプロシージャ\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //コール部分。Contractはモジュール名\n    Call the procedure whose module name is Contract\n    return;\n}\n\`\`\`\n\n\n### 実習\n\n前のチャプタで言及した通り、剰余演算子(%)をシリアルナンバー用の8桁の整数を得るために使います。10のn乗で割った余りはn桁の整数となるため、ここでは10の8乗を計算する手続きを採用していきます。\n\n1. \`BuildCastle\`モジュールの前に、このコースで必要な全ての計算手続きを含む\`Math\`モジュールを作ります。\n\n2. 次の様に、新しく作ったモジュール内に乗数計算を行うプロシージャ\`pow()\`を宣言してください。\n\n    - パラメータ：u64型の基数xと乗数n\n    - 戻り値：u64型の乗算結果値\n    - 計算内容：とりあえず空。コンパイルを成功させるために、戻り値を1に設定しておきましょう。この機能については次のチャプタで実装します。\n\n3. Mathモジュールをmain()の前にインポートし、\`SerialDigits\`の後に、シリアルナンバー内の桁数を表す、\`SerialLimit\`と名付けたu64の変数を宣言します。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \n//ここにコードを入力\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//ここにコードを入力\n\nmain() {\n    let SerialDigits: u64;\n    //ここにコードを入力\n\n    SerialDigits = 8;\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },    
    ]
};

const lesson2 = {
    lessonserial: "レッスン2",
    title: "",
    intro: ["レッスン1では変数とその操作を学び、城を作る礎となるシリアルナンバーを作ることに成功しました。レッスン2ではあなた独自のキャッスルワールドを作っていくため城のフレームワーク作りをガイドします。","所有権;Moveのプログラム構造;構造体;算術演算子;複数の戻り値があるプロシージャ"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "第一章 所有権",
            instruction: `## 第一章 所有権\n\n###所有権の使用\n\n　前、「バインディング」という単語に触れた。実際、バインディングは所有権のバインディングで、ある識別子がある値の所有権を持つ時に、この識別子を通じてこの数値をアクセスすることができる。\n\nある数値をある名前（識別子）とバインディングする時に、この数値（資源）の所有権をこの識別子とバインディングする。例えば：\n\n\`\`\`\nlet x: u64;\nx = 3;\n\n\`\`\`\n\n　\`let\`キーワードを通じて識別子\`x\`と\`u64\`種類、3数値の資源とバインディングする後、\`x\`は3の所有権を持つことになる。バインディングしている間に、この識別子は独立でこの資源の所有権を持ち、この数値をアクセス、修正することができるが、バインディングをほかの識別子に移転する後、この識別子はこの数値の所有権を持たなくなる。\n\n###所有権の移転\n\n所有権を移転したい時に、メモリ安全のデザインのため、直接に\`=\`を使えなく、\`move()\`で所有権を移転しなければならない。\n\nつまり、Move言語に、識別子の間に\`=\`で繋げなく、識別子と数値のみが\`=\`で繋げる。例えば、下記のコードは間違った例である：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //error\n\n\`\`\`\n\n次、具体的なコードで所有権の移転を説明する：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); //3の所有権を識別子xから識別子に移転(move)するy\nz = move(x); //error: この時に識別子xが所有権を失い、初期化しない変数になるので、move(x)失敗\nz = move(y)　; //3の所有権を識別子yから識別子に(move)移転するz\nx = 3; 	//改めて初期化する識別子x\nz = move(x); //この時にmoveを通じて3の所有権を識別子xから識別子に移転する　z\n\n\`\`\`\n\n### 所有権のコピー\n\nある状況では、所有権を移転しない状況では、識別子の数値をもう一つの識別子の数値に等しい時に、プロシージャが要る\`copy()\`，ある識別子が\`copy\`を経る後、続いてアクセスされることができる。例えば：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); //3の所有権を識別子xから識別子y\nz = move(x)にコピーする; //3の所有権を識別子xから識別子z\n\n\`\`\`\n\n　に移転する。ご注意、プロシージャをコールする、それにパラメータをインポートする時に、直接にパラメータ名を使えなく、\`move(パラメータ名)\`か\`copy(パラメータ名)\`で、所有権をプロシージャに転送し、コードにパラメータを使った状況によって、\`move\`か\`copy\`を使うことを決める。\n\n### 実戦演習\n\n前の課程に宣言した　\`SerialLimit\`，本章に\`SerialLimit\`の数値が10<sup>SerialDigits</sup>に等しいことを希望する。これのために、\`pow()\`プロシージャをコールすることを通じて、\`SerialLimit\`を初期化する。この過程のパラメータはそれぞれ10と\`SerialDigits\`である。\n\n以上の任務に変数をパラメータとして、\`pow()\`プロシージャに伝送するので、所有権の移転にかかわり、後の内容に\`SerialDigits\`が再び使われるので、\`copy()\`を使う。この時に\`pow()\`プロシージャが空いていて、次の章にこれを実現する。\n\n\`main()\`に\`pow()\`プロシージャをコールすることを通じて、\`SerialLimit\`を初期化する。プロシージャをコールする方法は\`モジュール名.プロシージャ名\`で、前の章に紹介した。忘れたら、復習できる。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //ここにコードを入力\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第二章 プログラムの構成",
            instruction: `## 第二章 プログラムの構成\n\nほかの言葉と似ていて、Move言語によくあるのプログラム構成があり、例えば選択とサイクルである。\n\n私たちは\`if-else\`語句を通じて簡単な構成選択を実現でき、具体的な規則が下記となる：\n\n1. 分けている語句は二重の大かっこ\`{}\`で包み、一つの語句でも必要で、下記の例は正しくない\n\n：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3; //ここ x = 3 大かっこが要る\n       return;\n   }\n   \`\`\`\n\n2. 分けている語句のセミコロン\`;\`語句の終わりに入れたら、大かっこにセミコロンを入れる必要がなく、下記の例が正しくない：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;\n       else {\n           x = 5\n       }; //ここのセミコロンは前の桁の終わりに現れる\n       return;\n   }\n   \`\`\`\n\n3. 　　識別子の初期化はブランチ語句に進行したら、ブランチ語句がすべての状況を含まない時に、ブランチが終わる後、この標識子をアクセスできなく、下記の例は正しくない：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } // ここはifブランチのみに変数xを初期化し、elseブランチに対応する状況では、 変数xが初期化されないので、後ろにcopyでx\n をアクセスできない assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n   ブランチはすべての状況を含むと、ブランチが終わる後、この識別子をアクセスでき、下記の例は正しい ：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } else {\n           x = 43;\n       } //ここの２つのブランチはtrueとfalseを含み、即ち、どんな状況では、変数xが初期化されるので、後ろにcopy\nを使える　　 assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n4. 分けている語句に\`move()\`を使う時に、所有権を注意しなければならなく、ブランチに\`move()\`される識別子は、ブランチが終わる後、再びアクセスされなく、下記の例は正しくない：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       let y: u64;\n       x = 0;\n       if (true) {\n           y = move(x); //このブランチに変数xの所有権を変数xに移転するので、後ろのコードにcopy(x)を通じて変数x\nをアクセスしない       }\n       assert(copy(x) == 0, 42);\n       return;\n   }\n   \`\`\`\n\n\`loop\`を通じて、サイクル構成を実現でき、紙幅のため、本章節に詳しく紹介しなく、後の章節に紹介する。\n\n### 実戦演習\n\nべき乗関数に最もよくあるの実現方法が再帰で、下記がC言語のべき乗関数の実例：\n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\n\`\`\`\n\n以上のプログラムを模倣ください。\`Math\`モジュールに実現する\`pow()\`の具体的な内容を実現し、変数の所有権を注意し、それに適当に使用する\`copy\`和\`move\`。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //ここにコードを入力\n        \n        return 1; //この言葉return\nを削除する    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第三章 構造体",
            instruction: `## 第三章 構造体\n\nMove言語の構造体とほかの言葉が似ていて、同じ種類か異なる種類のデータによって構成されるデータ集合である。\`struct 構造体名{データ1: 種類, データ2: 種類, ...}\`という方法で宣言し、例えば：\n\n\`\`\`\nmodule Test {\n //空構造体\n   struct Empty1 { }\n   //２つのメンバーの構造体\n   struct T { a: u64, b: u64, }\n}\n\n\`\`\`\n\nご注意：\n\n- 構造体はモジュールの最も前に宣言し、ほかのプロシージャに宣言できない\n- 構造体も\`copy\`か\`move\`できる。\n\n構造体をもっと多く使用し、私たちは次の章節に紹介する。\n\n### 実戦演習\n\n\`BuildCastle\`モジュールに構造体\`Castle\`を宣言し、これは５つのメンバーを含む：\`name(bytearray)\`, \`SerialNum(u64)\`, \`level(u64)\`, \`economic(u64) \`和\`military(u64)\`。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//ここにコードを入力\n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第四章 演算操作",
            instruction: `## 第四章 演算操作\n\n前の章節に、私たちは基礎的な演算を使い、例えば加算、掛け算など。この章節に、Moveが実現した何種類の演算操作を具体的に了解する。今、\n\nMove言語は下記の何種類の数学演算を実現する：足す \`+\`  引く \`-\` 掛ける\`*\`割る\`/\`摸倣\`%\`、具体的な使用実例は下記となる：\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\n\`\`\`\n\nは比較演算を実現する：大なり\`>\`、小なり\`<\`、イコール\`==\`、大なりイコール\`>=\`、小なりイコール\`<=\`、イコールならず\`!=\` 、具体的な実例は下記となる：\n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\n\`\`\`\n\nこのほかに、Moveは何種類の演算とブール演算などを実現し、紙幅のため、本章節に詳しく紹介しなく、後の章節に紹介する。\n\n### 実践演習\n\n今のブロックの深さによってリアルタイムに城のシリアル番号が生まれることを希望する。\n\n最も基礎的な乱数生成アルゴリズムはアナログ演算を通じて実現される。\n\n下記はＣ言語に簡単な疑似乱数コードを実現する例で、明らかにこんなプログラムが得た乱数系列は\`next\`初期値の選びによって決まる。\n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\n\`\`\`\n\nこのプログラムに基づき、ちょっと修正したら、シード\`seed\`によって乱数が生まれるプログラムを得る：\n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\n\`\`\`\n\nほかの言葉と完全に同じ方法で、アナログ演算を通じて、最終このコードが指定範囲の乱数に生まれる。具体的に言えば、\`m\`から\`n\`までの乱数が生まれたいと、下記のコードを使える：\n\n\`\`\`c\nmyrand(seed) % (n - m + 1) + m;\n\n\`\`\`\n\n1. 以上の乱数生成プログラムにより、在\`Math\`モジュールに乱数が生成するプロシージャ\`myrand()\`を添え、それに具体的な機能を実現する。\n2. \`BulidCastle\`モジュールに添え、それに共有プロシージャを実現する\`generateSerial()\`。このプロシージャにブロックの深さで\`Math\`モジュールの\`myrand\`をコールするプロシージャによって、リアルタイムに8桁のシリアルナンバーが生まれ（即ち10<sup>7</sup>到10<sup>8</sup>-1の間の乱数が生まれる）、パラメータがシリアルナンバー桁数制限\`SerialLimit\`で、戻り値が\`u64\`である。\n   -ブロックの深さは\`Block\` モジュールの \`get_current_height()\` を通じて得られる。\n   - \`Block\`モジュールのアドレスが\`0x0\`である。\n   - 正しいところに\`Math\`モジュールと\`Block\`モジュールをインポートする。\n3. \`main()\`に\`SerialNum\` 宣言し、それに\`generateSerial()\`プロシージャの初期化を通過する。\n\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //ここでコードを記入する\n    \n}\nmodule BuildCastle {\n    //ここでコードを記入する\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //ここでコードを記入する\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //ここでコードを記入する\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //ここでコードを記入する\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 マルチリターン値のプロシージャ",
            instruction: `## 第五章 マルチリターン値のプロシージャ\n\n第五章にプロシージャを紹介し、それに実例で戻り値があるプロシージャをどう使うかを説明する。しかし、多くのシーンに、１つのプロシージャにいつくかの戻り値があることを希望する。本章節に、マルチリターン値を編集するプロシージャを紹介する。\n\n第五章により、このように単一の戻り値のプロシージャを宣言できる：\n\n\`\`\`\npublic プロシージャ名(パラメータ名1、パラメータ名2，...) : 戻り値の種類 {...}\n\n\`\`\`\n\n２つの戻り値のプロシージャを例として、マルチリターン値のプロシージャを宣言する方式は下記となる：\n\n\`\`\`\npublic プロシージャ名(パラメータ名1、パラメータ名2，...) :  戻り値の種類 * 戻り値の種類 {...}\n\n\`\`\`\n\n　コール方法：\n\n\`\`\`\n変数1, 変数2, ...  =モジュール名.プロシージャ名( パラメータ1, パラメータ2, ...)\n\n\`\`\`\n\nマルチリターン値を使っているプロシージャに、下記を注意する：\n\n1. マルチリターン値と単一の戻り値を演算する時に、実際 マルチリターン値プロシージャの最後の戻り値と単一の戻り値のプロシージャの戻り値のみを演算する。\n\n   例えば下記の例に、Line 2はマルチリターン値プロシージャがあり、Line 18がこれをコールする時に、前の２つの戻り値はこのプロシージャが演算した結果で、三番目の戻り値はプロシージャ\`bar()\`と演算する。\n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\n\`\`\`\n\n2. 一つのマルチリターン値プロシージャはもう一つのマルチパラメータプロシージャのパラメータとすることができる。\n\n 例えば下記のコードに、Line 2に2つの戻り値のプロシージャは直接にLine 23の３つのパラメータプロシージャの前２つのパラメータになる。
\n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\n\`\`\`\n\n3. マルチリターン値プロシージャの戻し語句が分けている語句に現れたら、分けている語句の戻り値の種類と数量が一致するかどうかを検査しなければならない。\n\n   例えば下記のコードに、\`bar()\`プロシージャの戻り値がLine 6 ~ Line 10に現れ、二つのreturn語句の戻り値が全部u64となり、プロシージャに宣言する戻し種類と一致する。\n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\n\`\`\`\n\n### 実戦演習\n\n　\`BuildCastle\`モジュールに\`racial_judgment()\`プロシージャを添え、それにこれの機能を実現する：シリアル番号によって城の対応する種族を判断し、対応の初期経済実力と軍事実力に戻す。\n\n1.アナログ演算と除算演算を通じて、シリアル番号から種族値（シリアル番号の第7桁）を取る；\n2. 分けている語句で種族値の対応する経済実力と軍事実力の数値を判断し、種族値と実力値の対照関係は下記となる | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| 経済実力 |  6   |  8   |  3   |  7   |  4   |\n| 軍事実力 |  6   |  3   |  8   |  4   |  7   |\n\n3. このプロシージャに２つの\`u64\`戻り値があり、一つが経済実力値で、もう一つが軍事実力値である。\n\nヒント：\n\nどうn桁の数字から第m桁の数字を取るか？\n\n- n桁の数字Num、前x桁を取りたいと、整除法Num / 10<sup>x</sup>を使い、この演算で得た結果が前x桁の対応する数字で、例えば、54312 / 10<sup>5-2</sup>=54；\n- n桁数字Num、後x桁を取りたいと、アナログ演算Num / 10<sup>n-x</sup>を使い、この演算で得た結果が後x桁の対応する数字で、例えば、54312 / 10<sup>2</sup>=12；\n- n桁の数字Num、真ん中のx桁の数字を取りたいと、上記の演算を通じて問題を前x桁か後x桁を取ることに変ってから、計算する。\n\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //ここにコードを入力\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "第六章 城のデザインを完全する",
            instruction: `## 第六章 城のデザインを完全する\n\n第三章にどう構造体を宣言するかを勉強した。本章にどう構造体を初期化するかを続いて勉強し、それにどう\`main()\`プロシージャにこれを使うかを勉強する。\n\n下記の写真通りに、私たちはプロシージャを構成することを通じて、構造体の初期化を実現し、それに構造体の宣言と初期化プロシージャを同じモジュールに入力し、構造体を初期化するプロシージャに対応する戻り値の種類が構造体種類となる時に使われていて、それにメンバー変数が初期値だという構造体を戻すことを通じて、構造体の初期化を実現する。\n\n<img src=${require("../static/images/lesson2/pic_2_6_1_en.png")} style="width:80%;position:relative;left:10%">\n\n例えば：\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\n\`\`\`\n\nこの例に、私たちはモジュール\`Bar\`に構造体\`T\`を宣言し、それに\`new\`というプロシージャを通じて、構造体のメンバー変数をこのプロシージャのパラメータに初期化する。\n\n　\`new\`プロシージャに、私たちは構造体\`T\`を戻し、これのメンバー変数\`baz\`の数値がこの\プロシージャのパラメータ\`m\`となる。\n\nご注意、以上のコードの中にLine 6 ~ Line 8はフォームでは構造体の定義と似ているが、これが\`return\`語句である。だから、文末にセミコロンに入れる。\n\n　\`main()\`プロシージャかほかのプロシージャに構造体\`T\`を使いたい時に、\`let\`キーワードを通じて、変数を構造体種類に宣言でき、それに\`new\`プロシージャをコールして初期化する。\n\n例えば、下記のコードは変数\`x\`をメンバー変数値10の構造体に初期化する。\`T\`：\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\n\`\`\`\n\n### 実戦演習\n\n前の章節に**どうコントラクトを結ぶか**，**Moveのモジュール**、**変数とデータ種類及び所有権**、**Moveのプロシージャ及びマルチリターン値**、**Moveのプログラム構成**、**構造体の構成と使用**、**Moveのよくあるの演算子** などの知識ポイントを勉強した。今、城を建てる必要な重要なプロシージャを完成し、次これらを組み合わせ、それに\`main()\`プロシージャに城の建てを実現する。\n\n1. \`BuildCastle\`モジュールに\`newCastle\`プロシージャを添え、これで構造体\`Castle\`種類の変数を初期化し、このプロシージャに２つのパラメータがある：\n\n   - \`_name (bytearray)\`：城のネーム\n   - \`_SerialNum (u64)\`：城のシリアル番号\n\n　ご注意：\`main()\`の\`name\`と\`SerialNum\`と区別するために、私たちはパラメータの前にアンダーラインを引く。\n\n 　このプロシージャに戻り値があり、種類が\`Self.Castle\`である。\n\n   この課程の例を模倣して、以上のパラメータによってこのプロシージャに（\`_name\`, \`_SerialNum\`）城データの初期化を完成する。\n\n 　ヒント：城のネームとシリアル番号をパラメータの対応する数値に初期化し、城のレベルを1に初期化し、城の経済実力と軍事実力を\`racial_judgment()\`コールプロシージャに計算する数値に初期化する。\n\n2. \`main()\`プロシージャに、ユーザーは城のネームを入力するので、\`name\`というパラメータは外部によって入力され、\`main()\`プロシージャに\`name\`というパラメータを添え、種類が\`bytearray\`である。\n\n3. \`main()\`に\`castle\`変数を添え、それに初期化する。ヒント：\`let\`語句を一番前に入れる。\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //ここにコードを入力\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n//ここを修正する\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //ここにコードを入力\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //ここにコードを入力\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial:  "第3課程",
    title: "",
    intro: ["前の過程に私たちは基礎的な城フレームを構成した。次の第三課程に、城に煉瓦を添え、これをもっと安全にならせる。","資源の概念；どう資源を立てると廃棄するか；どうマルチファイル構成を建てるか"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "第一章 資源",
            instruction: `## 第一章 資源 \n\n今のブロックチェーンシステムに、ビットコインは"通貨"のプログラムを行い、エーテル坊が"応用"のプログラムを行い、リブラコインが"資産"のプログラムを行い、こんな資産が “資源”と呼ばれ、通貨よりもっと複雑な資産種類である。\n\nMoveの規定により、資源の操作が下記の２つの束縛条件を満足しなければならない：\n\n- **希少性の保障**：資源の総量をコントロールしなければならなく、ユーザーが勝手にコピー、再使用か廃棄してはいけない。\n- **アクセスのコントロール**：資源をアクセスする時に、ある事前定義の規則を満足しなければならない。\n\n以上の２つの束縛条件を満足するために、Moveトコントラクトに、資源はこの資源を定義するモジュールによって作成か廃棄されることができ、それに\`move()\`操作のみを受ける。即ち、\`copy()\`資源をコピーできない。\n\nMoveコンパイラはバイトコードを通じて、以上の安全的な束縛が満足されるかどうかを静的に検証し、これはバイトコード検証を通過しないプログラムコードの運行を断る。\n\n初心者にとって、一時に資源を制限される構造体と理解できる。\n\n資源の宣言と構造体が似ていて、\`resource 資源名{データ1: 種類, データ2: 種類, ...}\`という方法で宣言する。\n\n次はリブラコインという資源に対する宣言の例：\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### 実戦演習\n\n安全を保証するために、私たちは城という構造体を資源に修正する。\n\n1. \`Castle\`の種類を構造体から資源に変更する。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//ここのstruct\nを修正する        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "第二章 資源の作成",
            instruction: `## 第二章 資源の作成\n\n資源を使うために、まず資源を作成するプロシージャを実現し、このプロシージャの戻り値種類が資源種類である。\n\n例えば、下記のコードは前の課程に提出した\`LibraCoin\`の作成プロシージャで、このプロシージャは0数値の資源変数\`T\`を作成する\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\n以上により、資源の作成と構造体の初期化は似ている。\n\n### 実戦演習\n\n次、私たちは資源を作成するプロシージャを実現する。\n\n本章にアカウントの概念を導入し、全部のプレイヤーはアカウントを持ち、このアカウントは対応の城があり、アカウントを通じて城をプレイヤーと繋がることを希望する。\n\n後の課程にアカウントの具体的な機能と操作を紹介し、本章に関連のモジュールと資源を作成する。\n\n1. \`BuildCastle\`モジュールの下に\`CastleAccount\`というモジュールを作成する。\n\n2. 新しく作成されたモジュールに\`CastleAccount\`資源を宣言し、練習をするために、この資源は一時に一つの\`u64\`変数のみあり、変量名が\`a\`となる。将来、これを使う時にこの資源を改めて完全する。\n\n3. \`CastleAccount\`資源を作成するプロシージャ\`newAccount\`を実現し、このプロシージャは資源の変数\`a\`を0に初期化する。 \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//ここで新しいモジュールを作成する\n//モジュールにアカウント資源を宣言する\n//モジュールにアカウントを立てるプロシージャを実現する\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "第三章 資源の廃棄",
            instruction: `## 第三章 資源の廃棄\n\n　Move言語にガベージコレクション·メカニズムがないので、資源を使い終わる後、明示的に廃棄されなければならない。\n\n　Moveコードに、普通\`Move()\`を通じて、資源のバインディングを空きに設定し、これによって資源の廃棄を実現する。\n\nこれから簡単な例を見て、これが\`LibraCoin\`を廃棄しているプロシージャだ：\n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n     T { value } = move(coin);\n        return;\n}\n\`\`\`\n\nこのプロシージャに、まず、プロシージャ内部にメンバー変数\`value(u64)\`の局部資源変数\`T\`を宣言し、それから\`move()\`を通じて、廃棄したい\`coin\`を局部資源変数\`T\`に改めてバインディングする。このプロシージャが終わる時に、局部資源変数\`T\`が自動に廃棄され、\`coin\`資源がバインディングしなく、再びアクセスされられない資源になる。システムはバインディングしない資源を回収し、このまま、資源\`coin\`が廃棄される。\n\n### 実戦演習\n\n私たちは\`Castle\`資源と\`CastleAccount\`資源の立てを完成し、それからこれらの廃棄プロシージャを実現する。\n\n1. \`BuildCastle\`モジュールに\`desCastle\`プロシージャを立て、それに課程の例を模倣して、このプロシージャを完成し、このプロシージャのパラメータ名が\`castle\`で、プロシージャの一時変数名は前の課程のものと一致する。\n2. \`CastleAccount\`モジュールに\`desAccount\`プロシージャを立て、それにプロシージャの例を模倣して、このプロシージャを完成する。このプロシージャのパラメータ名が\`account\`で、プロシージャの一時変数名が\`num\`となる。
\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    //在这里实现销毁资源Castle的过程\n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //ここで資源CastleAccountの廃棄を実現するプロシージャ\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "第四章 資源の使用",
            instruction: `## 第四章 資源の使用\n\n資源を作成する後、資源を使える。\n\n資源の使用と構造体はほとんど一緒で、違うところは資源を使い終わる後、この資源を廃棄することである。\n\n本章に、今のトランザクションスクリプトのみに資源を使い、資源をあるアドレスへ送信しない。だから、\`main()\`が終わる前に、資源を廃棄しなければならない。\n\n次、私たちは一つと例と結び付け、資源の使用を理解し、それに資源の作成と廃棄を復習する。
\n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\nこの実例に\`MoneyHolder\`モジュールを宣言し、このモジュールに資源\`T\`があり、この資源はLine 5のプロシージャを通じて作成され、それにLine 8のプロシージャを通じて廃棄される。\n\nご注意、資源Tのメンバー変数が資源である。だから、\`T\`を廃棄する時に、二回廃棄し（即ちLine 10とLine 11）、この中に、二回目の廃棄は\`LibraCoin\`モジュールの\`coin\`の廃棄プロシージャ\`LibraCoin.destroy_zero()\`をコールした。\n\n次、この実例の\`script\`部分を見て、\`main()\`プロシージャの前の2つ桁はそれぞれ２つの資源変数を宣言し、この中に一つが\`LibraCoin.T\`で、もう一つは私たちが宣言した\`MoneyHolder.T\`である。宣言変数の後、私たちは変数を初期化する。だから、初期化されない変数を使えない。\n\nLine 21の\` LibraCoin.zero()\`は\`LibraCoin.T\`という資源の初期化プロシージャで、このプロシージャがリブラ公式の\`LibraCoin\`モジュールに定義され、ここで分析しない。\n\nLine 22の\`MoneyHolder.new(move(coin))\`は定義する資源作成プロシージャで、このプロシージャに\`money_holder\`を初期化する後、この変数を使える。\n\nご注意：ここのパラメータが\`move(coin)\`で、\`copy(coin)\`ではない。後ろの内容に\`coin\`という変数をやはり使いたくても、やはり\`copy()\`を使えない。\`coin\`が資源で、資源を\`move()\`でき、\`copy()\`できない。\n\n本実例に、私たちは\`money_holder\`を操作しない。だから、これからこれを廃棄し、これによってコントラクトを終わる。ご注意、ここのプロシージャのパラメータは同様に\`move()\`を使い、\`copy()\`を使えない。\n\n総体から言えば、使用資源の完全なプロセスは、\`let\`を通じて資源変数を宣言してから、資源を作成するプロシージャをコールし、この変数を初期化し、使い終わる後、資源を廃棄するプロシージャをコールして、変数を廃棄することで、下記の写真となる。\n\n<img src=${require("../static/images/lesson3/pic_3_4_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n### 実戦演習\n\n前の章に、城の建てとプロシージャの廃棄を完成したが、この時にこのコントラクトを順調に成功にコンパイルできない。だから、私たちは\`main()\`に資源の作成と廃棄を完全する。\n\nご注意：一時にアカウント資源は実際の働きがないので、\`main()\`にこれをコールしない。\`CastleAccount\`資源を使いたいと、\`newAccount\`と\`desAccount\`を通じて、これを作成と廃棄する。n\n1. \`main()\`に\`Castle\`資源を廃棄する語句を入れる。\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //ここにコードを入力\n\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 ファイルを分割する",
            instruction: `## 第五章 ファイルを分割する\n\nこの課程を勉強する時に、コードファイルがますます長くなる。これらをいくつかのファイルに分割して、これによって管理を便利し、コードの持続可能性を増加する。\n\nだから、この章に、右のコードをクリアし、今エディタのトップにタブが現れ、ラベルをクリックしてファイルを切り換えることができる。\n\nタブは活動タブと固定タブに分け、この中に活動タブを編集でき、これも実戦演習に修正し検査できるファイルで、固定タブが読み取り専用で、勉強している過程に調べることができるが、これを修正できない。\n\n普通、私たちは一つのモジュールを一つのファイルに入れてから、使いたいところで\`import アドレス.モジュール名\`という方法でこのモジュールをインポートし、これは第一課程の第二章に紹介した内容である。このまま、異なるモジュールの機能をメンテナンス、管理と更新できる。\n\n### 実戦演習\n\nマルチファイルの構成を立て、それにモジュールの分割を完成し、次、前完成したトランザクションスクリプトをファイルに入れる。\n\n1.作ったモジュールにブラウズし、それに今のアクティブタブにトランザクションスクリプトの内容を完成する。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここにコードを入力",
                    answer:"import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code:"module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code:"module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code:"module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lessons = [lesson1, lesson2, lesson3];

export default lessons;


