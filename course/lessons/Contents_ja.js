import React from 'react';
import L1c1 from './L1C1/L1C1'

const lesson1 = {
    info : {
        name: "Move Castle",
        subname: ["ゲームプログラムでLibra Moveを学ぼう", "*Based on Libra move Commit 61649eb"],
        intro: "既存のブロックチェーンシステムで「通貨」と「アプリケーション」をBitcoinとEthereumでプログラムしているのに対し、Libraは「資産（アセット）」を対象にします。\nLibraでは、通貨よりも複雑な「リソース」と呼ばれるアセットを定義できます。LibraではMove言語を使用してリソースの使用を制限することで、不適切な変更を防止し、アセットのセキュリティを向上させます。\nMove言語は、安全でプログラム可能なLibraブロックチェーンの基盤を提供しています。Moveのアセットを厳格な制限付きでプログラミングする方法は、デジタル通貨の発行、ブロックチェーンのトランザクション処理や権限認証の管理などに適しています。\nこのコースでは、Move言語を使ってキャッスル（城）を作ります。キャッスルの拡張やバトル機能を実装して、初心者がより効果的に言語を学習できるようにします。",
        goback: "← 戻る",
        editor: "エディタ",
        lesson: "レッスン",
        copyAnswer: "答えをコピー",
        learnmore: "もっと詳しく",
        start: "スタート",
        indexpage:"https://www.learnlibramove.com",
        learninide:["コース内のコードはChainIDEでコンパイルできます","ChainIDEへ"],
        practice: "さっそく始める",
    },
    local:{
        hint: "ヒント",
        previous: "前のチャプタ",
        next: "次のチャプタ",
        catalog: "メニュー",
        checkcode: "コードをチェック",
        showAnswer: "答えを表示",
        hideAnswer: "答えを隠す",
        contitle: ["良くできました！このチャプタは完了です。", "本レッスンは完了です。おめでとうございます！", "Keep going!"],
        concontent: ["「次に進む」をクリックして新しいチャレンジを！", "このレッスンはここで終わりです。「戻る」をクリックしてメニューに戻りましょう。", "お疲れ様でした！すべてのレッスンを完成しました。おめでとうございます！間もなくもっと多くのレッスンを皆さんにご提供する予定です。ChainIDEで、自分のLibra Moveコントラクトを作ってみましょう。"],
        concontinue: ["次に進む", "戻る", "ChainIDEへ", "次のレッスン"],
        shut: "ウィンドウを閉じる",
        target: "レッスン内容",
        keypoint: "学習ポイント",
        detail: "詳細を見る"
    },
    lessonserial: "レッスン1",
    title: "",
    intro: ["レッスン1では、順を追って独自のキャッスルワールドを構築する方法を説明します。あなたのキャッスルはユニークな外観を持っていて、不思議なクリーチャーが住んでいます。","コントラクトの作り方;Moveのモジュール;main()関数;変数とデータ型;Moveのプロシージャ"],
    key: 1,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 イントロダクション",
            instruction: `## Chapter 1 イントロダクション\n\nこのチャプタでは、どの様に城を築くのか習いましょう。\n\n* 新しく城を築くためにmoduleを使います。\n* キャッスルはデータベース（Libraブロックチェーン）に保存されます。\n\nこの後、自分のキャッスルに「パワーの拡張」や「他の城とバトルする」などの機能を付け足していきます。しかしまず最初に、城を生成する機能を最初に実現しないといけません。\n\n### 城のプロパティは？\n\n全ての城は「名前」「シリアルナンバー」「レベル」「経済力」「軍事力」を持っています。シリアルナンバーは城の「見た目」とそこに住む「種族」を決定します。レベルは城のバリューを決め、経済力、軍事力は他のと相互作用する場合のパフォーマンスに影響します。\n\n### シリアルナンバーはどの様に城に影響するの？\n\n城の見た目（アピアランス）とその種族は、例えば「83451029」の様な、シリアルナンバーと呼ぶ8桁の整数値で決められます。シリアルナンバーの個々の数字は城のプロパティと対応します。具体的には…\n\n| 1 | 2 | 3 | 4 |5  | 6 | 7 | 8 |\n|:--|:--|:--|:--|:--|:--|:--|:--|\n| size | style | color | logo style | logo color | logo position | race | special ID |\n\n新しく生成されたそれぞれの城の名前はユーザによって入力されます。シリアルナンバーは現在のブロック高(Block height)に応じてランダムに生成されます。レベルは1にイニシャライズされます。初期の経済力、軍事力はシリアルナンバーの中の「種族桁（Race digit）」で決まります。対応関係は次の様に定義されています。\n\n| Race digit | 0,5 | 1,6 | 2,7 | 3,8 | 4,9 |\n|:--|:--|:--|:--|:--|:--|\n| 経済力 | 6 | 8 | 3 | 7 | 4 |\n| 軍事力 | 6 | 3 | 8 | 4 | 7 |\n\n### 実習\n1. 右ページのスライダーをドラッグして、あるシリアルナンバーと城の見た目の対応関係を見てみましょう。\n\n**上記を理解したら「次へ進む」ボタンをクリックしてMoveの勉強を続けましょう。**\n\n`,
            type: 1, 
            show(){
                return <L1c1 lang="2"/>
            }
        },
        {
            title: "Chapter 2 スマートコントラクトとモジュール",
            instruction: `## Chapter 2 スマートコントラクトとモジュール\n\nスマートコントラクトはブロックチェーン上で動作するプログラムです。私たちは「送金」や「お買い物」といった一連の操作をブロックチェーン上で行うためにコントラクトを使います。\n\nMoveのコントラクトのコードは、次の二つのパートに分けられます。\n\n- 「modules:」で始まるモジュールセクション\n- 「script:」で始まる\`main()\`\n\nこのチャプタではモジュール部について説明し、次のチャプタでスクリプト部について説明します。\n\n### モジュール\n\nモジュール部はコントラクトに必要なモジュール群を含んでいます。モジュールはMoveコントラクトの基本パッケージ単位です。そして、全てのLibraに配置されたモジュールはグローバルです。\n\nモジュール内では、後のチャプタで説明する\`Structure\`（構造体）、\`Resource\`（リソース）、\`Procedure\`（プロシージャ）を定義できます。\n\nモジュールはEthereumにおけるスマートコントラクトや、あるいはJavaにおけるクラスにも似ています。モジュールは、モジュール内の情報にアクセスするインターフェースを使う特定の関数を持つコードブロックと見なせます。\n\n例えば、Libraコインを定義し、コインの転送やチャージを処理する\`LibraCoin\`モジュールはLibraによって公式にリリースされています。開発者がモジュールを紹介した後は、インターフェースを関連機能の実装に使うことができます。\n\n**モジュールの作りかた**\n\n\`module_name { }\`の形式でモジュールを作れます。\n\n**モジュールのインポートの仕方**\n\njavaにおける\`package name + class name\`の様に、Moveは\`address + module name\`をモジュールをインポートするのに使います。例えば次の様に。\n\n\`\`\`\nimport 0x0.LibraCoin\n\`\`\`\n\nここで\`LibraCoin\`はモジュール名で、\`0x0\`がモジュールを公開したアカウントのアドレスです。各ユーザは自分のモジュールをブロックチェーンに公開するか、ほかの人がこの様に公開したモジュールをインポートすることができます。リブラによって公開されたモジュールのアドレスは全て\`0x0\`です。\n\n同一のファイルからそこにあるモジュールをインポートする時には\`import Transaction.module name\`を利用できます。次の様にです。\n\n\`\`\`\nimport Transaction.LibraCoin\n\`\`\`\n\n### 実習\n\n城を作るにあたって、段階的に一連の築のクリエイト機能を実装する\`BuildCastle\`モジュールを作るところからスタートしましょう。\n\n1. 中身が空っぽの\`BuildCastle\`モジュールを作ってください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここにコードを入力",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "Chapter 3 コントラクトのmain関数",
            instruction: `## Chapter 3 コントラクトのmain関数\n\n### main()\n\n前のチャプタでは、モジュール構築の仕方を学びました。そして、このチャプタではモジュールをベースにしてコントラクトを完成させましょう。\n\n私たちは、コントラクト内に「トランザクションスクリプト」と呼ばれる、他のどのコードからもコールされない様な、ワンタイム実行コードを埋め込むことができます。トランザクションスクリプトは\`script:\`の記述から始まります。\n\n\`main()\`はトランザクションスクリプトを実行するための開始箇所です。\`main()\`の様なコードブロックは「プロシージャ」と言います。後のチャプタでこれらのコンセプトについては解説します。\`main()\`は特にスペシャルなプロシージャです。\n\n\`main()\`を含む、全てのプロシージャは\`return\`で終わることに注意してください。Moveコンパイラは\`return\`がなかったらそれを自動で補う様な、如何なる処理も行うことなくダイレクトに変換する、その名の通りの（単純な）コンパイラです。\n\nMoveのコントラクトを書くとき、私たちは\`main()\`を含む普通のプロシージャにおいて、いつも全ての操作を記述し、それをモジュールに配置します。最終的に、スクリプトセクションでモジュールをインポートし、そして、一連の操作実行のために、モジュールのプロシージャ群を開始ポイントの\`main()\`と共に呼び出します。概要を次の図で示します。\n\n<img src=${require("../static/images/lesson1/pic_1_2_1_en.png")} style="width:80%;position:relative;left:10%">\n\nモジュール内で他のモジュールをインポートする必要があるとき、インポートの記述は、例えばモジュール名の記述の次の行に書くなど、モジュールの最初に書く必要がありますので注意してください。\nそして、スクリプト部分で、モジュールをインポートする必要がある場合も、インポート記述はセクションの最初の行である必要があります。例えば、\`script:\`の次の行や\`main()\`の1行目などです。\n\nまとめに、基本的な空白のコントラクトのサンプルをお見せします。\n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### 実習\n\n城を作るために、まず\`BuildCastle\`という名前のモジュールや\`main()\`を含んだ、空のコントラクトを作る必要があります。\n\n1. 最初に\`modules:\`と\`script:\`を追加します。\n2. \`main()\`を\`script:\`の次の行に加えます。\`return\`を\`main()\`内につけることを忘れないでください。\n3. スクリプトセクションにmoduleをインポートします（\`main()\`の前の行に）。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここにコードを入力\nmodule BuildCastle {\n\n}\n//ここにコードを入力\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: " Chatper 4 変数バインディングとデータ型",
            instruction: `## Chatper 4 変数バインディングとデータ型\n\n### 変数バインディング\n\n変数バインディングは、後の利用のために、値を変数にバインディングすることです。\n\nRustの様にMoveは\`let variable: variable type;\`のフォーマットで\`let\`を変数バインディングに使います。例えば次の様にです。\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\n変数バインディングの後、\`=\`で変数をイニシャライズできます。例えば次の様に。\n\n\`\`\`\nx = 5;\n\`\`\`\n\n変数は全て処理の初めにバインドされなければならないことに注意してください。つまり、全ての\`let\`は初めの方に書かれなければならないのです。そうしないとコードブロックの中に書かれた\`let\`行はコンパイルエラーを引き起こします。\n\n### データ型\n\n現在のところ、Moveは次のデータ型をサポートしています。\n\n- ブール型（boolean）\n- 64ビット符号なし整数（uint64）\n- アドレス（address）\n- バイト配列（bytes）\n- 構造体（struct）\n- リソース（resource）これはMove独自のデータ型です。\n\nboolean型のデータは\`bool\`として、uint64型は\`u64\`、address型は\`address\`、byte型は\`bytearray\`として宣言される必要があります。例えば変数を次の様に定義できます。\n\n\`\`\`\nmain() {\n    //変数バインディング\n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //初期化\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h "123abc";\n    return;\n}\n\`\`\`\n\nまた、次の様にして、resouceやstructを定義できます。\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\nここで、f1やf2は変数名です。\n\nMoveは自動的に変数を初期化できないので、初期化なしの変数を使ってはいけないことに注意してください。\n\n### 実習\n\n城のシリアルナンバーは、8桁の数値です。そこで、私たちはランダムに生成されたシリアルナンバーを8桁の数に制限するために剰余演算子（％）を使います。\nそのまえに、シリアルナンバーの数値の表示に必要な\`SerialDigits\`と呼ぶ変数を用意しましょう。これがこの演習のメインタスクです。\n\`main()\`プロセスの中で、\`SerialDigits\`をu64として宣言し、それを8で初期化してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //ここにコードを入力\n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 プロシージャ",
            instruction: `## Chapter 5 プロシージャ\n\nチャプタ2で言及した様に、プロシージャは他のプログラミング言語における関数と同じ様に、モジュール内で定義できます。\n\n### プロシージャの定義\n\nプロシージャを宣言するために、そのビジビリティ（アクセス権）、名前、パラメータと戻り値を次のフォーマットで宣言します。\n\n\`Visibility Procedure name (parameter name): The type of return value\`\n\nプロシージャがパラメータを持たない時には、パラメータ名は宣言する必要がありません。また、戻り値がない場合には戻り値の型を宣言する必要はありません。\n\nモジュール内のプロセスは二つの種類のビジビリティを持ちます。\n\n- public:パブリックプロシージャは他のモジュールから呼ぶことができます。\n- private:プライベートプロシージャは同じモジュールのプロシージャからのみ呼ばれます。モジュール内のリソースは、プライベートであり他のモジュールからはパブリックプロシージャを通してのみアクセスされます。\n\nパラメータも戻り値も無いプロシージャは、次のようなフォーマットで宣言されます。\n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\nパラメータのあるプロシージャの場合は次の様に宣言されます。\n\n\`\`\`\npublic Procedure(a: u64, b: u64) {\n// パラメータの型が異なっている場合や、パラメータの数が異なる場合も形は同様です。\n    return;\n}\n\`\`\`\n\nプロシージャそれ自身も他のプロシージャのパラメータとして使われることがあることに注意してください。\n\nプロシージャが戻り値を持つなら、次の様に宣言されます。\n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 {\n// 戻り値の型が異なる場合でも形は同様です。\n    return 1;\n}\n\`\`\`\n\n上記の例においては、パブリックなプロシージャのみ定義しました。もしプライベートプロシージャを宣言したいなら\`public\`の表記を消すのみです。\n\n### プロシージャをコールする\n\nプロシージャは\`module name.procedure name\`によって呼ばれます。プロシージャが同じモジュール内の他のプロシージャによって呼ばれる場合は\`Self.procedure name\`というフォーマットを使います。\n\n次はプロシージャを定義してコールするサンプルです。\n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //定義部分。Procedureという名前のパブリックなプロシージャ\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //コール部分。Contractはモジュール名\n    Call the procedure whose module name is Contract\n    return;\n}\n\`\`\`\n\n\n### 実習\n\n前のチャプタで言及した通り、剰余演算子(%)をシリアルナンバー用の8桁の整数を得るために使います。10のn乗で割った余りはn桁の整数となるため、ここでは10の8乗を計算する手続きを採用していきます。\n\n1. \`BuildCastle\`モジュールの前に、このコースで必要な全ての計算手続きを含む\`Math\`モジュールを作ります。\n\n2. 次の様に、新しく作ったモジュール内に乗数計算を行うプロシージャ\`pow()\`を宣言してください。\n\n    - パラメータ：u64型の基数xと乗数n\n    - 戻り値：u64型の乗算結果値\n    - 計算内容：とりあえず空。コンパイルを成功させるために、戻り値を1に設定しておきましょう。この機能については次のチャプタで実装します。\n\n3. Mathモジュールをmain()の前にインポートし、\`SerialDigits\`の後に、シリアルナンバー内の桁数を表す、\`SerialLimit\`と名付けたu64の変数を宣言します。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \n//ここにコードを入力\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//ここにコードを入力\n\nmain() {\n    let SerialDigits: u64;\n    //ここにコードを入力\n\n    SerialDigits = 8;\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },    
    ]
};

const lesson2 = {
    lessonserial: "レッスン2",
    title: "",
    intro: ["レッスン1では変数とその操作を学び、城の土台となるシリアルナンバーを作ることに成功しました。レッスン2ではあなた独自のキャッスルワールドを作っていくため城の骨組み作りをガイドします。","所有権;Moveのプログラム構造;構造体;演算子;複数の戻り値があるプロシージャ"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "Chapter 1 所有権",
            instruction: `## Chapter 1 所有権\n### 所有権の使用例\n\n前のチャプタで、バインディングというワードに言及しました。実際には、このワードは「所有権のバインディング」を指します。ある識別子がある値の所有権を持っている場合に限って、私たちはこの識別子を通して値にアクセスできます。\n\n値を名前（識別子）にバインディングするとき、この値（リソース）の所有権を識別子にバインドしています。例えば…\n\n\`\`\`\nlet x: u64;\nx = 3;\n\`\`\`\n\n\`let\`記述を通して、型(u64)の数値(3)のリソースを識別子\`x\`にバインドするとき、\`x\`はこのリソースの所有権を持ち、その間、このリソースの値にアクセスしたり変更したりする排他的所有権を保持し続けます。しかし、一度他の識別子に所有権がうつされた後は、この識別子には値の所有権がなくなります。\n\n## 所有権の変更\n\n所有権の変更を行うなら、メモリ安全性のためにイコール記号（=）に代わって\`move()\`ファンクションを使わなければなりません。\n\nつまり、Moveにおいては、識別子をイコール記号（=）で繋げられません。それは識別子と値の間でのみ使うことができます。例えば次のコードは正しくありません。\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //エラー\n\`\`\`\n\n所有権の変更がどの様に行われるのか説明するサンプルは次の通りです。\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); // 3の所有権を識別子xから識別子yに変更\nz = move(x); // エラー：今識別子xは所有権が無い、初期化されていない変数なので、move(x)は失敗します。\nz = move(y); // 3の所有権がyからzに移ります。\nx = 3; 	// 再びxを3で初期化します。\nz = move(x); // この時点では3の所有権はmove()によって、xからzに変更できます。\n\`\`\`\n\n## 所有権のコピー\n\ncopy()ファンクションを使って、所有権を変更することなく、ある識別子の値を他の識別子と同じにできます。この場合、識別子はcopy()ファンクションが実行された後でもアクセス可能です。例えば…\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); // 3の所有権をxからyにコピー。\nz = move(x); // 3の所有権をxからzにムーブ。\n\`\`\`\n\nプロシージャを呼んでパラメータを渡すとき、パラメータをダイレクトに使うことは許されていないことに注意してください。その代わりに\`move(parameter name)\`あるいは\`copy(parameter name)\`といった関数を使って所有権の変更を行う必要があります。どちらで実装するかはそのパラメータがどの様に使われるかによって異なります。\n\n## 実習\n\n前のレッスンで、私たちは\`SerialLimit\`を定義しました。このチャプタでは、このパラメータの値を10<sup>SerialDigits</sup>にセットしたいと思います。\`SerialLimit\`を初期化するため\`10\`と\`SerialDigits\`というそれぞれ二つのパラメータを持つ\`pow()\`を呼びます。\n\n上記のタスクでは\`pow()\`プロシージャにパラメータとして値を渡す必要があり、それは所有権の変更を含んでいます。\`SerialDigits\`は後のチャプタでまた使われることを考慮して、ここでは\`copy()\`関数を使う様にします。この時点では\`pow()\`関数はまだ定義されていません。これは次のチャプタで実装されるでしょう。\n\n\`SerialLimit\`パラメータは\`main()\`プロシージャ内で、前のチャプタで説明した\`module name.function name\`形式の\`pow()\`関数呼び出しによって初期化されます。もし忘れてしまっていたら見直してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //ここにコードを入力\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 2 プログラムの構造",
            instruction: `## Chapter 2 プログラムの構造\n\n他の言語と似た様に、Moveは選択やループの様な一般的なプログラム構造を持っています。\n次のようなルールの\`if-else\`構文を使って単純な選択構造を実装できます。\n\nもしステートメントが一つだったとしても、分岐構文はブレース({})で括る必要があります。次の例は間違いです。\n\n\`\`\`\nmain() {\n    let x: u64;\n    if (true) x = 3; // ここでx=3は{}で括られているべき\n    return;\n}\n\`\`\`\n\n各分岐のステートメントに付け加えられるセミコロンについて、ブレースの後ろには必要ありません。次もまた間違いの例です。\n\n\`\`\`\nmain() {\n    let x: u64;\n    if (true) x = 3;\n    else {\n        x = 5\n    };　// このセミコロンは前の行につけられるべきです。\n    return;\n}\n\`\`\`\n\nもしある識別子が全てのケースを含まない分岐ステートメントの中で初期化されるなら、その識別子はその分岐の後ではアクセスできません。次の例は間違いです。\n\n\`\`\`\nmain() {\n    let x: u64;\n    if (true) {\n        x = 42;\n    }	// ここで、変数xはifブランチ内で初期化されており、一方elseブランチでは初期化されていません。そのため後でcopy(x)を使うことはできません。 \n    assert(copy(x) == 42, 42);\n    return;\n}\n\`\`\`\n\n分岐が全てのケースを含んでいる場合、識別子は分岐の後でもアクセスすることができます。以下に例示します。\n\n\`\`\`\nmain() {\n    let x: u64;\n    if (true) {\n        x = 42;\n    } else {\n        x = 43;\n    }	// この二つのブランチがtrue/falseを含んでおり、これは変数xはどうやっても初期化されることを意味しています。そのため後でcopy(x)が使えます。\n    assert(copy(x) == 42, 42);\n    return;\n}\n\`\`\`\n\n分岐の中で\`move()\`ファンクションを使うとき、所有権の問題について注意が必要です。この関数で実装されている識別子は分岐の後で再びアクセスされるべきではありません。次はダメな例です。\n\n\`\`\`\nmain() {\n    let x: u64;\n    let y: u64;\n    x = 0;\n    if (true) {\n        y = move(x);\n        // この分岐内でxの所有権をyに渡します。そのため、続くコードでcopy(x)によってxに再びアクセスすることはできません。\n    }\n    assert(copy(x) == 0, 42);\n    return;\n}\n\`\`\`\n\n\`loop\`を使ってループ構造を作ることもできます。このチャプタではスペースの関係で詳細解説しませんが、後に続くチャプチャーで説明されます。\n\n### 実習\n\n再帰はPower関数を実装する最も一般的な方法です。次はC言語でのPower関数の実装です。\n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\`\`\`\n\n上記のプログラムをエミュレートして\`pow()\`関数を\`Math\`モジュール内に実装してください。変数の所有権の問題や、\`copy()\` と \`move()\`を適切に使うことに注意してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //ここにコードを入力\n        \n        return 1; //このreturnは削除    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 3 構造体",
            instruction: `## Chapter 3 構造体\n\nムーブの構造体は他の言語の構造体と同じ様に、同じ型か異なる型のデータのコレクションからなるデータセットです。\`struct name{data: type, data:type, …}\`という形で構造体を定義できます。例えば…\n\n\`\`\`\nmodule Test {\n  // 空のstruct\n  struct Empty1 { }\n  // 二つのメンバーのあるstruct\n  struct T { a: u64, b: u64 }\n}\n\`\`\`\n\n注意：\n\n- 構造体はプロシージャの中ではなく、モジュールの冒頭部分でのみ定義できます。\n- 構造体も\`copy()\`あるいは\`move()\`が適用できます。\n\n構造体についての詳細はこの後のチャプタでカバーされます。\n\n### 実習\n\n\`name (bytearray)\`、\`SerualNum (u64)\`、\`level (u64)\`、\`economic (u64)\`、\`military (u64)\`の5つの要素を持つ\`Castle\`という構造体を\`BuildCastle\`モジュール内に定義してください。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//ここにコードを入力\n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 4 演算子",
            instruction: `## Capter 4 演算子\n\n前のセクションで、足し算や掛け算の様な、いくつかの基本的な算術演算子を使いました。このチャプタではMoveが実装している演算子についてより詳しく見ていきましょう。\n\n現在、Moveは次の算術演算子を実装しています。「足す：\`+\`」「引く：\`-\`」「掛ける：\`*\`」「割る：\`/\`」「剰余演算：\`%\`」。以下はこれらを利用するサンプルです。\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\`\`\`\n\nMoveはまた「大なり：\`>\`」や「小なり：\`<\`」「等しい：\`==\`」「大なりイコール：\`>=\`」「小なりイコール：\`<=\`」「ノットイコール：\`!=\`」といった比較演算子を実装しています。対応するサンプルを以下に示します。\n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\`\`\`\n\nそれに加えて、いくつかのビット演算子やブール演算子もMoveに実装されています。それらは後のチャプタで詳細に見ていきます。\n\n### 実習\n\n私たちのゲームでは、城のシリアルナンバーは、現在のブロック長によってランダムに生成されます。\nランダムな数値を生成する最も基本的なアルゴリズムは剰余演算で実装されるものです。\n\n次はC言語でシンプルな擬似乱数の生成を実装したサンプルです。\n明らかに、この様なプログラムで生成される乱数のシーケンスは\`next\`の初期値に依存します。\n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\`\`\`\n\n上のプロシージャにちょっと手を入れて\`seed\`をインプットすることでランダムな数を生成する次のプログラムをゲットできます。\n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\`\`\`\n\n他の言語と同様の方法で、特定の範囲のランダム数を生成するために剰余演算を利用できます。詳細には\`m\`から\`n\`の間の乱数を生成するには次の様にします。\n\n\`\`\`\nmyrand(seed) % (n - m + 1) + m;\n\`\`\`\n\n1. 上記の乱数生成プログラムを参考に。\`Math\`モジュールの中に、\`myrand()\`という乱数を生成するプロシージャをつけ加えて、その機能を実装してください。\n2. 現在のブロック高をベースに、8桁のシリアルナンバー(10<sup>7</sup>から 10<sup>8</sup>-1の間の数)を生成します。publicプロシージャの\`generateSerial()\`を\`BuildCastle\`モジュール内に付け加えて、その中から\`Math\`モジュールの\`myrand\`プロシージャを呼んでください。\n    - 現在のブロックの高さは、\`Block\`モジュールの\`get_current_height()\`メソッドによって獲得できます。\n    - \`Block\`モジュールのアドレスは\`0x00\`です。\n    - \`Math\`モジュールと\`Block\`モジュールを正しい場所でインポートしてください。\n3. \`main()\`内で\`SerialNum\`を定義して、\`generateSerial()\`プロシージャで初期化してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //ここでコードを記入する\n    \n}\nmodule BuildCastle {\n    //ここでコードを記入する\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //ここでコードを記入する\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //ここでコードを記入する\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //ここでコードを記入する\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 複数の戻り値があるプロシージャ",
            instruction: `## Chapter 5 複数の戻り値があるプロシージャ\n\nチャプタ5では、プロシージャについて説明し、一つの戻り値があるプロシージャの使い方を示しました。しかし、多くのシナリオでは、この章で説明する様な複数の戻り値があるプロシージャを使う必要があります。\n\nチャプタ5では、一つの戻り値があるプロシージャを次の様に定義しました。\n\n\`\`\`\npublic procedure name( parameter name 1，parameter name 2，...) : reture type {...}\n\`\`\`\n\n同様に、次の様に定義される二つの戻り値を持つプロシージャを例にしてみましょう。\n\n\`\`\`\npublic procedure name( parameter name 1，parameter name 2，...) : reture type * reture type {...}\n\`\`\`\n\nこのメソッドのコールは…\n\n\`\`\`\nvariable 1, variable 2, ...  = module name.procedure name( parameter name 1，parameter name 2，... )\n\`\`\`\n\n複数の戻り値があるプロシージャを使うとき、次の点に注意する必要があります。\n複数戻り値のプロシージャが、ひとつの戻り値を持つプロシージャと一緒に計算される場合には、最初のプロシージャの最後の戻り値のみが含まれています。\n\n次のコードがその例です。2行目が18行目で複数戻り値のプロシージャとして呼ばれる時、最後のひとつは\`bar()\`プロシージャの操作が終わってから導かれるため、最初のふたつの戻り値がこのプロシージャの実行結果となります。\n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\`\`\`\n\n複数の戻り値をもつプロシージャは、他の複数戻り値があるプロシージャのパラメータとして機能することができます。\n\n例えば、次のコードブロックで、2行目にある複数戻り値のプロシージャは、25行目の3つのパラメータを持つプロシージャの最初の2つのパラメータとして使われています。\n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\`\`\`\n\nもし、複数戻り値を持つプロシージャの\`return\`ステートメントが、\`switch\`構文なら、全ての分岐における型と戻り値の数が揃っているかどうかをチェックする必要があります。\n\n例えば\`bar()\`プロシージャの戻り値は6行目から10行目にあり、両方の戻り値は\`u64\`型ですが、これはプロシージャの定義と一致しています。\n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\`\`\`\n\n### 実習\n\n\`racial_judgement()\`プロシージャを\`BuildCastle\`モジュールに追加し、そして「シリアルナンバーに基づく種族を決定し、それに対応する経済力と軍事力を返す」という機能を実行してください。\n\nシリアルナンバーから種族桁(Race digit)を取り出します。ここでは、シリアルナンバーの7番目のデジットを、割り算と剰余演算によって取り出します。\n\nSwitchステートメントによって、種族に対応する経済力と戦力を決定します。種族と二つのパワー値の関係は次の様になります。\n\n| Race digit | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n|:--|:--|:--|:--|:--|:--|\n| 経済力 | 6 | 8 | 3 | 7 | 4 |\n| 軍事力 | 6 | 3 | 8 | 4 | 7 |\n\nこのプロシージャはひとつが経済力用、もう一つが軍事力用に二つのu64型の戻り値を持ちます。\n\nTips：どうやってn桁の数から、m番目の桁を切り出すの？\n\n- n桁の数で、最初のx個の桁を取り出したいなら、Num / 10<sup>n-1</sup>　の丸め込み割り算が使えます。この計算の結果は最初のn桁に基づく値になります。例えば「54321 / 10<sup>5-2</sup> = 54」\n- n桁の数で、後ろのx個の桁を取り出したいなら、Num % 10<sup>x</sup>の剰余演算が使えます。例えば「54312 % 10<sup>2</sup> = 12」\n- n桁の数で、真ん中のx桁が欲しい場合、上の二つの問題を一つに変換すると良いでしょう。そして、さらに最終的な値を計算します。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //ここにコードを入力\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 6 城の設計を完了する",
            instruction: `## Chapter 6 城の設計を完了する\n\nチャプタ3で、どうやって構造体を定義するか学びました。ここでは、構造体をどうやって初期化するか\`main()\`プロシージャでどの様に使っていくかについて学んでいきましょう。\n\n次の図の様に、構造体を初期化するためのプロシージャを作ることがあります。このプロシージャは、同じモジュールで宣言されて初期化される必要があります。構造体を初期化するために使われるプロシージャの戻り値はstruct型で、初期メンバー変数値をもった構造体を返すことで初期化を行うものです。\n\n<img src=${require("../static/images/lesson2/pic_2_6_1_en.png")} style="width:80%;position:relative;left:10%">\n\n例えば…\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\`\`\`\n\nこの例では、モジュール\`Bar\`に構造体\`T\`を定義し、\`new\`という名前のプロシージャによって、パラメータで構造体のメンバー変数を初期化します。\n\n\`new\`プロシージャでは、メンバー変数\`baz\`の値がプロシージャのパラメータ\`m\`である構造体\`T\`を返します。\n\n上記のコードで、6行目から8行目のコードは形式的に構造体の定義部分に似ていますが、実際には\`return\`構文の一部ですので、気をつけてください。そのため、後ろにセミコロンがあります。\n\n\`main()\`や他のプロシージャで構造体\`T\`を使いたいとき\`let\`ステートメントを使って変数をstruct型として宣言し、\`new\`プロシージャを呼び出してそれを初期化できます。\n\n例えば、続くコードは変数\`x\`をメンバー変数10を持った構造体\`T\`に初期化します。\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\`\`\`\n\n## 実習\n\n前のチャプタで、城を作るためのいくつかの重要なプロセスについて学んでいますので、次のステップはそれらを組み合わせて\`main()\`プロシージャ内で城を構築しましょう。\n\n1. 構造体型のCastle変数を初期化するための、\`newCastle\`プロシージャを\`BuildCastle\`モジュールに付け加えてください。このプロシージャは次のふたつのパラメータを持ちます。\n    - \`_name (bytearray)\`：城の名前です。\n    - \`_SerialNum (u64)\` ：城のシリアルナンバーを特定します。\n    Note：\`main()\`の中の\`name\`と\`SerialNum\`と区別するために上のパラメータ名の前にはアンダースコアをつけています。\n    このプロシージャは\`Self.Castle\`型の戻り値を持っています。\n    このコースの下の例に従って、二つのパラメータ（すなわち\`_name\`と\`_SerialNum\`）に基づいて城を初期化してください。\n    Tips：城の名前とシリアル番号は対応する値に初期化されます。さらに、城のレベルは1に初期化され、経済力と軍事力は\`racial_judgement()\`プロシージャを呼んで計算された値によって初期化されます。\n 2. メインプロシージャで城の名前はユーザによって入力されます。そのため\`name\`パラメータは外部入力です。このケースでは\`name\`という名前のパラメータを\`bytearray\`型で\`main()\`プロシージャに追加する必要があります。\n 3. \`main()\`に\`castle\`変数を追加してそれを初期化してください。注意：はじめに\`let\`ステートメントを入れることを覚えておいてください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //ここにコードを入力\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n//ここを修正する\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //ここにコードを入力\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //ここにコードを入力\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial:  "レッスン3",
    title: "",
    intro: ["前のレッスンでは城の骨組みを作りました。3番目のレッスンではこの城に壁を作りもっと安全にします。","リソースの概念;リソースの生成と破棄;ファイル分割の仕方"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 リソース",
            instruction: `## Chapter 1 リソース\n\n既存のブロックチェーンシステムにおいて、ビットコインは「通貨」をプログラムし、イーサリアムは「アプリケーション」をプログラムします。対して、Libraは\`Resource\`（リソース）と名付けられた、通貨よりももっと複雑なアセットをプログラムします。\n\nMoveはリソースへの操作を次の二つの制約に添う様に規制します。\n\n- 希少性(scarcity)：リソースのトータル量はユーザが勝手にコピーしたり再利用したり、破棄できない様に制限されなければならない。\n- アクセス制御（Permission control）：リソースの操作は事前定義されたルールを満たさなければならない。\n\n以上の二つの制約に合致するために、Moveのコントラクトでは、リソースはそれを定義したモジュールでのみ、生成あるいは破棄ができて、また\`move()\`ファンクションによってのみ操作することができます。そのため、リソースを\`copy()\`ファンクションで複製することは許されません。\n\nMoveコンパイラは上記のセキュリティ制約が満たされているかをバイトコード上で、静的に検証し、バイトコード検証に失敗したプログラムの実行は拒否します。\n\n初心者は、当面のところリソースは制限のついた構造体と捉えておくと良いでしょう。\n\nリソースの宣言は、構造体の宣言と似ています。\n\n\`resource name {data:type, data:type,…}\`\n\nこれは、LibraCoinリソースの宣言の例です。\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### 実習\n\nセキュリティのために、\`castle\`構造体をリソースに変更する必要があります。\n\`Castle\`の型を構造体からリソースに変更してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//このstructを修正する        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 2 リソースの生成",
            instruction: `## Chapter 2 リソースの生成\n\nリソースを使うために、私たちはその戻り値がリソースであるような、リソース生成のプロシージャを実装する必要があります。\n\n例えば、下のコードは、前のレッスンでも言及した、値が0のvalueを持つリソース変数\`T\`を生成する\`LibraCoin\`のプロシージャです。\n\n\`\`\`\nresource T {\n        value: u64,\n}\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\n見ての通り、リソースの生成は構造体の初期化に似ています。\n\n## 実習\n\nでは、リソースを生成するプロシージャを実装していきましょう。\n\nこのチャプタでは、各プレイヤーは城に対応するアカウントを持つための「アカウント」のコンセプトについて説明します。これによって、城とプレイヤーを関係付けます。\n\nアカウントの具体的な機能と操作については、以降のコースで紹介します。このチャプタではアカウントに関連したモジュールとリソースを作ることに焦点を当てます。\n\n1. \`BuildCastle\`モジュールの下に\`CastleAccount\`というモジュールを作ってください。\n2. 今新しく作ったモジュールに\`CastleAccount\`リソースを定義してください。練習のため、今はこのリソースは\`now\`というu64の変数を一つ持っているだけです。この後のチャプタで細かく説明します。\n3. \`CastleAccount\`リソースをクリエイトするためのプロシージャ\`newAccount\`を実装し、リソースの変数\`a\`を0で初期化してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//ここで新しいモジュールを作成\n//モジュールにアカウントリソースを宣言する\n//モジュールにアカウント生成のプロシージャを実装する\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Chapter 3 リソースの破棄",
            instruction: `## Chapter 3 リソースの破棄\n\nMove言語にはガーベッジコレクション機構がないので、スマートコントラクト内で宣言してクリエイトした、リソースのライフサイクルはコントラクトの消滅の最後まで続きます。そのため、リソースはリソースが生成されたモジュールの中で\`Unapck\`により破棄されなければなりません。\n\n特定のリソースをブロックチェーン内に保存しておきたいケースでは、それをブロックチェーンのアドレスに紐づけて、グローバルストレージに公開する必要があります。\n\nこのレッスンでは、どの様にしてリソースを破棄するかから始めます。そして、続くセクションでリソースの解放についてカバーします。\n\nとりわけ、リソースを\`resource name {member variable} = move(resoruce to be destroyed)\`とすることでアンパックして破壊できます。\n簡単な具体例を見てみましょう\`LibraCoin\`の破棄プロシージャです。\n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n        T { value } = move(coin);\n        return;\n}\n\`\`\`\n\nこのプロシージャにおいて、最初にu64型のメンバ変数\`value\`を持った、ローカルリソース変数の\`T\`を宣言し、そして破棄したい\`coin\`リソースをローカルリソースの\`T\`に\`move()\`関数を通して、再バインドします。このプロシージャの終わりに、ローカルリソース変数\`T\`は自動的に破棄されます。一連の結果として\`coin\`リソースはアンバインドとなってもうアクセス不能になります。システムはアンバインドされたリソースをリサイクルするので、結果的に\`coin\`リソースの破壊は達成されます。\n\n### 実習\n\nさて、\`Castle\`と\`CastleAccount\`リソースを作り、まさにこれらの破棄プロシージャを実装しようとしています。\n\nこのレッスンの例の通りに、\`desCastle\`プロシージャを\`BuildCastle\`モジュールに作ってください。このプロシージャのパラメータ名は\`castle\`で、一時変数名は前のレッスンで使われた名前と同じです。\n\nまた同様に\`CastleAccount\`モジュールに\`desAccount\`プロシージャを作成します。このプロシージャのパラメータ名は\`account\`で、一時変数には\`num\`という名前を付けます。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    ////ここにCastleを破棄するプロシージャを実装\n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //ここにCastleAccountを破棄するプロシージャを実装\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Chapter 4 リソースの使い方",
            instruction: `## Chapter 4 リソースの使い方\n\nリソースが作られて、それを使える様になりました。\n\nリソースの使い方は、それを使った後には破棄することになっているということを除いて、構造体とほぼ同じです。\n\nこのチャプタでは、リソースは現在のトランザクションスクリプトでのみ使われて、当面どのアドレスにも送られないものとします。これはリソースが\`main()\`の後で破棄されなければならないことを意味しています。\n次に、例を見てリソースをどうやって使うかを理解し、またリソースの生成と破棄について復習しましょう。\n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\`\`\`\n\nこの例では、5行目でプロシージャにより生成されて、8行目にプロシージャを通して破壊されるリソース\`T\`を持った\`MoneyHolder\`というモジュールを定義しています。\n\nリソース\`T\`のメンバ変数もまたリソースであることに注意しなければなりません。そのため、\`T\`を破棄するとき、10行目と11行目の二つの破棄が必要とされています。二つ目の破棄は\`LibraCoin\`モジュールの\`LibraCoin.destroy_zero()\`をコールして\`coin\`を破壊しています。\n\nこれは最初の2つのチャプタに含まれていたポイントです。もし忘れている場合は戻って復習してください。\n\n次にこの例のスクリプト部分を見ていきましょう。\`main()\`プロシージャの最初の2行は、二つのリソースを定義しています。その一つは\`LibraCoin.T\`でもう一つは、私たちが宣言した\`MoneyHolder.T\`です。変数の宣言の後、未初期化の変数は操作できないため、それらを初期化します。\n\n21行目の\`LibraCoin.zero()\`関数は、\`LibraCoint.T\`を初期化するためのものです。これはLibraのオフィシャルな\`LibraCoin\`モジュールで定義されたもので、ここではさらに分析することはしません。\n\n22行目の\`MoneyHolder.new(move(coin))\`は、\`money_holder\`変数をイニシャライズするために定義したリソース生成プロシージャです。そのため、この変数を今使うことができます。\n\nNote：この引数は、\`copy(coin)\`ではなく\`move(coin)\`です。もし後で\`coin\`変数を使いたいとしても、\`copy()\`関数を使うことは許されていません。\`coin\`はリソースであり、リソースは\`copy()\`関数ではなく、\`move()\`関数によってのみ操作ができるためです。\n\nここでは、\`money_holder\`の操作は実装しません。そのため次のステップは、コントラクトが抹消される前にこれを破棄することです。プロシージャ内のパラメータについても\`copy()\`ではなく\`move()\`関数を使うことに注意してください。\n\n一般にリソースを使うためには、最初に\`let\`ステートメントを通して、リソース変数を宣言しなければなりません。そしてその変数を初期化するためリソース生成のプロシージャをコールします。最後にリソースの使用が終わった時に、それを破壊するための破棄プロセスも実装します。\n\n<img src=${require("../static/images/lesson3/pic_3_4_1_en.png")} style="width:80%;position:relative;left:10%">\n\n### 実習\n\n前のチャプタで\`castle\`を生成して破棄するプロシージャを完了していますが、まだ\`main()\`プロシージャ内の、リソースの生成と破壊について細部調整が必要なため、コントラクトを上手くコンパイルすることはできません。\n\nNote:当面、アカウントリソースはどんな実際上の効果もないので、ここでは\`main()\`内でこれを呼びません。\`CastleAccount\`リソースが使われる必要があるとき、それぞれ\`newAccount\`や\`desAccount\`関数を呼ぶことによって、それを作ったり消したりできます。\n\n\`main()\`の中に\`Castle\`リソースを破棄するステートメントを追加してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //ここにコードを入力\n\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 ファイル分割",
            instruction: `## Chapter 5 ファイル分割\n\nここにきて、ファイルがどんどん長くなってきていることにお気づきかと思います。そのため、効果的な管理や読みやすさ改善のため、複数のファイルに分割した方が良さそうです。\n\nこのチャプタでは、右のコードをクリーンアップします。ご覧の通り、エディターの上部にもう少しタブがあります。そして、各タブをクリックしてファイルを切り替えることができます。\n\n上の様に、タブはアクティブなタブと固定タブに別れています。アクティブタブは、編集可能です。そしてまた、実習において私たちが編集＆チェックしようとしているファイルでもあります。一方、固定タブはリードオンリーで、学習プロセスにおいて確認することはできるものの、編集することは許されないファイルです。\n\n通常、モジュールを一つのファイルに配置し、最初のレッスンのチャプタ2で説明した通り、\`import address.module name\`によってインポートします。この方法は異なるモジュールの機能をメンテ・管理・更新するのにより便利です。\n\n### 実習\nここで、マルチファイル構造を作って、モジュールを分割しました。ここまでに完成したトランザクションスクリプトをファイルに追加してください。\n作られたモジュールを参照して、トランザクションスクリプトを現在のアクティブタブ内で完成させてください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここにコードを入力",
                    answer:"import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code:"module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code:"module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code:"module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lessons = [lesson1, lesson2, lesson3];

export default lessons;


