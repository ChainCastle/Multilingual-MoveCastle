import React from 'react';
import L1c1 from '../L1C1/L1C1'

const lesson1 = {
    info : {
        name: "動く城",
        subname: ["Libra Moveのゲーム課程", "*Libra move Commit 61649ebに基づき"],
        intro: "今のブロックチェーンシステムに、ビットコインが“仮想通貨”のプログラミングを行い、エーテル坊が“応用”のプログラミングを行い、リブラコインが“資産”のプログラミングを行う。\n\nLibraに通貨より複雑する資産類型を定義でき、こんな資産が「資源」と呼ばれる。LibraがMove言語を利用して、資源の操作を制限し、不適当な修正を防止し、これによって資産の安全性を高める。\n\nMoveが Libraブロックチェーンのために完全なプログラミング基礎を提供し、この言語が“資産”のプログラミングを行う方法、及び安全性を厳しく制限するので、これがデジタル通貨の発行、ブロックチェーン交易の扱い、及び検証機の管理に適合する。\n\n本課程に、私たちはMove言語で城を建て、それに城の拡張と対戦などの機能を実現し、これによって初心者がこの言葉をもっと速く勉強することを助ける。",
        goback: "← 戻す",
        editor: "エディタ",
        lesson: "教程",
        copyAnswer: "答えをコピーする",
        learnmore: "もっと多くのものを了解する",
        start: "勉強し始める",
        indexpage:"https://www.learnlibramove.com",
        learninide:["コース内のコードはChainIDEでコンパイルできます","ChainIDEへ"],
        practice: "今から始めます",
    },
    local:{
        hint: "ヒント",
        previous: "前の章",
        next: "次の章",
        catalog: "目録",
        checkcode: "コードを検査する",
        showAnswer: "答えを示す",
        hideAnswer: "答えを隠す",
        contitle: ["本章節を完成し、おめでとうございます~", "本課程を完成し、おめでとうございます~", "素晴らしさが続いている"],
        concontent: ["引き続き前進する”をクリックし、新しいチャレンジを迎える！", "本課程はここまで終わり、“戻し”をクリックして、目録に戻す！", "Hi~今課程のすべての内容を完成した。おめでとうございます~間もなくもっと多くの課程を皆さんに示す。「次のレッスン」をクリックして、天秤座についての新しい知識を学び続けてください！"],
        concontinue: ["引き続き前進する", "戻す", "ChainIDEへ", "次のレッスン"],
        shut: "ウィンドウをクローズする",
        target: "課程の紹介",
        keypoint: "知識ポイント",
        detail: "詳しい内容を調べる"
    },
    lessonserial: "第1課程",
    title: "",
    intro: ["課程1に、私たちは皆さんが自分の城の下地を打ち立てるよう導く。ご城にただ一つの外観があり、及び不思議な生物がここに住んでいる。", "どうコントラクトを結びか;Moveのモジュール;Moveのmain();変数及びデータ種類;Moveのプロシージャ"],
    key: 1,
    total: 5,
    chapters: [
        {
            title: "第一章 総括",
            instruction: `## 第一章 総括\n\n第一課程にどう城を建てるかを勉強する。\n\n-モジュールを通じて新しい城を建てる\n-私たちの城がデータベースに保存される（Libraブロックチェーン）\n\n後の章節に、次第に城の機能を増やし、例えば自分の実力を強める、ほかのプレイヤーの城と戦うなど、しかし、この前にまず城の機能を作らなければならない。 \n\n### 城はどんな属性があるか？\n\n全部の城は名前、シリアル 番号、レベル、経済実力と軍事実力がある。この中にシリアル番号が城の外観と生物種族を決め、レベルが城の価値を決め、経済実力と軍事実力は城がほかの城とインタラクションをしている時の表現に影響を与える。\n\n### シリアル番号がどう城に影響を与えるか？\n\n城の外観と種族はシリアル番号によって決まり、シリアル番号が8桁の数字、例えば：83451029。\n\nシリアル番号の各桁の数字は城の一つの属性に対応し、具体的なものは下記となる：\n\n|  1   |  2   |  3   |    4     |    5     |    6     |  7   |    8     |\n| :--: | :--: | :--: | :------: | :------: | :------: | :--: | :------: |\n| 大きさ | 様式 | 色 | ロゴ様式 |ロゴ色 |ロゴ位置 | 種族 | 特別な標識 |\n\nゲームの面白さを保証するために、城を建てる時のブロック深さによって、シリアル番号がリアルタイムに生まれ、ユーザー自分によって決まることではない。もちろん、これは城の外観が確定しないことを代表しない。城を建てる同時に、シリアル番号が固定値になる。新しく建てられる城の名前はユーザーによって入力され、レベルの初期値が1級で、初期の経済実力と軍事実力はシリアル番号の種族位によって決まり、これの対応関係が下記となる：\n\n|  種族位  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| 経済実力 |  6   |  8   |  3   |  7   |  4   |\n| 軍事実力 |  6   |  3   |  8   |  4   |  7   |\n\n### 実戦演習\n\n1. ページの右側のスライドをドラックし、異なるシリアル番号が対応する城の外観を探索する。\n\n\n **これの基礎的な内容を了解してから、次の章節をクリックし、続いてMove言語**を勉強する。\n\n`,
            type: 1, 
            show(){
                return <L1c1 lang="2"/>
            }
        },
        {
            title: "第二章 スマートコントラクト とモジュール",

            instruction: `## 第二章 スマートコントラクト とモジュール\n\n### コントラクトのモジュール\n\nコントラクトはブロックチェーンに運行しているコンピュータプログラムで、私たちはコントラクトを運行することを通じて、ブロックチェーンに一連の操作を完成し、例えば振り込み、商品の購買など。\n\nMoveコントラクトの全体コードは二部分に分け：\n\n- \`modules:\`を始めとするモジュール\n- \`script:\`を始めとする\`main()\`\n\n本章節に\`modules\`部分を紹介し、次の章節に\`script\`部分を紹介する。\n\n### モジュール\n\nモジュール部分はすべてのコントラクトの必要なモジュール（\`Module\`）を含み、モジュールがMoveコントラクトの基本的な実装ユニットで、 Libraに配置したすべてのモジュールが全体でえる。\n\nモジュールに　構造体(\`Struct\`)、資源(\`Resource\`)とプロシージャ(\`Procedure\`）を定義できる、これらの概念を次の章節に紹介する。\n\nモジュールはエーテル坊のスマートコントラクトと似ていて、それにJava言語のクラスと似ている。モジュールを機能のあるコードブロックと見なし、インターフェースでモジュールの内部情報をアクセスする。\n\n例えば、\`LibraCoin\`モジュールはLibra公式によって発布されたリブラコインモジュールである。このモジュールにLibra幣を定義し、Libra幣の振り込みを実現し、チャージするなどの操作を含む。開発人員はこのモジュールをインポートする後、インターフェースを通じて関連機能を実現できる。\n\n#### どうモジュールを作る\n\n\`module モジュール名 { }\`を通じて、モジュールを作る。\n\n#### どうモジュールを引用するか\n\nJavaの“パッケージ名 + クラス名”と似ている引用方法で、Moveが“アドレス+モジュール名”を通じて、\`import\`モジュールを引用し、例えば:\n\n\`import 0x0.LibraCoin\`\n\nここの\`LibraCoin\`がモジュール名で、\`0x0\`がこのモジュールを発布するアカウントのアドレスである。全部のユーザーはブロックチェーンに自分のモジュールを発布でき、それにこんな方法で他人の発布するモジュールを引用できる。Libra公式によって発布されるすべてのモジュールアドレスが\`0x0\`である。\n\n同じファイルのモジュールをインポートする時に、直接に\`import Transaction.モジュール名\`、を使える。例えばn\n\`import Transaction.LibraCoin\`\n\n### 実戦演習\n\n私たちの城を建てるために、まず\`BuildCastle\`というモジュールを作る、このモジュールに城を建てる一連の機能を実現する。\n\n1.Empty モジュールを建てる\`BuildCastle\`\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここでコードを入力する",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "第三章 コントラクトのmain()",
            instruction: `## 第三章 コントラクトの\`main()\`\n\n前の章節にどうモジュールを立てるかをマスターした。次、このモジュールに基づき、コントラクトの内容を完全する。\n\nコントラクトに一回で執行するコードを入れ、これらのコードがトランザクションスクリプトと呼ばれ、それにほかのコードによってコールされられない。トランザクションスクリプトに\`script:\`をスタートのIDとする。\n\n\`main()\`はトランザクションスクリプトを執行する入口である。私たちは似ている\`main()\`形式のコードブロックを「プロシージャ」と呼び、それに次の章節にプロシージャの概念を詳しく紹介し、\`main()\`が特別なプロシージャで、これが一回のみコールされ、それにほかのプロシージャによってコールされない。\n\nご注意、\`main()\`以内のすべてのプロシージャに\`return\`で終わり、Moveコンパイラが字面化する：これは直接にソースコードを翻訳し、ほかのことをしなく、例えば失った\`return\`'を加える。\n\nMoveコントラクトを編集する時に、すべての操作を普通のプロシージャ（\`main()\`の以外のプロシージャ）に記入し、普通のプロシージャをモジュールに入れ、最後\`script\`部分にモジュールをインポートし、それに\`main()\`を入口として、モジュールのプロシージャをコールして一連の操作を完成し、全体の構想は下記となる。\n\n<img src=${require("../../static/images/lesson1/pic_1_2_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\nご注意、モジュールにほかのモジュールをインポートする時に、インポートする語句はモジュール内部の第一桁に現れ、即ち\`module モジュール名\`の次の桁である。\`script\`部分にモジュールをインポートする時に、インポートする語句は\`script\`部分の第一桁に現れ、即ち\`script: \`の次の桁で、\`main()\`の前の桁である。\n\n以上のように、下は最も基本的な空欄コントラクト： \n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### 実戦演習\n\n立てた\`BuildCastle\`モジュールに基づき、空欄コントラクトを結ぶ。\n\n1. まず\`modules: \`と \`script: \`を添える；\n2. \`script\`の次の桁に\`main()\`を添え、\`main()\`に\`return\`語句を添える；\n3. \`script\`部分に\`import\`を通じてモジュールをインポートする（\`main()\`の前の桁）。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここでコードを入力する\nmodule BuildCastle {\n\n}\n//ここでコードを入力する\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: "第四章 バインディングとデータ種類変数",
            instruction: `## 第四章 　変数バインディングとデータ種類\n\n### **変数バインディング**\n\n変数バインディングとは、ある値をある変数にバインディングすることである。このまま、後これらを使える。\n\nRust言葉とにていて、Move言語がletキーワードを通じて変数をバインディングし、形式が下記となる：\`let 変数名: 変数種類;\`  例えば：\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\n変数をバインディングする後、初期化でき、直接にイコール\`=\`で初期化できる、例えば：\n\n\`\`\`\nx = 5;\n\`\`\`\n\nご注意、すべてのプロシージャの変数バインディングを最初に行う。即ち、すべての\`let\`語句を一番前に置き、コードブロックの中に\`let\`語句を入れたら、コンパイルが失敗になる。　\n\n### データ種類\n\n今、Move言語は下記のデータ種類を支える：\n\n- ブール（\`boolean\`）\n- 64桁の無記号整数（\`uint64\`）\n- アドレス（\`address\`）\n- バイト配列（\`bytes\`）\n- 構造体（\`struct\`）\n- 資源（\`resource\`）、これはMove言語の特有の種類\n\nこの中に、\`boolean\`種類使用\`bool\`キーワード，\`uint64\`種類使用\`u64\`キーワード，\`address\`種類使用\`address\`キーワード，\`bytes\`使用\`bytearray\`キーワード。下記の方法で異なる種類の変数を宣言できる：\n\n\`\`\`\nmain() {\n    //変数バインディング \n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //変数初期化\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h "123abc";\n    return;\n}\n\`\`\`\n\nも資源と構造体を宣言できる：\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\nこの中に，\`f1\`と\`f2\`は変数名である。\n\n 　ご注意、Move指令が自動初期化できないので、初期化しない変数を使えない。\n\n### 実戦演習\n\n城のシリアル番号が8桁の数字によって構成される。したがって、アナログ演算\`%\`を通じてリアルタイムに生まれたシリアル番号を8桁の整数に制限する。この前に、私たちは\` SerialDigits\` という変数が要り、これでシリアル番号の桁数を表示する。これは本章節の任務である。\n\n\`main()\`プロシージャに\`SerialDigits\` を u64データ種類に定義し、それにアサインが8となる。 \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //在这里输入代码\n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 プロシージャ ",
            instruction: `## 第五章 プロシージャ\n\n第二章の通りに、モジュールにプロシージャを定義でき、プロシージャがほかの言語の関数と似ている。\n\n### プロシージャの宣言 \n\nプロシージャを宣言している時に、これの可視性、名称、パラメートと戻り値を宣言し、格式が下記となる　：\n\n\`可視性 プロシージャ名( パラメータ名 ) : 戻り値の種類\`\n\nご注意：プロシージャにパラメータがない場合は、パラメータ名を宣言する必要がない；戻り値がない場合は、戻す種類を宣言する必要がない。\n\nモジュールのプロシージャに二種類の可視性がある：\n\n- 共有（public）：共有プロシージャにほかのモジュールによってコールされられる\n- プライベート（private）：プライベートプロシージャに同じモジュールのプロシージャによってコールされられる。モジュールの資源がプライベート資源で、共有プロシージャを通じてほかのモジュールによって訪問されることができる\n\n宣言したいプロシージャにパラメータと戻り値がない場合は、下記の方法で宣言する：\n\n\`\`\`\npublic Procedure() { \n 
　　	return;\n}\n\`\`\`\n\n宣言したプロシージャにパラメータがある場合は、下記の形式に変更できる：
\n\n\`\`\`\npublic Procedure(a: u64, b: u64) { //パラメータがほかの種類かもっと多い（少ない）パラメータとなる時に、形式が似ている\n    return;\n}\n\n\`\`\`\n\nご注意、プロシージャそのものはパラメータとしてほかのプロシージャにインポートできる。\n\n宣言したいプロシージャに戻り値がある場合は、下着の形式に変更する：\n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 { //戻り値がほかの種類となる時に、形式が似ている\n    return 1;\n}\n\n\`\`\`\n\n以上の例に、私たちが共有プロシージャ（public）を定義し、プライベートプロシージャを宣言したいと、直接に\`public\`を取り除くことができる。\n\n### プロシージャのコール\n\nプロシージャが \`モジュール名.プロシージャ名\` という方法でコールし、同じモジュールのプロシージャをコールすると、 \`Self.プロシージャ名\` を通じてコールする。\n\n下記が宣言を通じてプロシージャをコールする例：\n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //一つの共有プロシージャを宣言し、プロシージャ名Procedure\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //コールプロシージャに、この中にContractがモジュール名\n    return;\n}\n\n\`\`\`\n\n### 実戦演習\n\n前の章節にアナログ演算\`%\`を通じてシリアル番号を8桁の整数に転化することに言及した。具体的に言えば、一つのデジタルモード10<sup>n</sup>が得た結果はn桁の整数である。だから、ここでプロシージャを通じて計算する10<sup>8</sup>。\n\n1. \`BuildCastle\`モジュールの上に数学を演算するモジュールを立てる\`Math\`、これは本課程のすべての数学演算プロシージャを含む。\n2.新しく立てられるモジュールにべき乗演算のプロシージャを宣言する\`pow()\`、具体的に言えば、下記となる：\n   - パラメータ：u64類型の底数 x と指数 n\n   - 戻り値：u64類型のべき乗演算の結果\n   - プロシージャ内容：一時に空欄で、コンパイルを通過するために、一時に戻り値を1に設定する。次の章節にこれの機能を実現する。\n3. \`main()\`の前に数学演算モジュール\`Math\`をインポートし、それに\`SerialDigits\`の後ろに\`SerialLimit\`という\`u64\`変数を宣言 し、これはシリアル番号の桁数の制限を表す。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \n//ここでコードを入力する\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//ここでコードを入力する\n\nmain() {\n    let SerialDigits: u64;\n    //ここでコードを入力する\n\n    SerialDigits = 8;\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },    
    ]
};

const lesson2 = {
    lessonserial: "第2課程",
    title: "",
    intro: ["課程1に変数に関係する操作を勉強し、それに城のシリアル番号を成功に宣言し、城の建てに最初の基礎を打ち立てる。課程2に、城のフレームを構成するよう導き、自らで自分の城の世界を作る。","所有権;Moveのプログラム構成；構造体の構成と使用；Moveによくあるの演算子;Moveのマルチリターン値プロシージャ"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "第一章 所有権",
            instruction: `## 第一章 所有権\n\n###所有権の使用\n\n　前、「バインディング」という単語に触れた。実際、バインディングは所有権のバインディングで、ある識別子がある値の所有権を持つ時に、この識別子を通じてこの数値をアクセスすることができる。\n\nある数値をある名前（識別子）とバインディングする時に、この数値（資源）の所有権をこの識別子とバインディングする。例えば：\n\n\`\`\`\nlet x: u64;\nx = 3;\n\n\`\`\`\n\n　\`let\`キーワードを通じて識別子\`x\`と\`u64\`種類、3数値の資源とバインディングする後、\`x\`は3の所有権を持つことになる。バインディングしている間に、この識別子は独立でこの資源の所有権を持ち、この数値をアクセス、修正することができるが、バインディングをほかの識別子に移転する後、この識別子はこの数値の所有権を持たなくなる。\n\n###所有権の移転\n\n所有権を移転したい時に、メモリ安全のデザインのため、直接に\`=\`を使えなく、\`move()\`で所有権を移転しなければならない。\n\nつまり、Move言語に、識別子の間に\`=\`で繋げなく、識別子と数値のみが\`=\`で繋げる。例えば、下記のコードは間違った例である：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //error\n\n\`\`\`\n\n次、具体的なコードで所有権の移転を説明する：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); //3の所有権を識別子xから識別子に移転(move)するy\nz = move(x); //error: この時に識別子xが所有権を失い、初期化しない変数になるので、move(x)失敗\nz = move(y)　; //3の所有権を識別子yから識別子に(move)移転するz\nx = 3; 	//改めて初期化する識別子x\nz = move(x); //この時にmoveを通じて3の所有権を識別子xから識別子に移転する　z\n\n\`\`\`\n\n### 所有権のコピー\n\nある状況では、所有権を移転しない状況では、識別子の数値をもう一つの識別子の数値に等しい時に、プロシージャが要る\`copy()\`，ある識別子が\`copy\`を経る後、続いてアクセスされることができる。例えば：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); //3の所有権を識別子xから識別子y\nz = move(x)にコピーする; //3の所有権を識別子xから識別子z\n\n\`\`\`\n\n　に移転する。ご注意、プロシージャをコールする、それにパラメータをインポートする時に、直接にパラメータ名を使えなく、\`move(パラメータ名)\`か\`copy(パラメータ名)\`で、所有権をプロシージャに転送し、コードにパラメータを使った状況によって、\`move\`か\`copy\`を使うことを決める。\n\n### 実戦演習\n\n前の課程に宣言した　\`SerialLimit\`，本章に\`SerialLimit\`の数値が10<sup>SerialDigits</sup>に等しいことを希望する。これのために、\`pow()\`プロシージャをコールすることを通じて、\`SerialLimit\`を初期化する。この過程のパラメータはそれぞれ10と\`SerialDigits\`である。\n\n以上の任務に変数をパラメータとして、\`pow()\`プロシージャに伝送するので、所有権の移転にかかわり、後の内容に\`SerialDigits\`が再び使われるので、\`copy()\`を使う。この時に\`pow()\`プロシージャが空いていて、次の章にこれを実現する。\n\n\`main()\`に\`pow()\`プロシージャをコールすることを通じて、\`SerialLimit\`を初期化する。プロシージャをコールする方法は\`モジュール名.プロシージャ名\`で、前の章に紹介した。忘れたら、復習できる。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //ここでコードを入力する\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第二章 プログラムの構成",
            instruction: `## 第二章 プログラムの構成\n\nほかの言葉と似ていて、Move言語によくあるのプログラム構成があり、例えば選択とサイクルである。\n\n私たちは\`if-else\`語句を通じて簡単な構成選択を実現でき、具体的な規則が下記となる：\n\n1. 分けている語句は二重の大かっこ\`{}\`で包み、一つの語句でも必要で、下記の例は正しくない\n\n：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3; //ここ x = 3 大かっこが要る\n       return;\n   }\n   \`\`\`\n\n2. 分けている語句のセミコロン\`;\`語句の終わりに入れたら、大かっこにセミコロンを入れる必要がなく、下記の例が正しくない：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;\n       else {\n           x = 5\n       }; //ここのセミコロンは前の桁の終わりに現れる\n       return;\n   }\n   \`\`\`\n\n3. 　　識別子の初期化はブランチ語句に進行したら、ブランチ語句がすべての状況を含まない時に、ブランチが終わる後、この標識子をアクセスできなく、下記の例は正しくない：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } // ここはifブランチのみに変数xを初期化し、elseブランチに対応する状況では、 変数xが初期化されないので、後ろにcopyでx\n をアクセスできない assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n   ブランチはすべての状況を含むと、ブランチが終わる後、この識別子をアクセスでき、下記の例は正しい ：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } else {\n           x = 43;\n       } //ここの２つのブランチはtrueとfalseを含み、即ち、どんな状況では、変数xが初期化されるので、後ろにcopy\nを使える　　 assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n4. 分けている語句に\`move()\`を使う時に、所有権を注意しなければならなく、ブランチに\`move()\`される識別子は、ブランチが終わる後、再びアクセスされなく、下記の例は正しくない：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       let y: u64;\n       x = 0;\n       if (true) {\n           y = move(x); //このブランチに変数xの所有権を変数xに移転するので、後ろのコードにcopy(x)を通じて変数x\nをアクセスしない       }\n       assert(copy(x) == 0, 42);\n       return;\n   }\n   \`\`\`\n\n\`loop\`を通じて、サイクル構成を実現でき、紙幅のため、本章節に詳しく紹介しなく、後の章節に紹介する。\n\n### 実戦演習\n\nべき乗関数に最もよくあるの実現方法が再帰で、下記がC言語のべき乗関数の実例：\n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\n\`\`\`\n\n以上のプログラムを模倣ください。\`Math\`モジュールに実現する\`pow()\`の具体的な内容を実現し、変数の所有権を注意し、それに適当に使用する\`copy\`和\`move\`。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //ここでコードを入力する\n        \n        return 1; //この言葉return\nを削除する    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第三章 構造体",
            instruction: `## 第三章 構造体\n\nMove言語の構造体とほかの言葉が似ていて、同じ種類か異なる種類のデータによって構成されるデータ集合である。\`struct 構造体名{データ1: 種類, データ2: 種類, ...}\`という方法で宣言し、例えば：\n\n\`\`\`\nmodule Test {\n //空構造体\n   struct Empty1 { }\n   //２つのメンバーの構造体\n   struct T { a: u64, b: u64, }\n}\n\n\`\`\`\n\nご注意：\n\n- 構造体はモジュールの最も前に宣言し、ほかのプロシージャに宣言できない\n- 構造体も\`copy\`か\`move\`できる。\n\n構造体をもっと多く使用し、私たちは次の章節に紹介する。\n\n### 実戦演習\n\n\`BuildCastle\`モジュールに構造体\`Castle\`を宣言し、これは５つのメンバーを含む：\`name(bytearray)\`, \`SerialNum(u64)\`, \`level(u64)\`, \`economic(u64) \`和\`military(u64)\`。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//ここでコードを入力する\n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第四章 演算操作",
            instruction: `## 第四章 演算操作\n\n前の章節に、私たちは基礎的な演算を使い、例えば加算、掛け算など。この章節に、Moveが実現した何種類の演算操作を具体的に了解する。今、\n\nMove言語は下記の何種類の数学演算を実現する：足す \`+\`  引く \`-\` 掛ける\`*\`割る\`/\`摸倣\`%\`、具体的な使用実例は下記となる：\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\n\`\`\`\n\nは比較演算を実現する：大なり\`>\`、小なり\`<\`、イコール\`==\`、大なりイコール\`>=\`、小なりイコール\`<=\`、イコールならず\`!=\` 、具体的な実例は下記となる：\n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\n\`\`\`\n\nこのほかに、Moveは何種類の演算とブール演算などを実現し、紙幅のため、本章節に詳しく紹介しなく、後の章節に紹介する。\n\n### 実践演習\n\n今のブロックの深さによってリアルタイムに城のシリアル番号が生まれることを希望する。\n\n最も基礎的な乱数生成アルゴリズムはアナログ演算を通じて実現される。\n\n下記はＣ言語に簡単な疑似乱数コードを実現する例で、明らかにこんなプログラムが得た乱数系列は\`next\`初期値の選びによって決まる。\n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\n\`\`\`\n\nこのプログラムに基づき、ちょっと修正したら、シード\`seed\`によって乱数が生まれるプログラムを得る：\n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\n\`\`\`\n\nほかの言葉と完全に同じ方法で、アナログ演算を通じて、最終このコードが指定範囲の乱数に生まれる。具体的に言えば、\`m\`から\`n\`までの乱数が生まれたいと、下記のコードを使える：\n\n\`\`\`c\nmyrand(seed) % (n - m + 1) + m;\n\n\`\`\`\n\n1. 以上の乱数生成プログラムにより、在\`Math\`モジュールに乱数が生成するプロシージャ\`myrand()\`を添え、それに具体的な機能を実現する。\n2. \`BulidCastle\`モジュールに添え、それに共有プロシージャを実現する\`generateSerial()\`。このプロシージャにブロックの深さで\`Math\`モジュールの\`myrand\`をコールするプロシージャによって、リアルタイムに8桁のシリアルナンバーが生まれ（即ち10<sup>7</sup>到10<sup>8</sup>-1の間の乱数が生まれる）、パラメータがシリアルナンバー桁数制限\`SerialLimit\`で、戻り値が\`u64\`である。\n   -ブロックの深さは\`Block\` モジュールの \`get_current_height()\` を通じて得られる。\n   - \`Block\`モジュールのアドレスが\`0x0\`である。\n   - 正しいところに\`Math\`モジュールと\`Block\`モジュールをインポートする。\n3. \`main()\`に\`SerialNum\` 宣言し、それに\`generateSerial()\`プロシージャの初期化を通過する。\n\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //ここでコードを記入する\n    \n}\nmodule BuildCastle {\n    //ここでコードを記入する\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //ここでコードを記入する\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //ここでコードを記入する\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //ここでコードを記入する\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 マルチリターン値のプロシージャ",
            instruction: `## 第五章 マルチリターン値のプロシージャ\n\n第五章にプロシージャを紹介し、それに実例で戻り値があるプロシージャをどう使うかを説明する。しかし、多くのシーンに、１つのプロシージャにいつくかの戻り値があることを希望する。本章節に、マルチリターン値を編集するプロシージャを紹介する。\n\n第五章により、このように単一の戻り値のプロシージャを宣言できる：\n\n\`\`\`\npublic プロシージャ名(パラメータ名1、パラメータ名2，...) : 戻り値の種類 {...}\n\n\`\`\`\n\n２つの戻り値のプロシージャを例として、マルチリターン値のプロシージャを宣言する方式は下記となる：\n\n\`\`\`\npublic プロシージャ名(パラメータ名1、パラメータ名2，...) :  戻り値の種類 * 戻り値の種類 {...}\n\n\`\`\`\n\n　コール方法：\n\n\`\`\`\n変数1, 変数2, ...  =モジュール名.プロシージャ名( パラメータ1, パラメータ2, ...)\n\n\`\`\`\n\nマルチリターン値を使っているプロシージャに、下記を注意する：\n\n1. マルチリターン値と単一の戻り値を演算する時に、実際 マルチリターン値プロシージャの最後の戻り値と単一の戻り値のプロシージャの戻り値のみを演算する。\n\n   例えば下記の例に、Line 2はマルチリターン値プロシージャがあり、Line 18がこれをコールする時に、前の２つの戻り値はこのプロシージャが演算した結果で、三番目の戻り値はプロシージャ\`bar()\`と演算する。\n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\n\`\`\`\n\n2. 一つのマルチリターン値プロシージャはもう一つのマルチパラメータプロシージャのパラメータとすることができる。\n\n 例えば下記のコードに、Line 2に2つの戻り値のプロシージャは直接にLine 23の３つのパラメータプロシージャの前２つのパラメータになる。
\n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\n\`\`\`\n\n3. マルチリターン値プロシージャの戻し語句が分けている語句に現れたら、分けている語句の戻り値の種類と数量が一致するかどうかを検査しなければならない。\n\n   例えば下記のコードに、\`bar()\`プロシージャの戻り値がLine 6 ~ Line 10に現れ、二つのreturn語句の戻り値が全部u64となり、プロシージャに宣言する戻し種類と一致する。\n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\n\`\`\`\n\n### 実戦演習\n\n　\`BuildCastle\`モジュールに\`racial_judgment()\`プロシージャを添え、それにこれの機能を実現する：シリアル番号によって城の対応する種族を判断し、対応の初期経済実力と軍事実力に戻す。\n\n1.アナログ演算と除算演算を通じて、シリアル番号から種族値（シリアル番号の第7桁）を取る；\n2. 分けている語句で種族値の対応する経済実力と軍事実力の数値を判断し、種族値と実力値の対照関係は下記となる | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| 経済実力 |  6   |  8   |  3   |  7   |  4   |\n| 軍事実力 |  6   |  3   |  8   |  4   |  7   |\n\n3. このプロシージャに２つの\`u64\`戻り値があり、一つが経済実力値で、もう一つが軍事実力値である。\n\nヒント：\n\nどうn桁の数字から第m桁の数字を取るか？\n\n- n桁の数字Num、前x桁を取りたいと、整除法Num / 10<sup>x</sup>を使い、この演算で得た結果が前x桁の対応する数字で、例えば、54312 / 10<sup>5-2</sup>=54；\n- n桁数字Num、後x桁を取りたいと、アナログ演算Num / 10<sup>n-x</sup>を使い、この演算で得た結果が後x桁の対応する数字で、例えば、54312 / 10<sup>2</sup>=12；\n- n桁の数字Num、真ん中のx桁の数字を取りたいと、上記の演算を通じて問題を前x桁か後x桁を取ることに変ってから、計算する。\n\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //ここでコードを入力する\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "第六章 城のデザインを完全する",
            instruction: `## 第六章 城のデザインを完全する\n\n第三章にどう構造体を宣言するかを勉強した。本章にどう構造体を初期化するかを続いて勉強し、それにどう\`main()\`プロシージャにこれを使うかを勉強する。\n\n下記の写真通りに、私たちはプロシージャを構成することを通じて、構造体の初期化を実現し、それに構造体の宣言と初期化プロシージャを同じモジュールに入力し、構造体を初期化するプロシージャに対応する戻り値の種類が構造体種類となる時に使われていて、それにメンバー変数が初期値だという構造体を戻すことを通じて、構造体の初期化を実現する。\n\n<img src=${require("../../static/images/lesson2/pic_2_6_1_en.png")} style="width:80%;position:relative;left:10%">\n\n例えば：\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\n\`\`\`\n\nこの例に、私たちはモジュール\`Bar\`に構造体\`T\`を宣言し、それに\`new\`というプロシージャを通じて、構造体のメンバー変数をこのプロシージャのパラメータに初期化する。\n\n　\`new\`プロシージャに、私たちは構造体\`T\`を戻し、これのメンバー変数\`baz\`の数値がこの\プロシージャのパラメータ\`m\`となる。\n\nご注意、以上のコードの中にLine 6 ~ Line 8はフォームでは構造体の定義と似ているが、これが\`return\`語句である。だから、文末にセミコロンに入れる。\n\n　\`main()\`プロシージャかほかのプロシージャに構造体\`T\`を使いたい時に、\`let\`キーワードを通じて、変数を構造体種類に宣言でき、それに\`new\`プロシージャをコールして初期化する。\n\n例えば、下記のコードは変数\`x\`をメンバー変数値10の構造体に初期化する。\`T\`：\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\n\`\`\`\n\n### 実戦演習\n\n前の章節に**どうコントラクトを結ぶか**，**Moveのモジュール**、**変数とデータ種類及び所有権**、**Moveのプロシージャ及びマルチリターン値**、**Moveのプログラム構成**、**構造体の構成と使用**、**Moveのよくあるの演算子** などの知識ポイントを勉強した。今、城を建てる必要な重要なプロシージャを完成し、次これらを組み合わせ、それに\`main()\`プロシージャに城の建てを実現する。\n\n1. \`BuildCastle\`モジュールに\`newCastle\`プロシージャを添え、これで構造体\`Castle\`種類の変数を初期化し、このプロシージャに２つのパラメータがある：\n\n   - \`_name (bytearray)\`：城のネーム\n   - \`_SerialNum (u64)\`：城のシリアル番号\n\n　ご注意：\`main()\`の\`name\`と\`SerialNum\`と区別するために、私たちはパラメータの前にアンダーラインを引く。\n\n 　このプロシージャに戻り値があり、種類が\`Self.Castle\`である。\n\n   この課程の例を模倣して、以上のパラメータによってこのプロシージャに（\`_name\`, \`_SerialNum\`）城データの初期化を完成する。\n\n 　ヒント：城のネームとシリアル番号をパラメータの対応する数値に初期化し、城のレベルを1に初期化し、城の経済実力と軍事実力を\`racial_judgment()\`コールプロシージャに計算する数値に初期化する。\n\n2. \`main()\`プロシージャに、ユーザーは城のネームを入力するので、\`name\`というパラメータは外部によって入力され、\`main()\`プロシージャに\`name\`というパラメータを添え、種類が\`bytearray\`である。\n\n3. \`main()\`に\`castle\`変数を添え、それに初期化する。ヒント：\`let\`語句を一番前に入れる。\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //ここでコードを入力する\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n//ここを修正する\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //ここでコードを入力する\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //ここでコードを入力する\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial:  "第3課程",
    title: "",
    intro: ["前の過程に私たちは基礎的な城フレームを構成した。次の第三課程に、城に煉瓦を添え、これをもっと安全にならせる。","資源の概念；どう資源を立てると廃棄するか；どうマルチファイル構成を建てるか"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "第一章 資源",
            instruction: `## 第一章 資源 \n\n今のブロックチェーンシステムに、ビットコインは"通貨"のプログラムを行い、エーテル坊が"応用"のプログラムを行い、リブラコインが"資産"のプログラムを行い、こんな資産が “資源”と呼ばれ、通貨よりもっと複雑な資産種類である。\n\nMoveの規定により、資源の操作が下記の２つの束縛条件を満足しなければならない：\n\n- **希少性の保障**：資源の総量をコントロールしなければならなく、ユーザーが勝手にコピー、再使用か廃棄してはいけない。\n- **アクセスのコントロール**：資源をアクセスする時に、ある事前定義の規則を満足しなければならない。\n\n以上の２つの束縛条件を満足するために、Moveトコントラクトに、資源はこの資源を定義するモジュールによって作成か廃棄されることができ、それに\`move()\`操作のみを受ける。即ち、\`copy()\`資源をコピーできない。\n\nMoveコンパイラはバイトコードを通じて、以上の安全的な束縛が満足されるかどうかを静的に検証し、これはバイトコード検証を通過しないプログラムコードの運行を断る。\n\n初心者にとって、一時に資源を制限される構造体と理解できる。\n\n資源の宣言と構造体が似ていて、\`resource 資源名{データ1: 種類, データ2: 種類, ...}\`という方法で宣言する。\n\n次はリブラコインという資源に対する宣言の例：\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### 実戦演習\n\n安全を保証するために、私たちは城という構造体を資源に修正する。\n\n1. \`Castle\`の種類を構造体から資源に変更する。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//ここのstruct\nを修正する        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "第二章 資源の作成",
            instruction: `## 第二章 資源の作成\n\n資源を使うために、まず資源を作成するプロシージャを実現し、このプロシージャの戻り値種類が資源種類である。\n\n例えば、下記のコードは前の課程に提出した\`LibraCoin\`の作成プロシージャで、このプロシージャは0数値の資源変数\`T\`を作成する\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\n以上により、資源の作成と構造体の初期化は似ている。\n\n### 実戦演習\n\n次、私たちは資源を作成するプロシージャを実現する。\n\n本章にアカウントの概念を導入し、全部のプレイヤーはアカウントを持ち、このアカウントは対応の城があり、アカウントを通じて城をプレイヤーと繋がることを希望する。\n\n後の課程にアカウントの具体的な機能と操作を紹介し、本章に関連のモジュールと資源を作成する。\n\n1. \`BuildCastle\`モジュールの下に\`CastleAccount\`というモジュールを作成する。\n\n2. 新しく作成されたモジュールに\`CastleAccount\`資源を宣言し、練習をするために、この資源は一時に一つの\`u64\`変数のみあり、変量名が\`a\`となる。将来、これを使う時にこの資源を改めて完全する。\n\n3. \`CastleAccount\`資源を作成するプロシージャ\`newAccount\`を実現し、このプロシージャは資源の変数\`a\`を0に初期化する。 \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//ここで新しいモジュールを作成する\n//モジュールにアカウント資源を宣言する\n//モジュールにアカウントを立てるプロシージャを実現する\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "第三章 資源の廃棄",
            instruction: `## 第三章 資源の廃棄\n\n　Move言語にガベージコレクション·メカニズムがないので、資源を使い終わる後、明示的に廃棄されなければならない。\n\n　Moveコードに、普通\`Move()\`を通じて、資源のバインディングを空きに設定し、これによって資源の廃棄を実現する。\n\nこれから簡単な例を見て、これが\`LibraCoin\`を廃棄しているプロシージャだ：\n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n     T { value } = move(coin);\n        return;\n}\n\`\`\`\n\nこのプロシージャに、まず、プロシージャ内部にメンバー変数\`value(u64)\`の局部資源変数\`T\`を宣言し、それから\`move()\`を通じて、廃棄したい\`coin\`を局部資源変数\`T\`に改めてバインディングする。このプロシージャが終わる時に、局部資源変数\`T\`が自動に廃棄され、\`coin\`資源がバインディングしなく、再びアクセスされられない資源になる。システムはバインディングしない資源を回収し、このまま、資源\`coin\`が廃棄される。\n\n### 実戦演習\n\n私たちは\`Castle\`資源と\`CastleAccount\`資源の立てを完成し、それからこれらの廃棄プロシージャを実現する。\n\n1. \`BuildCastle\`モジュールに\`desCastle\`プロシージャを立て、それに課程の例を模倣して、このプロシージャを完成し、このプロシージャのパラメータ名が\`castle\`で、プロシージャの一時変数名は前の課程のものと一致する。\n2. \`CastleAccount\`モジュールに\`desAccount\`プロシージャを立て、それにプロシージャの例を模倣して、このプロシージャを完成する。このプロシージャのパラメータ名が\`account\`で、プロシージャの一時変数名が\`num\`となる。
\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    //在这里实现销毁资源Castle的过程\n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //ここで資源CastleAccountの廃棄を実現するプロシージャ\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "第四章 資源の使用",
            instruction: `## 第四章 資源の使用\n\n資源を作成する後、資源を使える。\n\n資源の使用と構造体はほとんど一緒で、違うところは資源を使い終わる後、この資源を廃棄することである。\n\n本章に、今のトランザクションスクリプトのみに資源を使い、資源をあるアドレスへ送信しない。だから、\`main()\`が終わる前に、資源を廃棄しなければならない。\n\n次、私たちは一つと例と結び付け、資源の使用を理解し、それに資源の作成と廃棄を復習する。
\n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\nこの実例に\`MoneyHolder\`モジュールを宣言し、このモジュールに資源\`T\`があり、この資源はLine 5のプロシージャを通じて作成され、それにLine 8のプロシージャを通じて廃棄される。\n\nご注意、資源Tのメンバー変数が資源である。だから、\`T\`を廃棄する時に、二回廃棄し（即ちLine 10とLine 11）、この中に、二回目の廃棄は\`LibraCoin\`モジュールの\`coin\`の廃棄プロシージャ\`LibraCoin.destroy_zero()\`をコールした。\n\n次、この実例の\`script\`部分を見て、\`main()\`プロシージャの前の2つ桁はそれぞれ２つの資源変数を宣言し、この中に一つが\`LibraCoin.T\`で、もう一つは私たちが宣言した\`MoneyHolder.T\`である。宣言変数の後、私たちは変数を初期化する。だから、初期化されない変数を使えない。\n\nLine 21の\` LibraCoin.zero()\`は\`LibraCoin.T\`という資源の初期化プロシージャで、このプロシージャがリブラ公式の\`LibraCoin\`モジュールに定義され、ここで分析しない。\n\nLine 22の\`MoneyHolder.new(move(coin))\`は定義する資源作成プロシージャで、このプロシージャに\`money_holder\`を初期化する後、この変数を使える。\n\nご注意：ここのパラメータが\`move(coin)\`で、\`copy(coin)\`ではない。後ろの内容に\`coin\`という変数をやはり使いたくても、やはり\`copy()\`を使えない。\`coin\`が資源で、資源を\`move()\`でき、\`copy()\`できない。\n\n本実例に、私たちは\`money_holder\`を操作しない。だから、これからこれを廃棄し、これによってコントラクトを終わる。ご注意、ここのプロシージャのパラメータは同様に\`move()\`を使い、\`copy()\`を使えない。\n\n総体から言えば、使用資源の完全なプロセスは、\`let\`を通じて資源変数を宣言してから、資源を作成するプロシージャをコールし、この変数を初期化し、使い終わる後、資源を廃棄するプロシージャをコールして、変数を廃棄することで、下記の写真となる。\n\n<img src=${require("../../static/images/lesson3/pic_3_4_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n### 実戦演習\n\n前の章に、城の建てとプロシージャの廃棄を完成したが、この時にこのコントラクトを順調に成功にコンパイルできない。だから、私たちは\`main()\`に資源の作成と廃棄を完全する。\n\nご注意：一時にアカウント資源は実際の働きがないので、\`main()\`にこれをコールしない。\`CastleAccount\`資源を使いたいと、\`newAccount\`と\`desAccount\`を通じて、これを作成と廃棄する。n\n1. \`main()\`に\`Castle\`資源を廃棄する語句を入れる。\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //ここでコードを入力する\n\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 ファイルを分割する",
            instruction: `## 第五章 ファイルを分割する\n\nこの課程を勉強する時に、コードファイルがますます長くなる。これらをいくつかのファイルに分割して、これによって管理を便利し、コードの持続可能性を増加する。\n\nだから、この章に、右のコードをクリアし、今エディタのトップにタブが現れ、ラベルをクリックしてファイルを切り換えることができる。\n\nタブは活動タブと固定タブに分け、この中に活動タブを編集でき、これも実戦演習に修正し検査できるファイルで、固定タブが読み取り専用で、勉強している過程に調べることができるが、これを修正できない。\n\n普通、私たちは一つのモジュールを一つのファイルに入れてから、使いたいところで\`import アドレス.モジュール名\`という方法でこのモジュールをインポートし、これは第一課程の第二章に紹介した内容である。このまま、異なるモジュールの機能をメンテナンス、管理と更新できる。\n\n### 実戦演習\n\nマルチファイルの構成を立て、それにモジュールの分割を完成し、次、前完成したトランザクションスクリプトをファイルに入れる。\n\n1.作ったモジュールにブラウズし、それに今のアクティブタブにトランザクションスクリプトの内容を完成する。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここでコードを入力する",
                    answer:"import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code:"module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code:"module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code:"module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lessons = [lesson1, lesson2, lesson3];

export default lessons;


