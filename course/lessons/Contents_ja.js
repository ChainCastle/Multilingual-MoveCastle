import React from 'react';
import L1c1 from './L1C1/L1C1'

const lesson1 = {
    info : {
        name: "Move Castle",
        subname: ["ゲームプログラムでLibra Moveを学ぼう", "*Based on Libra move Commit 61649eb"],
        intro: "既存のブロックチェーンシステムで「通貨」と「アプリケーション」をBitcoinとEthereumでプログラムしているのに対し、Libraは「資産（アセット）」を対象にします。\nLibraでは、通貨よりも複雑な「リソース」と呼ばれるアセットを定義できます。LibraではMove言語を使用してリソースの使用を制限することで、不適切な変更を防止し、アセットのセキュリティを向上させます。\nMove言語は、安全でプログラム可能なLibraブロックチェーンの基盤を提供しています。Moveのアセットを厳格な制限付きでプログラミングする方法は、デジタル通貨の発行、ブロックチェーンのトランザクション処理や権限認証の管理などに適しています。\nこのコースでは、Move言語を使ってキャッスル（城）を作ります。キャッスルの拡張やバトル機能を実装して、初心者がより効果的に言語を学習できるようにします。",
        goback: "← 戻る",
        editor: "エディタ",
        lesson: "レッスン",
        copyAnswer: "答えをコピー",
        learnmore: "もっと詳しく",
        start: "スタート",
        indexpage:"https://www.learnlibramove.com",
        learninide:["コース内のコードはChainIDEでコンパイルできます","ChainIDEへ"],
        practice: "さっそく始める",
    },
    local:{
        hint: "ヒント",
        previous: "前のチャプタ",
        next: "次のチャプタ",
        catalog: "メニュー",
        checkcode: "コードをチェック",
        showAnswer: "答えを表示",
        hideAnswer: "答えを隠す",
        contitle: ["良くできました！このチャプタは完了です。", "本レッスンは完了です。おめでとうございます！", "Keep going!"],
        concontent: ["「次に進む」をクリックして新しいチャレンジを！", "このレッスンはここで終わりです。「戻る」をクリックしてメニューに戻りましょう。", "お疲れ様でした！すべてのレッスンを完成しました。おめでとうございます！間もなくもっと多くのレッスンを皆さんにご提供する予定です。ChainIDEで、自分のLibra Moveコントラクトを作ってみましょう。"],
        concontinue: ["次に進む", "戻る", "ChainIDEへ", "次のレッスン"],
        shut: "ウィンドウを閉じる",
        target: "レッスン内容",
        keypoint: "学習ポイント",
        detail: "詳細を見る"
    },
    lessonserial: "レッスン1",
    title: "",
    intro: ["レッスン1では、順を追って独自のキャッスルワールドを構築する方法を説明します。あなたのキャッスルはユニークな外観を持っていて、不思議なクリーチャーが住んでいます。","コントラクトの作り方;Moveのモジュール;main()関数;変数とデータ型;Moveのプロシージャ"],
    key: 1,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 イントロダクション",
            instruction: `## Chapter 1 イントロダクション\n\nこのチャプタでは、どの様に城を築くのか習いましょう。\n\n* 新しく城を築くためにmoduleを使います。\n* キャッスルはデータベース（Libraブロックチェーン）に保存されます。\n\nこの後、自分のキャッスルに「パワーの拡張」や「他の城とバトルする」などの機能を付け足していきます。しかしまず最初に、城を生成する機能を最初に実現しないといけません。\n\n### 城のプロパティは？\n\n全ての城は「名前」「シリアルナンバー」「レベル」「経済力」「軍事力」を持っています。シリアルナンバーは城の「見た目」とそこに住む「種族」を決定します。レベルは城のバリューを決め、経済力、軍事力は他のと相互作用する場合のパフォーマンスに影響します。\n\n### シリアルナンバーはどの様に城に影響するの？\n\n城の見た目（アピアランス）とその種族は、例えば「83451029」の様な、シリアルナンバーと呼ぶ8桁の整数値で決められます。シリアルナンバーの個々の数字は城のプロパティと対応します。具体的には…\n\n| 1 | 2 | 3 | 4 |5  | 6 | 7 | 8 |\n|:--|:--|:--|:--|:--|:--|:--|:--|\n| size | style | color | logo style | logo color | logo position | race | special ID |\n\n新しく生成されたそれぞれの城の名前はユーザによって入力されます。シリアルナンバーは現在のブロック高(Block height)に応じてランダムに生成されます。レベルは1にイニシャライズされます。初期の経済力、軍事力はシリアルナンバーの中の「種族桁（Race digit）」で決まります。対応関係は次の様に定義されています。\n\n| Race digit | 0,5 | 1,6 | 2,7 | 3,8 | 4,9 |\n|:--|:--|:--|:--|:--|:--|\n| 経済力 | 6 | 8 | 3 | 7 | 4 |\n| 軍事力 | 6 | 3 | 8 | 4 | 7 |\n\n### 実習\n1. 右ページのスライダーをドラッグして、あるシリアルナンバーと城の見た目の対応関係を見てみましょう。\n\n**上記を理解したら「次へ進む」ボタンをクリックしてMoveの勉強を続けましょう。**\n\n`,
            type: 1, 
            show(){
                return <L1c1 lang="2"/>
            }
        },
        {
            title: "Chapter 2 スマートコントラクトとモジュール",
            instruction: `## Chapter 2 スマートコントラクトとモジュール\n\nスマートコントラクトはブロックチェーン上で動作するプログラムです。私たちは「送金」や「お買い物」といった一連の操作をブロックチェーン上で行うためにコントラクトを使います。\n\nMoveのコントラクトのコードは、次の二つのパートに分けられます。\n\n- 「modules:」で始まるモジュールセクション\n- 「script:」で始まる\`main()\`\n\nこのチャプタではモジュール部について説明し、次のチャプタでスクリプト部について説明します。\n\n### モジュール\n\nモジュール部はコントラクトに必要なモジュール群を含んでいます。モジュールはMoveコントラクトの基本パッケージ単位です。そして、全てのLibraに配置されたモジュールはグローバルです。\n\nモジュール内では、後のチャプタで説明する\`Structure\`（構造体）、\`Resource\`（リソース）、\`Procedure\`（プロシージャ）を定義できます。\n\nモジュールはEthereumにおけるスマートコントラクトや、あるいはJavaにおけるクラスにも似ています。モジュールは、モジュール内の情報にアクセスするインターフェースを使う特定の関数を持つコードブロックと見なせます。\n\n例えば、Libraコインを定義し、コインの転送やチャージを処理する\`LibraCoin\`モジュールはLibraによって公式にリリースされています。開発者がモジュールを紹介した後は、インターフェースを関連機能の実装に使うことができます。\n\n**モジュールの作りかた**\n\n\`module_name { }\`の形式でモジュールを作れます。\n\n**モジュールのインポートの仕方**\n\njavaにおける\`package name + class name\`の様に、Moveは\`address + module name\`をモジュールをインポートするのに使います。例えば次の様に。\n\n\`\`\`\nimport 0x0.LibraCoin\n\`\`\`\n\nここで\`LibraCoin\`はモジュール名で、\`0x0\`がモジュールを公開したアカウントのアドレスです。各ユーザは自分のモジュールをブロックチェーンに公開するか、ほかの人がこの様に公開したモジュールをインポートすることができます。リブラによって公開されたモジュールのアドレスは全て\`0x0\`です。\n\n同一のファイルからそこにあるモジュールをインポートする時には\`import Transaction.module name\`を利用できます。次の様にです。\n\n\`\`\`\nimport Transaction.LibraCoin\n\`\`\`\n\n### 実習\n\n城を作るにあたって、段階的に一連の築のクリエイト機能を実装する\`BuildCastle\`モジュールを作るところからスタートしましょう。\n\n1. 中身が空っぽの\`BuildCastle\`モジュールを作ってください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここにコードを入力",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "Chapter 3 コントラクトのmain関数",
            instruction: `## Chapter 3 コントラクトのmain関数\n\n### main()\n\n前のチャプタでは、モジュール構築の仕方を学びました。そして、このチャプタではモジュールをベースにしてコントラクトを完成させましょう。\n\n私たちは、コントラクト内に「トランザクションスクリプト」と呼ばれる、他のどのコードからもコールされない様な、ワンタイム実行コードを埋め込むことができます。トランザクションスクリプトは\`script:\`の記述から始まります。\n\n\`main()\`はトランザクションスクリプトを実行するための開始箇所です。\`main()\`の様なコードブロックは「プロシージャ」と言います。後のチャプタでこれらのコンセプトについては解説します。\`main()\`は特にスペシャルなプロシージャです。\n\n\`main()\`を含む、全てのプロシージャは\`return\`で終わることに注意してください。Moveコンパイラは\`return\`がなかったらそれを自動で補う様な、如何なる処理も行うことなくダイレクトに変換する、その名の通りの（単純な）コンパイラです。\n\nMoveのコントラクトを書くとき、私たちは\`main()\`を含む普通のプロシージャにおいて、いつも全ての操作を記述し、それをモジュールに配置します。最終的に、スクリプトセクションでモジュールをインポートし、そして、一連の操作実行のために、モジュールのプロシージャ群を開始ポイントの\`main()\`と共に呼び出します。概要を次の図で示します。\n\n<img src=${require("../static/images/lesson1/pic_1_2_1_en.png")} style="width:80%;position:relative;left:10%">\n\nモジュール内で他のモジュールをインポートする必要があるとき、インポートの記述は、例えばモジュール名の記述の次の行に書くなど、モジュールの最初に書く必要がありますので注意してください。\nそして、スクリプト部分で、モジュールをインポートする必要がある場合も、インポート記述はセクションの最初の行である必要があります。例えば、\`script:\`の次の行や\`main()\`の1行目などです。\n\nまとめに、基本的な空白のコントラクトのサンプルをお見せします。\n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### 実習\n\n城を作るために、まず\`BuildCastle\`という名前のモジュールや\`main()\`を含んだ、空のコントラクトを作る必要があります。\n\n1. 最初に\`modules:\`と\`script:\`を追加します。\n2. \`main()\`を\`script:\`の次の行に加えます。\`return\`を\`main()\`内につけることを忘れないでください。\n3. スクリプトセクションにmoduleをインポートします（\`main()\`の前の行に）。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここにコードを入力\nmodule BuildCastle {\n\n}\n//ここにコードを入力\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: " Chatper 4 変数バインディングとデータ型",
            instruction: `## Chatper 4 変数バインディングとデータ型\n\n### 変数バインディング\n\n変数バインディングは、後の利用のために、値を変数にバインディングすることです。\n\nRustの様にMoveは\`let variable: variable type;\`のフォーマットで\`let\`を変数バインディングに使います。例えば次の様にです。\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\n変数バインディングの後、\`=\`で変数をイニシャライズできます。例えば次の様に。\n\n\`\`\`\nx = 5;\n\`\`\`\n\n変数は全て処理の初めにバインドされなければならないことに注意してください。つまり、全ての\`let\`は初めの方に書かれなければならないのです。そうしないとコードブロックの中に書かれた\`let\`行はコンパイルエラーを引き起こします。\n\n### データ型\n\n現在のところ、Moveは次のデータ型をサポートしています。\n\n- ブール型（boolean）\n- 64ビット符号なし整数（uint64）\n- アドレス（address）\n- バイト配列（bytes）\n- 構造体（struct）\n- リソース（resource）これはMove独自のデータ型です。\n\nboolean型のデータは\`bool\`として、uint64型は\`u64\`、address型は\`address\`、byte型は\`bytearray\`として宣言される必要があります。例えば変数を次の様に定義できます。\n\n\`\`\`\nmain() {\n    //変数バインディング\n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //初期化\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h "123abc";\n    return;\n}\n\`\`\`\n\nまた、次の様にして、resouceやstructを定義できます。\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\nここで、f1やf2は変数名です。\n\nMoveは自動的に変数を初期化できないので、初期化なしの変数を使ってはいけないことに注意してください。\n\n### 実習\n\n城のシリアルナンバーは、8桁の数値です。そこで、私たちはランダムに生成されたシリアルナンバーを8桁の数に制限するために剰余演算子（％）を使います。\nそのまえに、シリアルナンバーの数値の表示に必要な\`SerialDigits\`と呼ぶ変数を用意しましょう。これがこの演習のメインタスクです。\n\`main()\`プロセスの中で、\`SerialDigits\`をu64として宣言し、それを8で初期化してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //ここにコードを入力\n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 プロシージャ",
            instruction: `## Chapter 5 プロシージャ\n\nチャプタ2で言及した様に、プロシージャは他のプログラミング言語における関数と同じ様に、モジュール内で定義できます。\n\n### プロシージャの定義\n\nプロシージャを宣言するために、そのビジビリティ（アクセス権）、名前、パラメータと戻り値を次のフォーマットで宣言します。\n\n\`Visibility Procedure name (parameter name): The type of return value\`\n\nプロシージャがパラメータを持たない時には、パラメータ名は宣言する必要がありません。また、戻り値がない場合には戻り値の型を宣言する必要はありません。\n\nモジュール内のプロセスは二つの種類のビジビリティを持ちます。\n\n- public:パブリックプロシージャは他のモジュールから呼ぶことができます。\n- private:プライベートプロシージャは同じモジュールのプロシージャからのみ呼ばれます。モジュール内のリソースは、プライベートであり他のモジュールからはパブリックプロシージャを通してのみアクセスされます。\n\nパラメータも戻り値も無いプロシージャは、次のようなフォーマットで宣言されます。\n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\nパラメータのあるプロシージャの場合は次の様に宣言されます。\n\n\`\`\`\npublic Procedure(a: u64, b: u64) {\n// パラメータの型が異なっている場合や、パラメータの数が異なる場合も形は同様です。\n    return;\n}\n\`\`\`\n\nプロシージャそれ自身も他のプロシージャのパラメータとして使われることがあることに注意してください。\n\nプロシージャが戻り値を持つなら、次の様に宣言されます。\n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 {\n// 戻り値の型が異なる場合でも形は同様です。\n    return 1;\n}\n\`\`\`\n\n上記の例においては、パブリックなプロシージャのみ定義しました。もしプライベートプロシージャを宣言したいなら\`public\`の表記を消すのみです。\n\n### プロシージャをコールする\n\nプロシージャは\`module name.procedure name\`によって呼ばれます。プロシージャが同じモジュール内の他のプロシージャによって呼ばれる場合は\`Self.procedure name\`というフォーマットを使います。\n\n次はプロシージャを定義してコールするサンプルです。\n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //定義部分。Procedureという名前のパブリックなプロシージャ\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //コール部分。Contractはモジュール名\n    Call the procedure whose module name is Contract\n    return;\n}\n\`\`\`\n\n\n### 実習\n\n前のチャプタで言及した通り、剰余演算子(%)をシリアルナンバー用の8桁の整数を得るために使います。10のn乗で割った余りはn桁の整数となるため、ここでは10の8乗を計算する手続きを採用していきます。\n\n1. \`BuildCastle\`モジュールの前に、このコースで必要な全ての計算手続きを含む\`Math\`モジュールを作ります。\n\n2. 次の様に、新しく作ったモジュール内に乗数計算を行うプロシージャ\`pow()\`を宣言してください。\n\n    - パラメータ：u64型の基数xと乗数n\n    - 戻り値：u64型の乗算結果値\n    - 計算内容：とりあえず空。コンパイルを成功させるために、戻り値を1に設定しておきましょう。この機能については次のチャプタで実装します。\n\n3. Mathモジュールをmain()の前にインポートし、\`SerialDigits\`の後に、シリアルナンバー内の桁数を表す、\`SerialLimit\`と名付けたu64の変数を宣言します。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \n//ここにコードを入力\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//ここにコードを入力\n\nmain() {\n    let SerialDigits: u64;\n    //ここにコードを入力\n\n    SerialDigits = 8;\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },    
    ]
};

const lesson2 = {
    lessonserial: "レッスン2",
    title: "",
    intro: ["レッスン1では変数とその操作を学び、城を作る礎となるシリアルナンバーを作ることに成功しました。レッスン2ではあなた独自のキャッスルワールドを作っていくため城のフレームワーク作りをガイドします。","所有権;Moveのプログラム構造;構造体;演算子;複数の戻り値があるプロシージャ"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "Chapter 1 所有権",
            instruction: `## Chapter 1 所有権\n### 所有権の使用例\n\n前のチャプタで、バインディングというワードに言及しました。実際には、このワードは「所有権のバインディング」を指します。ある識別子がある値の所有権を持っている場合に限って、私たちはこの識別子を通して値にアクセスできます。\n\n値を名前（識別子）にバインディングするとき、この値（リソース）の所有権を識別子にバインドしています。例えば…\n\n\`\`\`\nlet x: u64;\nx = 3;\n\`\`\`\n\n\`let\`記述を通して、型(u64)の数値(3)のリソースを識別子\`x\`にバインドするとき、\`x\`はこのリソースの所有権を持ち、その間、このリソースの値にアクセスしたり変更したりする排他的所有権を保持し続けます。しかし、一度他の識別子に所有権がうつされた後は、この識別子には値の所有権がなくなります。\n\n## 所有権の変更\n\n所有権の変更を行うなら、メモリ安全性のためにイコール記号（=）に代わって\`move()\`ファンクションを使わなければなりません。\n\nつまり、Moveにおいては、識別子をイコール記号（=）で繋げられません。それは識別子と値の間でのみ使うことができます。例えば次のコードは正しくありません。\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //エラー\n\`\`\`\n\n所有権の変更がどの様に行われるのか説明するサンプルは次の通りです。\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); // 3の所有権を識別子xから識別子yに変更\nz = move(x); // エラー：今識別子xは所有権が無い、初期化されていない変数なので、move(x)は失敗します。\nz = move(y); // 3の所有権がyからzに移ります。\nx = 3; 	// 再びxを3で初期化します。\nz = move(x); // この時点では3の所有権はmove()によって、xからzに変更できます。\n\`\`\`\n\n## 所有権のコピー\n\ncopy()ファンクションを使って、所有権を変更することなく、ある識別子の値を他の識別子と同じにできます。この場合、識別子はcopy()ファンクションが実行された後でもアクセス可能です。例えば…\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); // 3の所有権をxからyにコピー。\nz = move(x); // 3の所有権をxからzにムーブ。\n\`\`\`\n\nプロシージャを呼んでパラメータを渡すとき、パラメータをダイレクトに使うことは許されていないことに注意してください。その代わりに\`move(parameter name)\`あるいは\`copy(parameter name)\`といった関数を使って所有権の変更を行う必要があります。どちらで実装するかはそのパラメータがどの様に使われるかによって異なります。\n\n## 実習\n\n前のレッスンで、私たちは\`SerialLimit\`を定義しました。このチャプタでは、このパラメータの値を10<sup>SerialDigits</sup>にセットしたいと思います。\`SerialLimit\`を初期化するため\`10\`と\`SerialDigits\`というそれぞれ二つのパラメータを持つ\`pow()\`を呼びます。\n\n上記のタスクでは\`pow()\`プロシージャにパラメータとして値を渡す必要があり、それは所有権の変更を含んでいます。\`SerialDigits\`は後のチャプタでまた使われることを考慮して、ここでは\`copy()\`関数を使う様にします。この時点では\`pow()\`関数はまだ定義されていません。これは次のチャプタで実装されるでしょう。\n\n\`SerialLimit\`パラメータは\`main()\`プロシージャ内で、前のチャプタで説明した\`module name.function name\`形式の\`pow()\`関数呼び出しによって初期化されます。もし忘れてしまっていたら見直してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //ここにコードを入力\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 2 プログラムの構造",
            instruction: `## Chapter 2 プログラムの構造\n\n他の言語と似た様に、Moveは選択やループの様な一般的なプログラム構造を持っています。\n次のようなルールの\`if-else\`構文を使って単純な選択構造を実装できます。\n\nもしステートメントが一つだったとしても、分岐構文はブレース({})で括る必要があります。次の例は間違いです。\n\n\`\`\`\nmain() {\n    let x: u64;\n    if (true) x = 3; // ここでx=3は{}で括られているべき\n    return;\n}\n\`\`\`\n\n各分岐のステートメントに付け加えられるセミコロンについて、ブレースの後ろには必要ありません。次もまた間違いの例です。\n\n\`\`\`\nmain() {\n    let x: u64;\n    if (true) x = 3;\n    else {\n        x = 5\n    };　// このセミコロンは前の行につけられるべきです。\n    return;\n}\n\`\`\`\n\nもしある識別子が全てのケースを含まない分岐ステートメントの中で初期化されるなら、その識別子はその分岐の後ではアクセスできません。次の例は間違いです。\n\n\`\`\`\nmain() {\n    let x: u64;\n    if (true) {\n        x = 42;\n    }	// ここで、変数xはifブランチ内で初期化されており、一方elseブランチでは初期化されていません。そのため後でcopy(x)を使うことはできません。 \n    assert(copy(x) == 42, 42);\n    return;\n}\n\`\`\`\n\n分岐が全てのケースを含んでいる場合、識別子は分岐の後でもアクセスすることができます。以下に例示します。\n\n\`\`\`\nmain() {\n    let x: u64;\n    if (true) {\n        x = 42;\n    } else {\n        x = 43;\n    }	// この二つのブランチがtrue/falseを含んでおり、これは変数xはどうやっても初期化されることを意味しています。そのため後でcopy(x)が使えます。\n    assert(copy(x) == 42, 42);\n    return;\n}\n\`\`\`\n\n分岐の中で\`move()\`ファンクションを使うとき、所有権の問題について注意が必要です。この関数で実装されている識別子は分岐の後で再びアクセスされるべきではありません。次はダメな例です。\n\n\`\`\`\nmain() {\n    let x: u64;\n    let y: u64;\n    x = 0;\n    if (true) {\n        y = move(x);\n        // この分岐内でxの所有権をyに渡します。そのため、続くコードでcopy(x)によってxに再びアクセスすることはできません。\n    }\n    assert(copy(x) == 0, 42);\n    return;\n}\n\`\`\`\n\n\`loop\`を使ってループ構造を作ることもできます。このチャプタではスペースの関係で詳細解説しませんが、後に続くチャプチャーで説明されます。\n\n### 実習\n\n再帰はPower関数を実装する最も一般的な方法です。次はC言語でのPower関数の実装です。\n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\`\`\`\n\n上記のプログラムをエミュレートして\`pow()\`関数を\`Math\`モジュール内に実装してください。変数の所有権の問題や、\`copy()\` と \`move()\`を適切に使うことに注意してください。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //ここにコードを入力\n        \n        return 1; //このreturnは削除    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 3 構造体",
            instruction: `## Chapter 3 構造体\n\nムーブの構造体は他の言語の構造体と同じ様に、同じ型か異なる型のデータのコレクションからなるデータセットです。\`struct name{data: type, data:type, …}\`という形で構造体を定義できます。例えば…\n\n\`\`\`\nmodule Test {\n  // 空のstruct\n  struct Empty1 { }\n  // 二つのメンバーのあるstruct\n  struct T { a: u64, b: u64 }\n}\n\`\`\`\n\n注意：\n\n- 構造体はプロシージャの中ではなく、モジュールの冒頭部分でのみ定義できます。\n- 構造体も\`copy()\`あるいは\`move()\`が適用できます。\n\n構造体についての詳細はこの後のチャプタでカバーされます。\n\n### 実習\n\n\`name (bytearray)\`、\`SerualNum (u64)\`、\`level (u64)\`、\`economic (u64)\`、\`military (u64)\`の5つの要素を持つ\`Castle\`という構造体を\`BuildCastle\`モジュール内に定義してください。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//ここにコードを入力\n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 4 演算子",
            instruction: `## Capter 4 演算子\n\n前のセクションで、足し算や掛け算の様な、いくつかの基本的な算術演算子を使いました。このチャプタではMoveが実装している演算子についてより詳しく見ていきましょう。\n\n現在、Moveは次の算術演算子を実装しています。「足す：\`+\`」「引く：\`-\`」「掛ける：\`*\`」「割る：\`/\`」「剰余演算：\`%\`」。以下はこれらを利用するサンプルです。\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\`\`\`\n\nMoveはまた「大なり：\`>\`」や「小なり：\`<\`」「等しい：\`==\`」「大なりイコール：\`>=\`」「小なりイコール：\`<=\`」「ノットイコール：\`!=\`」といった比較演算子を実装しています。対応するサンプルを以下に示します。\n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\`\`\`\n\nそれに加えて、いくつかのビット演算子やブール演算子もMoveに実装されています。それらは後のチャプタで詳細に見ていきます。\n\n### 実習\n\n私たちのゲームでは、城のシリアルナンバーは、現在のブロック長によってランダムに生成されます。\nランダムな数値を生成する最も基本的なアルゴリズムは剰余演算で実装されるものです。\n\n次はC言語でシンプルな擬似乱数の生成を実装したサンプルです。\n明らかに、この様なプログラムで生成される乱数のシーケンスは\`next\`の初期値に依存します。\n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\`\`\`\n\n上のプロシージャにちょっと手を入れて\`seed\`をインプットすることでランダムな数を生成する次のプログラムをゲットできます。\n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\`\`\`\n\n他の言語と同様の方法で、特定の範囲のランダム数を生成するために剰余演算を利用できます。詳細には\`m\`から\`n\`の間の乱数を生成するには次の様にします。\n\n\`\`\`\nmyrand(seed) % (n - m + 1) + m;\n\`\`\`\n\n1. 上記の乱数生成プログラムを参考に。\`Math\`モジュールの中に、\`myrand()\`という乱数を生成するプロシージャをつけ加えて、その機能を実装してください。\n2. 現在のブロック高をベースに、8桁のシリアルナンバー(10<sup>7</sup>から 10<sup>8</sup>-1の間の数)を生成します。publicプロシージャの\`generateSerial()\`を\`BuildCastle\`モジュール内に付け加えて、その中から\`Math\`モジュールの\`myrand\`プロシージャを呼んでください。\n    - 現在のブロックの高さは、\`Block\`モジュールの\`get_current_height()\`メソッドによって獲得できます。\n    - \`Block\`モジュールのアドレスは\`0x00\`です。\n    - \`Math\`モジュールと\`Block\`モジュールを正しい場所でインポートしてください。\n3. \`main()\`内で\`SerialNum\`を定義して、\`generateSerial()\`プロシージャで初期化してください。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //ここでコードを記入する\n    \n}\nmodule BuildCastle {\n    //ここでコードを記入する\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //ここでコードを記入する\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //ここでコードを記入する\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //ここでコードを記入する\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 複数の戻り値があるプロシージャ",
            instruction: `## Chapter 5 複数の戻り値があるプロシージャ\n\nチャプタ5では、プロシージャについて説明し、一つの戻り値があるプロシージャの使い方を示しました。しかし、多くのシナリオでは、この章で説明する様な複数の戻り値があるプロシージャを使う必要があります。\n\nチャプタ5では、一つの戻り値があるプロシージャを次の様に定義しました。\n\n\`\`\`\npublic procedure name( parameter name 1，parameter name 2，...) : reture type {...}\n\`\`\`\n\n同様に、次の様に定義される二つの戻り値を持つプロシージャを例にしてみましょう。\n\n\`\`\`\npublic procedure name( parameter name 1，parameter name 2，...) : reture type * reture type {...}\n\`\`\`\n\nこのメソッドのコールは…\n\n\`\`\`\nvariable 1, variable 2, ...  = module name.procedure name( parameter name 1，parameter name 2，... )\n\`\`\`\n\n複数の戻り値があるプロシージャを使うとき、次の点に注意する必要があります。\n複数戻り値のプロシージャが、ひとつの戻り値を持つプロシージャと一緒に計算される場合には、最初のプロシージャの最後の戻り値のみが含まれています。\n\n次のコードがその例です。2行目が18行目で複数戻り値のプロシージャとして呼ばれる時、最後のひとつは\`bar()\`プロシージャの操作が終わってから導かれるため、最初のふたつの戻り値がこのプロシージャの実行結果となります。\n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\`\`\`\n\n複数の戻り値をもつプロシージャは、他の複数戻り値があるプロシージャのパラメータとして機能することができます。\n\n例えば、次のコードブロックで、2行目にある複数戻り値のプロシージャは、25行目の3つのパラメータを持つプロシージャの最初の2つのパラメータとして使われています。\n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\`\`\`\n\nもし、複数戻り値を持つプロシージャの\`return\`ステートメントが、\`switch\`構文なら、全ての分岐における型と戻り値の数が揃っているかどうかをチェックする必要があります。\n\n例えば\`bar()\`プロシージャの戻り値は6行目から10行目にあり、両方の戻り値は\`u64\`型ですが、これはプロシージャの定義と一致しています。\n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\`\`\`\n\n### 実習\n\n\`racial_judgement()\`プロシージャを\`BuildCastle\`モジュールに追加し、そして「シリアルナンバーに基づく種族を決定し、それに対応する経済力と軍事力を返す」という機能を実行してください。\n\nシリアルナンバーから種族桁(Race digit)を取り出します。ここでは、シリアルナンバーの7番目のデジットを、割り算と剰余演算によって取り出します。\n\nSwitchステートメントによって、種族に対応する経済力と戦力を決定します。種族と二つのパワー値の関係は次の様になります。\n\n| Race digit | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n|:--|:--|:--|:--|:--|:--|\n| 経済力 | 6 | 8 | 3 | 7 | 4 |\n| 軍事力 | 6 | 3 | 8 | 4 | 7 |\n\nこのプロシージャはひとつが経済力用、もう一つが軍事力用に二つのu64型の戻り値を持ちます。\n\nTips：どうやってn桁の数から、m番目の桁を切り出すの？\n\n- n桁の数で、最初のx個の桁を取り出したいなら、Num / 10<sup>n-1</sup>　の丸め込み割り算が使えます。この計算の結果は最初のn桁に基づく値になります。例えば「54321 / 10<sup>5-2</sup> = 54」\n- n桁の数で、後ろのx個の桁を取り出したいなら、Num % 10<sup>x</sup>の剰余演算が使えます。例えば「54312 % 10<sup>2</sup> = 12」\n- n桁の数で、真ん中のx桁が欲しい場合、上の二つの問題を一つに変換すると良いでしょう。そして、さらに最終的な値を計算します。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //ここにコードを入力\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 6 城の設計を完了する",
            instruction: `## Chapter 6 城の設計を完了する\n\nチャプタ3で、どうやって構造体を定義するか学びました。ここでは、構造体をどうやって初期化するか\`main()\`プロシージャでどの様に使っていくかについて学んでいきましょう。\n\n次の図の様に、構造体を初期化するためのプロシージャを作ることがあります。このプロシージャは、同じモジュールで宣言されて初期化される必要があります。構造体を初期化するために使われるプロシージャの戻り値はstruct型で、初期メンバー変数値をもった構造体を返すことで初期化を行うものです。\n\n<img src=${require("../static/images/lesson2/pic_2_6_1_en.png")} style="width:80%;position:relative;left:10%">\n\n例えば…\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\`\`\`\n\nこの例では、モジュール\`Bar\`に構造体\`T\`を定義し、\`new\`という名前のプロシージャによって、パラメータで構造体のメンバー変数を初期化します。\n\n\`new\`プロシージャでは、メンバー変数\`baz\`の値がプロシージャのパラメータ\`m\`である構造体\`T\`を返します。\n\n上記のコードで、6行目から8行目のコードは形式的に構造体の定義部分に似ていますが、実際には\`return\`構文の一部ですので、気をつけてください。そのため、後ろにセミコロンがあります。\n\n\`main()\`や他のプロシージャで構造体\`T\`を使いたいとき\`let\`ステートメントを使って変数をstruct型として宣言し、\`new\`プロシージャを呼び出してそれを初期化できます。\n\n例えば、続くコードは変数\`x\`をメンバー変数10を持った構造体\`T\`に初期化します。\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\`\`\`\n\n## 実習\n\n前のチャプタで、城を作るためのいくつかの重要なプロセスについて学んでいますので、次のステップはそれらを組み合わせて\`main()\`プロシージャ内で城を構築しましょう。\n\n1. 構造体型のCastle変数を初期化するための、\`newCastle\`プロシージャを\`BuildCastle\`モジュールに付け加えてください。このプロシージャは次のふたつのパラメータを持ちます。\n    - \`_name (bytearray)\`：城の名前です。\n    - \`_SerialNum (u64)\` ：城のシリアルナンバーを特定します。\n    Note：\`main()\`の中の\`name\`と\`SerialNum\`と区別するために上のパラメータ名の前にはアンダースコアをつけています。\n    このプロシージャは\`Self.Castle\`型の戻り値を持っています。\n    このコースの下の例に従って、二つのパラメータ（すなわち\`_name\`と\`_SerialNum\`）に基づいて城を初期化してください。\n    Tips：城の名前とシリアル番号は対応する値に初期化されます。さらに、城のレベルは1に初期化され、経済力と軍事力は\`racial_judgement()\`プロシージャを呼んで計算された値によって初期化されます。\n 2. メインプロシージャで城の名前はユーザによって入力されます。そのため\`name\`パラメータは外部入力です。このケースでは\`name\`という名前のパラメータを\`bytearray\`型で\`main()\`プロシージャに追加する必要があります。\n 3. \`main()\`に\`castle\`変数を追加してそれを初期化してください。注意：はじめに\`let\`ステートメントを入れることを覚えておいてください。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //ここにコードを入力\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n//ここを修正する\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //ここにコードを入力\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //ここにコードを入力\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial:  "第3課程",
    title: "",
    intro: ["前の過程に私たちは基礎的な城フレームを構成した。次の第三課程に、城に煉瓦を添え、これをもっと安全にならせる。","資源の概念；どう資源を立てると廃棄するか；どうマルチファイル構成を建てるか"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "第一章 資源",
            instruction: `## 第一章 資源 \n\n今のブロックチェーンシステムに、ビットコインは"通貨"のプログラムを行い、エーテル坊が"応用"のプログラムを行い、リブラコインが"資産"のプログラムを行い、こんな資産が “資源”と呼ばれ、通貨よりもっと複雑な資産種類である。\n\nMoveの規定により、資源の操作が下記の２つの束縛条件を満足しなければならない：\n\n- **希少性の保障**：資源の総量をコントロールしなければならなく、ユーザーが勝手にコピー、再使用か廃棄してはいけない。\n- **アクセスのコントロール**：資源をアクセスする時に、ある事前定義の規則を満足しなければならない。\n\n以上の２つの束縛条件を満足するために、Moveトコントラクトに、資源はこの資源を定義するモジュールによって作成か廃棄されることができ、それに\`move()\`操作のみを受ける。即ち、\`copy()\`資源をコピーできない。\n\nMoveコンパイラはバイトコードを通じて、以上の安全的な束縛が満足されるかどうかを静的に検証し、これはバイトコード検証を通過しないプログラムコードの運行を断る。\n\n初心者にとって、一時に資源を制限される構造体と理解できる。\n\n資源の宣言と構造体が似ていて、\`resource 資源名{データ1: 種類, データ2: 種類, ...}\`という方法で宣言する。\n\n次はリブラコインという資源に対する宣言の例：\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### 実戦演習\n\n安全を保証するために、私たちは城という構造体を資源に修正する。\n\n1. \`Castle\`の種類を構造体から資源に変更する。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//ここのstruct\nを修正する        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "第二章 資源の作成",
            instruction: `## 第二章 資源の作成\n\n資源を使うために、まず資源を作成するプロシージャを実現し、このプロシージャの戻り値種類が資源種類である。\n\n例えば、下記のコードは前の課程に提出した\`LibraCoin\`の作成プロシージャで、このプロシージャは0数値の資源変数\`T\`を作成する\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\n以上により、資源の作成と構造体の初期化は似ている。\n\n### 実戦演習\n\n次、私たちは資源を作成するプロシージャを実現する。\n\n本章にアカウントの概念を導入し、全部のプレイヤーはアカウントを持ち、このアカウントは対応の城があり、アカウントを通じて城をプレイヤーと繋がることを希望する。\n\n後の課程にアカウントの具体的な機能と操作を紹介し、本章に関連のモジュールと資源を作成する。\n\n1. \`BuildCastle\`モジュールの下に\`CastleAccount\`というモジュールを作成する。\n\n2. 新しく作成されたモジュールに\`CastleAccount\`資源を宣言し、練習をするために、この資源は一時に一つの\`u64\`変数のみあり、変量名が\`a\`となる。将来、これを使う時にこの資源を改めて完全する。\n\n3. \`CastleAccount\`資源を作成するプロシージャ\`newAccount\`を実現し、このプロシージャは資源の変数\`a\`を0に初期化する。 \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//ここで新しいモジュールを作成する\n//モジュールにアカウント資源を宣言する\n//モジュールにアカウントを立てるプロシージャを実現する\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "第三章 資源の廃棄",
            instruction: `## 第三章 資源の廃棄\n\n　Move言語にガベージコレクション·メカニズムがないので、資源を使い終わる後、明示的に廃棄されなければならない。\n\n　Moveコードに、普通\`Move()\`を通じて、資源のバインディングを空きに設定し、これによって資源の廃棄を実現する。\n\nこれから簡単な例を見て、これが\`LibraCoin\`を廃棄しているプロシージャだ：\n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n     T { value } = move(coin);\n        return;\n}\n\`\`\`\n\nこのプロシージャに、まず、プロシージャ内部にメンバー変数\`value(u64)\`の局部資源変数\`T\`を宣言し、それから\`move()\`を通じて、廃棄したい\`coin\`を局部資源変数\`T\`に改めてバインディングする。このプロシージャが終わる時に、局部資源変数\`T\`が自動に廃棄され、\`coin\`資源がバインディングしなく、再びアクセスされられない資源になる。システムはバインディングしない資源を回収し、このまま、資源\`coin\`が廃棄される。\n\n### 実戦演習\n\n私たちは\`Castle\`資源と\`CastleAccount\`資源の立てを完成し、それからこれらの廃棄プロシージャを実現する。\n\n1. \`BuildCastle\`モジュールに\`desCastle\`プロシージャを立て、それに課程の例を模倣して、このプロシージャを完成し、このプロシージャのパラメータ名が\`castle\`で、プロシージャの一時変数名は前の課程のものと一致する。\n2. \`CastleAccount\`モジュールに\`desAccount\`プロシージャを立て、それにプロシージャの例を模倣して、このプロシージャを完成する。このプロシージャのパラメータ名が\`account\`で、プロシージャの一時変数名が\`num\`となる。
\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    //在这里实现销毁资源Castle的过程\n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //ここで資源CastleAccountの廃棄を実現するプロシージャ\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "第四章 資源の使用",
            instruction: `## 第四章 資源の使用\n\n資源を作成する後、資源を使える。\n\n資源の使用と構造体はほとんど一緒で、違うところは資源を使い終わる後、この資源を廃棄することである。\n\n本章に、今のトランザクションスクリプトのみに資源を使い、資源をあるアドレスへ送信しない。だから、\`main()\`が終わる前に、資源を廃棄しなければならない。\n\n次、私たちは一つと例と結び付け、資源の使用を理解し、それに資源の作成と廃棄を復習する。
\n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\nこの実例に\`MoneyHolder\`モジュールを宣言し、このモジュールに資源\`T\`があり、この資源はLine 5のプロシージャを通じて作成され、それにLine 8のプロシージャを通じて廃棄される。\n\nご注意、資源Tのメンバー変数が資源である。だから、\`T\`を廃棄する時に、二回廃棄し（即ちLine 10とLine 11）、この中に、二回目の廃棄は\`LibraCoin\`モジュールの\`coin\`の廃棄プロシージャ\`LibraCoin.destroy_zero()\`をコールした。\n\n次、この実例の\`script\`部分を見て、\`main()\`プロシージャの前の2つ桁はそれぞれ２つの資源変数を宣言し、この中に一つが\`LibraCoin.T\`で、もう一つは私たちが宣言した\`MoneyHolder.T\`である。宣言変数の後、私たちは変数を初期化する。だから、初期化されない変数を使えない。\n\nLine 21の\` LibraCoin.zero()\`は\`LibraCoin.T\`という資源の初期化プロシージャで、このプロシージャがリブラ公式の\`LibraCoin\`モジュールに定義され、ここで分析しない。\n\nLine 22の\`MoneyHolder.new(move(coin))\`は定義する資源作成プロシージャで、このプロシージャに\`money_holder\`を初期化する後、この変数を使える。\n\nご注意：ここのパラメータが\`move(coin)\`で、\`copy(coin)\`ではない。後ろの内容に\`coin\`という変数をやはり使いたくても、やはり\`copy()\`を使えない。\`coin\`が資源で、資源を\`move()\`でき、\`copy()\`できない。\n\n本実例に、私たちは\`money_holder\`を操作しない。だから、これからこれを廃棄し、これによってコントラクトを終わる。ご注意、ここのプロシージャのパラメータは同様に\`move()\`を使い、\`copy()\`を使えない。\n\n総体から言えば、使用資源の完全なプロセスは、\`let\`を通じて資源変数を宣言してから、資源を作成するプロシージャをコールし、この変数を初期化し、使い終わる後、資源を廃棄するプロシージャをコールして、変数を廃棄することで、下記の写真となる。\n\n<img src=${require("../static/images/lesson3/pic_3_4_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n### 実戦演習\n\n前の章に、城の建てとプロシージャの廃棄を完成したが、この時にこのコントラクトを順調に成功にコンパイルできない。だから、私たちは\`main()\`に資源の作成と廃棄を完全する。\n\nご注意：一時にアカウント資源は実際の働きがないので、\`main()\`にこれをコールしない。\`CastleAccount\`資源を使いたいと、\`newAccount\`と\`desAccount\`を通じて、これを作成と廃棄する。n\n1. \`main()\`に\`Castle\`資源を廃棄する語句を入れる。\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //ここにコードを入力\n\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 ファイルを分割する",
            instruction: `## 第五章 ファイルを分割する\n\nこの課程を勉強する時に、コードファイルがますます長くなる。これらをいくつかのファイルに分割して、これによって管理を便利し、コードの持続可能性を増加する。\n\nだから、この章に、右のコードをクリアし、今エディタのトップにタブが現れ、ラベルをクリックしてファイルを切り換えることができる。\n\nタブは活動タブと固定タブに分け、この中に活動タブを編集でき、これも実戦演習に修正し検査できるファイルで、固定タブが読み取り専用で、勉強している過程に調べることができるが、これを修正できない。\n\n普通、私たちは一つのモジュールを一つのファイルに入れてから、使いたいところで\`import アドレス.モジュール名\`という方法でこのモジュールをインポートし、これは第一課程の第二章に紹介した内容である。このまま、異なるモジュールの機能をメンテナンス、管理と更新できる。\n\n### 実戦演習\n\nマルチファイルの構成を立て、それにモジュールの分割を完成し、次、前完成したトランザクションスクリプトをファイルに入れる。\n\n1.作ったモジュールにブラウズし、それに今のアクティブタブにトランザクションスクリプトの内容を完成する。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//ここにコードを入力",
                    answer:"import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code:"module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code:"module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code:"module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lessons = [lesson1, lesson2, lesson3];

export default lessons;


