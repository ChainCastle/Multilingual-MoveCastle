import React from 'react';
import L1c1 from '../L1C1/L1C1'
import L6c1 from '../L6C1/L6C1'



const lesson1 = {
    info : {
        name: "移动城堡",
        subname: ["Libra Move的游戏化课程", "*基于Libra move Commit 61649eb"],
        intro: "在现有的区块链系统中，比特币对“货币”进行编程，以太坊对“应用”进行编程，与之相比，Libra对“资产”进行编程。\n\n在Libra 中我们可以定义一些比货币更复杂的资产类型，这种资产被称为 “资源”。Libra利用Move语言限制对资源的操作来防止不恰当的修改，从而提高资产的安全性。\n\nMove为 Libra 区块链提供安全、可编程的基础，该语言针对“资产”进行编程的方式，和对安全性的严格限制，使其十分适合用于发行数字货币、处理区块链交易以及验证器管理。\n\n在本课程中，我们使用Move语言来搭建一个城堡并实现城堡扩张和对战等功能，以帮助初学者更快速地学习这门语言。",
        goback: "←目录",
        editor: "编辑器",
        lesson: "教程",
        copyAnswer: "复制答案",
        learnmore: "了解更多",
        start: "开始学习",
        indexpage:"https://www.learnlibramove.com/index-cn.html",
        learninide:["本课程代码能够在ChainIDE中编译通过","前往ChainIDE"],
        practice: "现在开始",
    },
    local:{
        hint: "提示",
        previous: "上一章",
        next: "下一章",
        catalog: "目录",
        checkcode: "检查代码",
        showAnswer: "显示答案",
        hideAnswer: "隐藏答案",
        contitle: ["恭喜完成本章~", "恭喜完成本课~", "精彩还在继续"],
        concontent: ["点击“继续前进”，迎接新的挑战吧！", "本课到此结束，点击“返回”回到目录页！点击“下一课”继续学习关于Libra的新知识！", "Hi~恭喜你已经完成目前课程的所有内容了~更多课程将不久之后为大家呈现。现在，让我们前往ChainIDE编写自己的Libra Move合约吧！"],
        concontinue: ["继续前进", "返回", "前往ChainIDE", "下一课"],
        shut: "关闭窗口",
        target: "课程简介",
        keypoint: "知识点",
        detail: "查看详情"
    },
    lessonserial: "第1课",
    title: "",
    intro: ["在课程1中，我们将引导你为自己的城堡奠基，你的城堡具有专属的独一无二的外观以及你意想不到的生物居住在里面。", "如何建立一个合约;Move中的模块;Move中的main();变量及数据类型;Move中的过程"],
    key: 1,
    total: 5,
    chapters: [
        {
            title: "第一章 概述",
            instruction: `## 第一章 概述\n\n在第一课中我们将学习如何建立一个城堡。\n\n- 我们将通过模块来建立新的城堡\n- 我们的城堡会被保存在数据库（Libra区块链）中\n\n在之后的章节中，我们城堡的功能会逐渐增加，比如增强自身的实力、与其他玩家的城堡发生战争等，但在此之前，我们首先需要实现建立城堡的功能。 \n\n### 城堡有哪些属性？\n\n每个城堡具有名字、序列号、等级、经济实力与军事实力。其中，序列号决定城堡的外观和城堡中的生物种族，等级决定了城堡的价值，经济实力与军事实力会影响城堡在与其他城堡进行交互时的表现。\n\n### 序列号如何影响城堡？\n\n城堡的外观和种族由序列号决定，序列号是一个8位整数，比如：83451029。\n\n序列号的每一位对应着城堡的一个属性，具体如下：\n\n|  1   |  2   |  3   |    4     |    5     |    6     |  7   |    8     |\n| :--: | :--: | :--: | :------: | :------: | :------: | :--: | :------: |\n| 大小 | 样式 | 颜色 | 徽标样式 | 徽标颜色 | 徽标位置 | 种族 | 特殊标识 |\n\n出于游戏趣味性的考虑，我们将序列号设定为根据建立城堡时的区块深度随机产生，而不是由用户自主决定，当然这并不意味着城堡的外观是不确定的，因为在建立城堡的同时序列号就是一个固定值了。每个新建立的城堡的名字由用户输入，等级初始值为1级，初始经济实力和军事实力由序列号中的种族位决定，其对应关系如下：\n\n|  种族位  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| 经济实力 |  6   |  8   |  3   |  7   |  4   |\n| 军事实力 |  6   |  3   |  8   |  4   |  7   |\n\n### 实战演习\n\n1. 请拖动页面右侧的滑块，探索不同序列号对应的城堡外观。\n\n\n **了解了这些基础内容后，点击下一章，继续学习Move语言**。\n\n`,
            type: 1, 
            show(){
                return <L1c1 lang="0"/>
            }
        },
        {
            title: "第二章 合约与模块",
            instruction: `## 第二章 合约中的模块\n\n合约是在区块链上运行的计算机程序，我们通过运行合约从而在区块链上完成一系列操作，比如转账、购买商品等。\n\nMove合约整体的代码被分为两部分：\n\n- 由\`modules:\`开头的模块部分\n- 由\`script:\`开头的\`main()\`\n\n我们将在本章介绍\`modules\`部分，在下一章介绍\`script\`部分。\n\n### 模块\n\n模块部分包含了整个合约所需要用到的模块（\`Module\`），模块是Move合约的基本封装单元，所有部署在 Libra 上的模块都是全局的。\n\n模块中可以定义 结构体(\`Struct\`)、资源(\`Resource\`)和 过程(\`Procedure\`），这些概念我们将在后续章节中进行介绍。\n\n模块类似于以太坊中的智能合约，也类似于Java语言中的类。我们可以把模块看成一个整体具有一定功能的代码块，通过使用接口来访问模块的内部信息。\n\n例如，\`LibraCoin\`模块是Libra官方发布的Libra币模块。该模块中有对Libra币的定义和实现Libra币的转账、充值等操作的过程。开发人员在引入该模块后，就可以通过接口来实现相关功能。\n\n#### 如何建立模块\n\n我们通过\`module 模块名 { }\`的方式来建立一个模块。\n\n#### 如何引用模块\n\n类似于Java中“包名 + 类名”的引用方式，Move通过“地址+模块名”的方式来引用\`import\`一个模块，例如:\n\n\`import 0x0.LibraCoin\`\n\n这里的\`LibraCoin\`是模块名，\`0x0\`是发布该模块的账户地址。每个用户都可以在区块链上发布自己的模块，也可以通过这种方式引用他人发布的模块。所有Libra官方发布的模块地址都是\`0x0\`。\n\n导入同一个文件中的模块时，可以直接使用\`import Transaction.模块名\`，例如\n\n\`import Transaction.LibraCoin\`\n\n### 实战演习\n\n为了建立我们的城堡，我们要先建立一个名为\`BuildCastle\`的模块，我们将在该模块中逐渐实现建立城堡的一系列功能。\n\n1. 建立一个空模块\`BuildCastle\`\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//在这里输入代码",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "第三章 合约中的main()",
            instruction: `## 第三章 合约中的\`main()\`\n\n上一章中我们学会了如何建立一个模块，接下来我们要在这个模块的基础上，完善合约的内容。\n\n我们可以在合约中嵌入一段一次性执行的代码，这段代码被称为交易脚本（Transaction Script），并且不能被其他代码调用。交易脚本由\`script:\`作为开始的标识符。\n\n\`main()\`是执行交易脚本的入口。我们将类似\`main()\`形式的代码块称为“过程”，并将在后续章节中详细介绍过程的概念，\`main()\`是一种特殊的过程，它只会被调用一次，且无法被其他过程调用。\n\n注意，包括\`main()\`在内的每个过程都必须以\`return\`结尾，Move编译器非常字面化：它直接翻译源代码，而不会做一些其他的事情，比如插入丢失的\`return\`'。\n\n在编写Move合约的时候，我们通常将所有操作写在普通过程（指除了\`main()\`以外的过程）中，而将普通过程放入模块中，最后在\`script\`部分中导入模块，并以\`main()\`为入口，调用模块中的过程来完成一系列操作，整体思路如下图所示。\n\n<img src=${require("../../static/images/lesson1/pic_1_2_1_zh.png")} style="width:80%;position:relative;left:10%">\n\n\n\n注意，当我们需要在模块中导入其他模块时，导入语句需要出现在模块内部的第一行，也就是\`module 模块名\`的下一行。而当我们需要在\`script\`部分中导入模块时，导入语句出现在\`script\`部分的第一行，也就是\`script: \`的下一行，\`main()\`的前一行。\n\n综上所述，下面就是一个最基本的空合约： \n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### 实战演习\n\n在已经建立好的\`BuildCastle\`模块基础上，建立一个空合约。\n\n1. 首先添加\`modules: \`和 \`script: \`；\n2. 在\`script\`的下一行添加\`main()\`，记得在\`main()\`中添加\`return\`语句；\n3. 在\`script\`部分中通过\`import\`导入模块（在\`main()\`的前一行）。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//在这里输入代码\nmodule BuildCastle {\n\n}\n//在这里输入代码\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: "第四章 变量绑定与数据类型",
            instruction: `## 第四章 变量绑定与数据类型\n\n### **变量绑定**\n\n变量绑定是指将一些值绑定到一个变量上，这样可以在之后使用他们。\n\n与Rust语言类似，Move语言通过let关键字来绑定变量，形式如下：\`let 变量名: 变量类型;\`  例如：\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\n在绑定变量之后就可以进行初始化了，可以直接使用等号\`=\`来初始化，例如：\n\n\`\`\`\nx = 5;\n\`\`\`\n\n需要注意的是，所有过程中的变量绑定都需要在最开始进行，也就是说，所有的\`let\`语句都需要放到最前面，在代码块中间加入\`let\`语句会导致编译失败。\n\n### 数据类型\n\n目前，Move语言支持以下数据类型：\n\n- 布尔（\`boolean\`）\n- 64位无符号整数（\`uint64\`）\n- 地址（\`address\`）\n- 字节数组（\`bytes\`）\n- 结构体（\`struct\`）\n- 资源（\`resource\`），这是Move语言特有的类型\n\n其中，\`boolean\`类型使用\`bool\`关键字，\`uint64\`类型使用\`u64\`关键字，\`address\`类型使用\`address\`关键字，\`bytes\`使用\`bytearray\`关键字。我们可以通过如下的方式声明不同类型的变量：\n\n\`\`\`\nmain() {\n    //变量绑定 \n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //变量初始化\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h "123abc";\n    return;\n}\n\`\`\`\n\n也可以声明资源和结构体：\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\n其中，\`f1\`和\`f2\`是变量名。\n\n 需要注意的是，因为Move指令不会自动初始化，所以我们无法使用未经初始化的变量。\n\n### 实战演习\n\n我们的城堡序列号将由一个8位数字组成，因此我们要通过模运算\`%\`来将随机生成的序列号限制为8位整数。在此之前，我们首先需要一个名为\` SerialDigits\` 的变量，用它表示序列号位数，这是本章的任务。\n\n在\`main()\`过程中定义 \`SerialDigits\` 为 u64 数据类型, 并赋值为 8。 \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //在这里输入代码\n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 过程",
            instruction: `## 第五章 过程\n\n如第二章所说，在模块中我们可以定义过程，过程类似于其他语言中的函数。\n\n### 过程的声明\n\n在声明一个过程的时候，我们需要声明其可见性、名称、参数和返回值，格式如下：\n\n\`可见性 过程名( 参数名 ) : 返回值类型\`\n\n需要注意的是：在过程没有参数的情况下，不需要声明参数名；在没有返回值的情况下，不需要声明返回类型。\n\n模块中的过程有两种可见性：\n\n- 公有（public）：公有过程可以被其他模块调用\n- 私有（private）：私有过程只能被同模块的过程调用。模块中的资源都是私有的，只有通过公有过程才能被其他模块访问\n\n当要声明的过程既没有参数也没有返回值时，我们使用如下的方式声明：\n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\n当要声明的过程有参数时，则改写为如下形式：\n\n\`\`\`\npublic Procedure(a: u64, b: u64) { //参数是其他类型或者有更多（更少）参数时，形式是类似的\n    return;\n}\n\n\`\`\`\n\n需要注意的是，过程本身也可以作为参数传入其他过程。\n\n如果要声明的过程有返回值，则改写为如下形式：\n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 { //返回值是其他类型时，形式是类似的\n    return 1;\n}\n\n\`\`\`\n\n在以上的例子中，我们定义的都是公有过程（public），如果要声明私有过程，可以直接去掉\`public\`。\n\n### 过程的调用\n\n过程通过 \`模块名.过程名\` 的方式调用，如果调用同模块的过程，则通过 \`Self.过程名\` 来调用。\n\n如下就是一个声明并调用过程的例子：\n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //声明了一个公有过程，过程名是Procedure\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //调用过程，其中Contract是模块名\n    return;\n}\n\n\`\`\`\n\n### 实战演习\n\n在前面的章节中，我们提到要通过模运算\`%\`来将序列号转为8位整数，具体来说，一个数字模10<sup>n</sup>得到的结果就是n位整数，因此在这里我们要通过过程来计算10<sup>8</sup>。\n\n1. 在\`BuildCastle\`模块的上面建立一个数学运算的模块\`Math\`，它将包括本课程中所有的数学运算过程。\n2. 在新建的模块中声明幂运算的过程\`pow()\`，具体如下：\n   - 参数：类型为u64的底数 x 和指数 n\n   - 返回值：类型为u64的幂运算结果\n   - 过程内容：暂时是空的，为了编译通过，我们暂且让它的返回值是1。我们将在下一章来实现它的功能。\n3. 在\`main()\`前导入数学运算模块\`Math\`，并在\`SerialDigits\`后面声明一个名为\`SerialLimit\`的\`u64\`变量，它代表序列号的位数限制。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \n//在这里输入代码\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//在这里输入代码\n\nmain() {\n    let SerialDigits: u64;\n    //在这里输入代码\n\n    SerialDigits = 8;\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },    
    ]
};

const lesson2 = {
    lessonserial: "第2课",
    title: "",
    intro: ["在课程1中，我们学习了变量相关的操作，并成功声明了城堡的序列号，为城堡的建立奠定第一块基石。在课程2中，我们将引导你搭建城堡的框架，亲手打造自己的城堡世界。","所有权;Move中的程序结构;结构体的建立和使用;Move中的常用运算符;Move中的多返回值过程"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "第一章 所有权",
            instruction: `## 第一章 所有权\n\n### 所有权的使用\n\n在前面的内容中，我们提到了“绑定”这个词，实际上，绑定是指所有权的绑定，只有在某标识符拥有某值的所有权时，我们才可以通过该标识符来访问该值。\n\n当我们将一个值绑定到某个名字（标识符）时，是将该值（资源）的所有权绑定到这个标识符。例如：\n\n\`\`\`\nlet x: u64;\nx = 3;\n\n\`\`\`\n\n当我们通过\`let\`关键字将标识符\`x\`和类型为\`u64\`、值为3的资源绑定后，\`x\`就拥有了对3的所有权。在绑定期间，该标识符独享该资源的所有权，可以访问、更改该值，但是一旦将绑定转移给其他标识符后，该标识符不再拥有对该值的所有权。\n\n### 所有权的转移\n\n当我们希望转移所有权时，出于内存安全的设计，我们必须使用\`move()\`来进行所有权的转移，而不能直接用\`=\`。\n\n也就是说，在Move语言中，标识符之间不能使用\`=\`连接，只有标识符和值可以使用\`=\`连接。例如以下代码就是错误的示例：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //error\n\n\`\`\`\n\n接下来，我们通过具体的代码来说明所有权的转移：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); //将3的所有权从标识符x转移(move)给标识符y\nz = move(x); //error: 此时标识符x已经失去所有权，成为一个未经初始化的变量，因此move(x)失败\nz = move(y); //将3的所有权从标识符y转移(move)给标识符z\nx = 3; 	//重新初始化标识符x\nz = move(x); //此时可以通过move将3的所有权从标识符x转移给标识符z\n\n\`\`\`\n\n### 所有权的复制\n\n在一些情况下，我们希望可以在不转移所有权的情况下，让一个标识符的值等于另一个标识符的值，这个时候就需要使用过程\`copy()\`，一个标识符经过\`copy\`后，依旧可以继续被访问。例如：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); //将3的所有权从标识符x复制（copy）给标识符y\nz = move(x); //将3的所有权从标识符x转移（move）给标识符z\n\n\`\`\`\n\n需要注意的是，当我们调用过程并传入参数的时候，不能直接使用参数名，而需要使用\`move(参数名)\`或\`copy(参数名)\`的方式，将所有权传入过程，要根据参数在代码前后的使用情况来决定使用\`move\`还是\`copy\`。\n\n### 实战演习\n\n在上一课中我们已经声明了\`SerialLimit\`，本章中我们希望\`SerialLimit\`的值等于10<sup>SerialDigits</sup>。为此，我们需要调用\`pow()\`过程来初始化\`SerialLimit\`，该过程的参数分别是10和\`SerialDigits\`。\n\n上述任务需要将一个变量作为参数传递到\`pow()\`过程中，因此涉及到了所有权的转移，而\`SerialDigits\`在之后的内容中也许还会再次使用，因此要使用\`copy()\`。此时\`pow()\`过程还是空的，我们将在下一章实现它。\n\n在\`main()\`中通过调用\`pow()\`过程初始化\`SerialLimit\`，调用过程的方式为\`模块名.过程名\`，是在上一章中介绍的，如果发现自己遗忘了，可以复习一下。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //在这里输入代码\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第二章 程序结构",
            instruction: `## 第二章 程序结构\n\n与其他语言类似，在Move语言中也有常用的程序结构，比如选择和循环。\n\n我们可以通过\`if-else\`语句来实现简单的选择结构，具体规则如下：\n\n1. 分支语句必须由双大括号\`{}\`包括起来，即便只有一句也需要，如下的例子就是错误的：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;	//这里 x = 3 需要有大括号\n       return;\n   }\n   \`\`\`\n\n2. 分支语句的分号\`;\`在每句结束后面加，不需要在大括号后面加分号，如下的例子也是错误的：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;\n       else {\n           x = 5\n       };	//这里的分号应该出现在上一行结尾\n       return;\n   }\n   \`\`\`\n\n3. 如果一个标识符的初始化是在分支语句中进行，那么当分支语句并不包含所有情况时，分支结束后该标识符无法被访问，如下的例子是错误的：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       }	//这里仅在if分支中对变量x进行了初始化，而在else分支对应的情况下，中变量x是未经初始化的，因此我们无法在后面使用copy来访问x\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n   而如果分支包含了所有情况，则分支结束后可以访问该标识符，如下的例子是正确的：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } else {\n           x = 43;\n       }	//这里的两个分支包含了true和false，也就是说无论什么情况，变量x都将被初始化，因此我们可以在后面使用copy\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n4. 在分支语句中使用\`move()\`时，一定要注意所有权问题，在分支中被\`move()\`的标识符，在分支结束后不应该再次被访问，如下的例子是错误的：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       let y: u64;\n       x = 0;\n       if (true) {\n           y = move(x);	//在该分支中我们将变量x的所有权转移给变量y，因此在后面的代码中，我们不能再次通过copy(x)来访问变量x\n       }\n       assert(copy(x) == 0, 42);\n       return;\n   }\n   \`\`\`\n\n我们也可以通过\`loop\`实现循环结构，由于篇幅原因，本章不进行详细介绍，我们将在后续的章节中介绍。\n\n### 实战演习\n\n幂函数最常见的实现方式是递归，如下是一个C语言中的幂函数实例：\n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\n\`\`\`\n\n请模仿以上程序，在\`Math\`模块中实现\`pow()\`的具体内容，注意变量的所有权问题，并恰当地使用\`copy\`和\`move\`。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //在这里输入代码\n        \n        return 1; //删去这句return\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第三章 结构体",
            instruction: `## 第三章 结构体\n\nMove语言中的结构体与其他语言的类似，是由一系列具有相同类型或不同类型的数据构成的数据集合。通过\`struct 结构体名{数据1: 类型, 数据2: 类型, ...}\`的方式声明，例如：\n\n\`\`\`\nmodule Test {\n	//空结构体\n  	struct Empty1 { }\n  	//有两个成员的结构体\n  	struct T { a: u64, b: u64, }\n}\n\n\`\`\`\n\n注意：\n\n- 结构体只能在模块的最前面进行声明，而不能在过程中声明\n- 结构体也可以被\`copy\`或者\`move\`\n\n关于结构体的更多使用，我们将在后续章节使用到时再介绍。\n\n### 实战演习\n\n在\`BuildCastle\`模块中声明结构体\`Castle\`，它包含5个成员：\`name(bytearray)\`, \`SerialNum(u64)\`, \`level(u64)\`, \`economic(u64) \`和\`military(u64)\`。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//在这里输入代码\n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第四章 运算操作",
            instruction: `## 第四章 运算操作\n\n在前面章节中，我们已经用到了一些基础运算，例如加法、乘法等，这一章中我们将具体了解Move已经实现了的几种运算操作。\n\nMove语言目前实现了如下几种数学运算：加 \`+\`  减 \`-\` 乘\`*\`除\`/\`模\`%\`，具体使用实例如下：\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\n\`\`\`\n\n还实现了比较运算：大于\`>\`、小于\`<\`、等于\`==\`、大于等于\`>=\`、小于等于\`<=\`、不等于\`!=\` ，具体实例如下：\n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\n\`\`\`\n\n此外，Move还实现了几种位运算和布尔运算等，由于篇幅原因，本章不进行详细介绍，我们将在后续的章节中介绍。\n\n### 实战演习\n\n我们希望根据当前区块的深度来生成随机的城堡序列号。\n\n最基础的随机数生成算法是通过模运算来实现的。\n\n如下是C语言中实现简单伪随机数的代码示例，很显然，这样的程序得到的随机数序列取决于\`next\`初始值的选择。\n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\n\`\`\`\n\n在这段程序的基础上，我们稍作修改，即可得到如下根据种子\`seed\`生成一个随机数的程序：\n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\n\`\`\`\n\n我们可以用与其他语言完全相同的方式，通过模运算让这段代码最终生成指定范围内的随机数。具体来说，想要生成从\`m\`到\`n\`的随机数，可以使用以下代码：\n\n\`\`\`c\nmyrand(seed) % (n - m + 1) + m;\n\n\`\`\`\n\n1. 请仿照上述的随机数生成程序，在\`Math\`模块中添加生成随机数的过程\`myrand()\`，并实现其具体功能。\n2. 请在\`BulidCastle\`模块中添加并实现公有过程\`generateSerial()\`，该过程根据区块深度调用\`Math\`模块的\`myrand\`过程来生成随机的8位序列号（即生成10<sup>7</sup>到10<sup>8</sup>-1之间的随机数），参数是序列号位数限制\`SerialLimit\`，返回值是\`u64\`。\n   - 区块深度可通过\`Block\` 模块中的 \`get_current_height()\` 方法获取。\n   - \`Block\`模块的地址是\`0x0\`。\n   - 请在正确的地方导入\`Math\`模块和\`Block\`模块。\n3. 在\`main()\`中声明\`SerialNum\` 并通过\`generateSerial()\`过程初始化。\n\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //在这里输入代码\n    \n}\nmodule BuildCastle {\n    //在这里输入代码\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //在这里输入代码\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //在这里输入代码\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //在这里输入代码\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 多返回值过程",
            instruction: `## 第五章 多返回值过程\n\n第五章中我们介绍了过程，并通过实例说明了有返回值的过程应该如何使用。但是，在很多场景中，我们往往希望一个过程可以有多个返回值，本章中，我们将介绍如何编写多返回值的过程。\n\n根据第五章可知，单返回值的过程可以这样声明：\n\n\`\`\`\npublic 过程名(参数名1，参数名2，...) : 返回值类型 {...}\n\n\`\`\`\n\n类似地，我们以两个返回值的过程为例，多返回值的过程声明方式为：\n\n\`\`\`\npublic 过程名(参数名1，参数名2，...) : 返回值类型 * 返回值类型 {...}\n\n\`\`\`\n\n调用方式为：\n\n\`\`\`\n变量1, 变量2, ...  = 模块名.过程名( 参数1, 参数2, ...)\n\n\`\`\`\n\n在使用多返回值过程的时候，有以下几点需要注意：\n\n1. 当多返回值过程与单返回值过程进行运算时，实际发生运算的只有多返回值过程的最后一个返回值与单返回值过程的返回值。\n\n   比如在下面的例子中，Line 2有一个多返回值过程，在Line 18调用它的时候，前两个返回值均为该过程运算后的结果，而第三个返回值则需要再与过程\`bar()\`进行运算。\n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\n\`\`\`\n\n2. 一个多返回值过程可以直接作为另一个多参数过程的参数。\n\n   例如在下面的代码中，Line 2中有两个返回值的过程直接成为了Line 23中有三个参数的过程的前两个参数。\n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\n\`\`\`\n\n3. 如果一个多返回值过程的返回语句是出现在分支语句中，那么一定要检查每个分支的返回值类型和数量是否统一。\n\n   比如在下面的代码中，\`bar()\`过程的返回值出现在Line 6 ~ Line 10，两个return语句的返回值均为u64，与过程声明的返回类型一致。\n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\n\`\`\`\n\n### 实战演习\n\n在\`BuildCastle\`模块中添加\`racial_judgment()\`过程，并实现其功能：根据序列号判断城堡所对应的种族，返回对应的初始经济实力与军事实力。\n\n1. 通过模运算和除法运算从序列号中截取出种族位（序列号的第7位）；\n2. 通过分支语句判断种族位所对应的经济实力与军事实力数值，种族位与实力值的对照关系如下表：\n\n|  种族位  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| 经济实力 |  6   |  8   |  3   |  7   |  4   |\n| 军事实力 |  6   |  3   |  8   |  4   |  7   |\n\n3. 该过程有两个\`u64\`返回值，一个是经济实力值，一个是军事实力值。\n\n提示：\n\n如何从n位数中截取第m位？\n\n- n位数Num，如果要取前x位，可通过取整除法Num / 10<sup>x</sup>，该运算得到的结果就是前x位所对应的数字，例如，54312 / 10<sup>5-2</sup>=54；\n- n位数Num，如果要取末x位，可通过模运算Num % 10<sup>n-x</sup>，该运算得到的余数就是末x位所对应的数字，例如，54312 % 10<sup>2</sup>=12；\n- n位数Num，如果要取中间x位，则先通过上述运算将问题转变为取前x位或取后x位，再进一步计算。\n\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //在这里输入代码\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "第六章 完善城堡设计",
            instruction: `## 第六章 完善城堡设计\n\n在第三章中我们学习了如何声明一个结构体，本章中我们将继续学习如何初始化一个结构体，并在\`main()\`过程中使用它。\n\n如下图所示，我们往往通过构造一个过程来实现结构体的初始化，并将结构体的声明与初始化过程写入同一个模块中，用于初始化结构体的过程所对应的返回值类型是结构体类型，并通过返回一个成员变量为初始值的结构体来实现结构体的初始化。\n\n<img src=${require("../../static/images/lesson2/pic_2_6_1_zh.png")} style="width:80%;position:relative;left:10%">\n\n例如：\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\n\`\`\`\n\n在这个例子中，我们在模块\`Bar\`中声明了一个结构体\`T\`，并通过名为\`new\`的过程将结构体的成员变量初始化为该过程的参数。\n\n在\`new\`过程中，我们返回了一个结构体\`T\`，其成员变量\`baz\`的值是该过程的参数\`m\`。\n\n注意，上述代码中Line 6 ~ Line 8形式上很像结构体的定义，但它是一个\`return\`语句，因此句末有一个分号。\n\n当我们要在\`main()\`过程或其他过程中使用结构体\`T\`时，可以通过\`let\`关键字将变量声明为结构体类型，并调用\`new\`过程进行初始化。\n\n例如：以下代码将变量\`x\`初始化为成员变量值等于10的结构体\`T\`：\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\n\`\`\`\n\n### 实战演习\n\n在之前的章节中，我们学习了**如何建立一个合约**，**Move中的模块**、**变量与数据类型及其所有权**，**Move中的过程及多返回值过程**，**Move中的程序结构**，**结构体的建立和使用**，**Move中的常用运算符** 等知识点，现在我们已经完成了建立城堡所需要的几个重要过程，接下来要把它们组合起来，并在\`main()\`过程中实现城堡的建立。\n\n1. 在\`BuildCastle\`模块中添加\`newCastle\`过程，用于初始化一个结构体\`Castle\`类型的变量，该过程有两个参数：\n\n   - \`_name (bytearray)\`：城堡名\n   - \`_SerialNum (u64)\`：城堡序列号\n\n   注意：为了与\`main()\`中的\`name\`和\`SerialNum\`有所区分，我们在参数名的前面加了下划线。\n\n   该过程有一个返回值，类型为\`Self.Castle\`。\n\n   请模仿课程中的示例，在该过程中根据上述参数（\`_name\`, \`_SerialNum\`）完成一个城堡数据的初始化。\n\n   提示：城堡的名字和序列号初始化为参数对应的值，城堡的等级初始化为1，城堡的经济实力和军事实力初始化为调用\`racial_judgment()\`过程所计算出的值。\n\n2. 在\`main()\`过程中，城堡的名字是由用户输入的，因此\`name\`这一参数是外部输入，我们需要给\`main()\`过程添加一个名为\`name\`的参数，其类型为\`bytearray\`。\n\n3. 在\`main()\`中添加\`castle\`变量并初始化，提醒：要记得把\`let\`语句插入到前面。\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //在这里输入代码\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n//修改这里\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //在这里输入代码\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //在这里输入代码\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial: "第3课",
    title: "",
    intro: ["在之前的课程中，我们已经建立了一个基础的城堡架构。在接下来的第三课中，我们将为城堡添砖加瓦，让它看起来更安全一些。","资源的概念;如何建立和销毁资源;如何建立一个多文件结构"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "第一章 资源",
            instruction: `## 第一章 资源 \n\n在现有的区块链系统中，比特币对\"货币\"进行编程，以太坊对\"应用\"进行编程，与之相比，Libra对\"资产\"进行编程，这种资产被称为 “资源”，是一种比货币更复杂的资产类型。\n\nMove规定，对资源的操作必须满足以下两个约束条件：\n\n- **稀缺性**：资源总量必须受控，不允许用户随意复制、重用或丢弃资源。\n- **权限控制**：对资源的操作必须满足某种预先定义的规则。\n\n为满足上述两个约束条件，在Move合约中，资源只能由定义该资源的模块创建或销毁，且只能接受\`move()\`操作，换句话说，我们不能用\`copy()\`复制资源。\n\nMove编译器通过字节码静态验证上述安全性约束是否被满足，它将拒绝运行未通过字节码验证的程序代码。\n\n对于初学者而言，可以暂且将资源理解为受限制的结构体。\n\n资源的声明与结构体类似，是通过\`resource 资源名{数据1: 类型, 数据2: 类型, ...}\`的方式声明。\n\n下面是对Libra币这一资源的声明示例：\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### 实战演习\n\n出于安全性的考虑，我们需要将城堡这一结构体修改为资源。\n\n1. 请将\`Castle\`的类型从结构体改为资源。`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//修改这里的struct\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "第二章 资源的建立",
            instruction: `## 第二章 资源的建立\n\n为了使用资源，我们首先需要实现建立资源的过程，该过程的返回值类型为资源类型。\n\n例如，下面的代码就是上一课提到的\`LibraCoin\`的建立过程，该过程创建了一个值为0的资源变量\`T\`。\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\n可以看出，资源的建立与结构体的初始化十分相似。\n\n### 实战演习\n\n接下来我们要实现建立资源的过程。\n\n本章中，我们将引入账户的概念，每个玩家都拥有一个账户，该账户有其对应的城堡，我们希望通过账户将城堡与玩家关联起来。\n\n我们将在之后的课程中介绍关于账户的具体功能及操作，本章暂时只建立和账户相关的模块与资源。\n\n1. 在\`BuildCastle\`模块下面建立名为\`CastleAccount\`的模块。\n\n2. 在新建的模块中声明\`CastleAccount\`资源，出于练习的目的，该资源暂时只有一个\`u64\`变量，变量名为\`a\`，我们会在以后要用到它的时候重新完善该资源。\n\n3. 实现建立\`CastleAccount\`资源的过程\`newAccount\`，该过程将资源中的变量\`a\`初始化为0。`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//在这里建立新模块\n//在模块中声明账户资源\n//在模块中实现建立账户的过程\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "第三章 资源的销毁",
            instruction: `## 第三章 资源的销毁\n\n因为Move语言中没有垃圾回收机制，我们在智能合约中声明和创建的资源，其生命周期会随着合约的结束而结束。因此，我们所创建的资源必须在创建它的模块内通过解包的方式销毁。\n\n当我们希望某个资源永久地存在于区块链系统中时，我们需要将它发布到全局存储中，与区块链中的某个地址建立联系。\n\n本课中，我们先介绍销毁资源的方式，关于资源的发布将在后续内容中介绍。\n\n具体来说，我们可以通过 \`资源名 { 成员变量 } = move ( 待销毁资源 )\` 的方式来解包销毁一个资源。\n\n让我们来看一个简单的例子，这是\`LibraCoin\`的销毁过程：\n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n        T { value } = move(coin);\n        return;\n}\n\`\`\`\n\n在该过程中，我们首先在过程内部声明一个成员变量为\`value(u64)\`的局部资源变量\`T\`，接下来将我们要销毁的\`coin\`通过\`move()\`重新绑定到局部资源变量\`T\`。当过程结束时，局部资源变量\`T\`被自动销毁，而\`coin\`资源变成了没有绑定、也无法再被访问使用的资源。由于系统会将没有绑定的资源回收，这样资源\`coin\`就被销毁了。\n\n### 实战演习\n\n我们已经完成了\`Castle\`资源和\`CastleAccount\`资源的建立，接下来要实现它们的销毁过程。\n\n1. 在\`BuildCastle\`模块中建立\`desCastle\`过程，并仿照课程中的示例完成该过程，该过程的参数名为\`castle\`，过程中的临时变量名与之前的课程中所使用的保持一致。\n2. 在\`CastleAccount\`模块中建立\`desAccount\`过程，并仿照课程中的示例完成该过程，该过程的参数名为\`account\`，过程中的临时变量名为\`num\`。`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    //在这里实现销毁资源Castle的过程\n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //在这里实现销毁资源CastleAccount的过程\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "第四章 资源的使用",
            instruction: `## 第四章 资源的使用\n\n在建立了资源之后，我们就可以使用资源啦。\n\n资源的使用与结构体几乎一样，不同的地方在于，我们需要在使用完资源后，销毁该资源。\n\n在本章中，我们假设仅在当前交易脚本中使用资源，暂时不把资源发送给某个地址，因此在\`main()\`结束前需要销毁资源。\n\n接下来，我们结合一个例子来理解资源的使用，并复习资源的建立与销毁。\n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\n在该实例中，我们声明了一个\`MoneyHolder\`模块，该模块中有一个资源\`T\`，该资源通过Line 5的过程建立，并通过Line 8的过程销毁。\n\n需要注意的是，资源T的成员变量也是一个资源。因此，在销毁\`T\`的时候，需要进行两次销毁（即Line 10和Line 11），其中，第二次销毁是调用了\`LibraCoin\`模块中销毁\`coin\`的过程\`LibraCoin.destroy_zero()\`。这些内容是前两章中所涉及的知识点，如果有所遗忘请及时复习。\n\n接下来，我们看该实例的\`script\`部分，\`main()\`过程中的前两行分别声明了两个资源变量，其中一个是\`LibraCoin.T\`，另一个是我们自己声明的\`MoneyHolder.T\`。在声明变量之后，我们随之要进行变量的初始化，因为未经初始化的变量无法被使用。\n\nLine 21中的\` LibraCoin.zero()\`是\`LibraCoin.T\`这一资源的初始化过程，该过程被定义在Libra官方的\`LibraCoin\`模块中，在此不进行分析。\n\nLine 22中的\`MoneyHolder.new(move(coin))\`是我们定义的建立资源过程，在通过该过程初始化\`money_holder\`后，就可以使用该变量啦。\n\n注意：这里的参数是\`move(coin)\`，而不是\`copy(coin)\`，即便在后面的内容中仍然想使用\`coin\`这一变量，我们依旧不能使用\`copy()\`，因为\`coin\`是资源，而资源只能\`move()\`，不能\`copy()\`。\n\n在本实例中，我们不对\`money_holder\`进行操作，因此接下来就需要销毁它，从而结束合约。注意，这里过程中的参数同样是要使用\`move()\`，而不能使用\`copy()\`。\n\n总体来说，使用资源的完整流程，是先通过\`let\`声明资源变量，再调用建立资源的过程初始化该变量，使用完以后调用销毁资源的过程来销毁变量，如下图所示。\n\n### 实战演习\n\n在前面的章节中，我们已经完成了城堡的建立和销毁过程，但此时该合约仍然无法顺利编译成功的，因为我们还需要在\`main()\`中完善资源的建立和销毁。\n\n注：由于账户资源暂时没有实际作用，我们先不在\`main()\`中调用它。如果需要使用\`CastleAccount\`资源，我们可以通过\`newAccount\`和\`desAccount\`来创建和销毁它。\n\n1. 在\`main()\`中加入销毁\`Castle\`资源的语句。`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //在这里输入代码\n\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 拆分文件",
            instruction: `## 第五章 拆分文件\n\n学到这一课时，相信你已经注意到我们的代码文件越来越长，我们希望把它分成多个文件以便于管理，增加代码的可读性。\n\n因此在这一章，我们清理了下右边的代码，现在你可以看到，编辑器的顶部多了几个选项卡，可以尝试单击标签来切换文件。\n\n可以看到，选项卡分为活动选项卡和固定选项卡，其中活动选项卡是可以编辑的，这也是我们实战演习中会修改并检查的文件，而固定选项卡是只读的，我们可以在学习的过程中查看，但不能对其进行修改。\n\n一般来说，我们会将一个模块放在一个文件中，然后在要使用它的地方通过\`import 地址.模块名\`的方式导入该模块，这是在第一课第二章中所介绍过的内容。这样，我们可以方便地维护、管理和更新不同的模块功能。\n\n### 实战演习\n\n我们已经建立了一个多文件的结构，并完成了模块的拆分，接下来请将之前完成的交易脚本部分加入到文件中。\n\n1. 请浏览已经建立好的模块，并在当前活动的选项卡中完成交易脚本的内容。`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//在这里输入代码",
                    answer:"import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code:"module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code:"module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code:"module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lesson4 = {
    lessonserial: "第4课",
    title: "",
    intro: ["在上一课中，我们让城堡变得更加安全了，但这还不够，我们还需要设计相应的访问控制，本课中，我们将继续加固城堡。","assert()的使用方法;内置命令中的get_txn_sender()，move_to_sender()和borrow_globla();借用和可变借用;acquires的用法;解引用的用法"],
    key: 4,
    total: 6,
    chapters: [
        {
            title: "第一章 资源的统计 ",
            instruction: `## 第一章 资源的统计 \n\n在上一课中，我们提到对资源的操作需要满足稀缺性保障和访问控制的特点。因此，作为玩家持有的最重要的资源——城堡，我们需要保障其合理数量以及访问权限。\n\n为实现上述目的，我们可以在系统中添加一个计数器变量，每当新建一个城堡时，就更新该变量的值，并为该变量设置一个访问权限，只有管理员才可以访问该变量。\n\n注意：Libra中存在一个管理员账户，其地址为\`0xA550C\`，目前该账户的权限包括生成或销毁Libra币、访问市场容量等。类似地，我们的城堡系统中也存在一个管理员，它可以访问城堡数量。\n\n考虑到上述计数器变量需要安全性保障和访问权限的限制，我们将它的类型定义为资源，通过对资源的操作来实现一系列相关功能。（注：接下来的设计思路是模仿\`LibraCoin\`模块进行的，有兴趣的读者可以阅读该模块的代码。）\n\n### 实战演习\n\n首先，我们需要声明城堡总数的资源。\n\n1. 在\`BuildCastle\`模块中声明名为\`CastleSum\`的资源，该资源有一个\`u64\`成员变量\`sum\`。\n\n\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    // 在这里输入代码\n\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第二章 初始化过程的权限控制                                 ",
            instruction: `## 第二章 初始化过程的权限控制                                 \n\n根据第三课，我们知道资源在使用前需要被初始化。因此，在声明了\`CastleSum\`资源后，我们需要初始化它，以便后续使用。此时，我们面临两个问题：\n\n1. 初始化\`CastleSum\`的过程应该仅允许管理员在区块链系统刚建立时调用一次。换句话说，我们需要实现初始化过程的权限控制；\n2. 该资源在初始化后应当被发送到管理员所对应的地址，而不是最后在交易脚本中被销毁掉。\n\n我们将在本章解决第一个问题，在下一章解决第二个问题。\n\n针对第一个问题，我们需要学习两个新的内联过程。\n\n### \`assert()\`\n\n\`assert()\`是一个在很多编程语言中被广泛使用的操作，其作用是检查“不应该”发生的情况。\`assert()\`常常被用于在函数开始处检验传入参数的合法性，以及在函数结束时，判断结果的正确性。（注：其他语言中的函数相当于Move语言中的过程）\n\n在Move语言中，\`assert()\`有两个参数，第一个参数是一个表达式，程序在运行到\`assert()\`这一句时，会检查该表达式是否成立，如果成立，则继续执行；反之，则终止程序并输出错误码，错误码的值为第二个参数。\n\n下面的例子是一个简单的\`assert()\`的示例。\n\n\`\`\`\nmain() {\n  assert(1 + 2 == 3, 99);\n  return;\n}\n\n\`\`\`\n\n在该例中，程序判定\`1+2\`是否为3。若是，则无任何信息输出，反之，则会输出错误码99。\n\n### \`get_txn_sender()\`\n\n在Move语言中，有许多用于访问系统数据的内置命令，\`get_txn_sender()\`是其中的一个，它的功能是获取当前交易发送方的地址。\n\n下面是一个使用实例： \n\n\`\`\`\nmain() {\n    let sender: address;\n    let addr: address;\n    sender = get_txn_sender();\n    addr = 0x0;\n    assert(copy(sender) != copy(addr), 42);\n    return;\n}\n\n\`\`\`\n\n从该例中可以看出，\`get_txn_sender()\`的返回值是一个\`address\`型变量，我们通过\`变量名 = get_txn_sender()\`的方式将当前执行\`main()\`的账户地址赋值给一个\`address\`型变量。\n\n\n\n### 实战演习\n\n接下来，我们要建立初始化城堡总量的过程，并将该过程限制为只允许管理员账户调用。\n\n1. 在\`BuildCastle\`模块的\`desCastle()\`过程下面声明初始化城堡总量这一资源的过程，名为\`iniCastleSum()\`，该过程为公有过程，没有返回值。\n2. 通过\`assert()\`和\`get_txn_sender()\`的结合实现资源的权限控制。具体来说，通过\`assert()\`来判断当前的账户地址是否与管理员地址一致，如果不一致，则抛出错误信息并终止程序。这里，我们假设管理员账户地址为\`0x0000000\`，错误码为1。\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    // 在这里输入代码\n\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第三章 资源的发送 ",
            instruction: `## 第三章 资源的发送 \n\n在第三课中，我们曾介绍过资源的销毁，本章中，我们将介绍如何发布一个资源。\n\n我们需要将资源\`CastleSum\`发布到管理员地址，该操作可以通过\`move_to_sender()\`来实现。\n\n\`move_to_sender()\`是一个模块操作，它的作用是将一个资源发送到当前账户对应的地址存储，使用形式如下：\n\n\`move_to_sender<n>(e)\`，\n\n其中，\`n\`是资源类型，\`e\`是资源表达式。在解释该操作之前，我们首先要介绍一下泛型\`<>\`。\n\n### 泛型 \n\n泛型是程序设计语言的一种特性，它允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，这些可变部分在使用前必须作出指明。\n\n简单来说，我们可以通过泛型来使得一个过程可以同时被多种类型的变量使用，而不需要修改过程本身的代码。\n\n例如，一个实现了访问资源A的过程，在不使用泛型时，它的返回值类型是资源A的类型。此时，如果我们希望对资源B进行同样的操作，就需要再次声明一个内容完全相同、只有返回值不同的过程。这样的代码对开发人员来说是无意义的重复工作，并增加了代码的复杂性和冗余度。如果在这种情况下，我们使用泛型，那么相同的过程只需要完成一次，在具体调用时指明资源类型就可以在所有的资源上进行相同的操作。\n\n因此，泛型可以理解为把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。泛型为开发者提供了一种高性能的编程方式，能够提高代码的重用性和类型的安全性。\n\n在本章中，我们暂且先不考虑如何实现泛型过程，只考虑如何使用它。在Move语言中使用泛型的方式很简单：\`过程名<类型>(参数表达式)\`\n\n### \`move_to_sender()\`\n\n我们通过一个例子来具体地学习\`move_to_sender()\`。\n\n\`\`\`\npublic initialize() {\n        assert(get_txn_sender() == 0xA550C18, 1);\n        move_to_sender<MintCapability>(MintCapability{});\n        move_to_sender<MarketCap>(MarketCap { total_value: 0 });\n        return;\n}\n\`\`\`\n\n这是\`LibraCoin\`中对市场总量的初始化过程。Line 2通过\`assert()\`来判断当前账户是否为管理员账户，这是上一章中学到的知识点。Line 3和Line 4都是对\`move_to_sender()\`的使用，这两行分别将资源\`MintCapability\`和资源\`MarketCap\`发送到当前账户对应的地址，其中\`MintCapability\`是一个无成员变量的资源，它表示挖矿权限，而\`MarketCap\`的成员变量\`total_value\`则被初始化为0。\n\n总体来说，上述过程首先检查当前账户是否为管理员账户，如果是，则将挖矿权限赋予当前账户，并将市场容量（即当前系统中的所有\`LibraCoin\`的总和）置为0，并发送市场容量到当前账户。\n\n### 实战演习\n\n最后，我们要初始化城堡总数的资源，并将该资源发送给管理员账户。\n\n1. 在\`iniCastleSum()\`过程中通过\`move_to_sender()\`将我们已经声明过的\`CastleSum\`资源初始化为0，并发送给当前账户（即管理员账户，地址为\`0x0000000\`）。记得在过程结束时添加\`return\`。\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        // 在这里输入代码\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第四章 借用 ",
            instruction: `## 第四章 借用 \n\n在实现了城堡总量的初始化后，我们希望可以随时查看当前系统中一共有多少个城堡。\n\n这样的功能乍一看很容易实现，只需要访问\`CastleSum\`资源并输出其成员变量\`sum\`的值即可。但是要注意，我们已经知道，资源不能被\`copy()\`，只能被\`move()\`，当我们将\`CastleSum\`通过\`move()\`传入访问它的过程时，原本的资源变量将失去所有权，这就导致我们每访问一次，都需要重新将\`CastleSum\`重新初始化并发送到管理员账户——这显然是极其不合理的。\n\n所有权一方面提高了资源的安全性，另一方面也使得访问和改变资源的值变得十分困难。面对这样的问题，Libra Move引入借用的概念。\n\n借用是指对所有权的借用，又被称作引用，它的机制很像我们在其他语言中学习到的“读写锁”，即同一时刻，只能拥有一个“写锁”，或只能拥有多个“读锁”，不允许“写锁”和“读锁”在同一时刻同时出现。\n\nMove语言会在编译的时候检查借用的安全性，而不是运行时检查，这也避免了出现死锁、野指针等问题。\n\nMove通过\`&\`来实现借用。例如：\n\n\`\`\`\nmain() {\n    let x: u64;\n    let x_ref: &u64;\n    let y: u64;\n    x = 5;\n    x_ref = &x;\n    //y = copy(x);	//error\n    _ = move(x_ref);\n    y = copy(x);	//correct\n    return;\n}\n\`\`\`\n\n从这段代码中我们可以看出，声明一个借用的方式是：\`let 借用变量名: &借用变量类型\`。\n\n在声明借用后，就可以通过\`借用变量名: = &被借用变量名\`来实现借用。\n\n在借用期间，原变量的所有权被借走，我们无法在此期间通过\`copy()\`或其他方式来访问原变量。\n\n类似于资源需要显式销毁一样，借用是需要归还的，我们同样需要在不再使用借用时，或者在\`main()\`结束之前，显式地解除借用。\n\n例如，在这段代码中，我们通过\`_ = move(x_ref);\`来解除借用，其中\`_\`表示Move语言中的临时变量，这项操作将\`x_ref\`的所有权转移给临时变量，而临时变量会在使用结束后自动销毁，这样就解除了\`x_ref\`的借用。  \n\n### 可变借用\`mut\`\n\n像“读写锁”机制分为“读锁”和“写锁”一样，借用也分为“可变借用\`&mut\`”与“不可变借用\`&\`”。\n\n可变借用可以在借用期间修改原始变量的值，而不可变借用则只能读取。\n\n同一时刻，一个变量最多只有一个可变借用，或者有多个不可变借用，但是两种借用不能同时出现。\n\n例如，下面的例子是能成功编译的，而如果我们将\`x_ref = &x;\`改为\`x_ref = &mut x;\`，则会导致编译无法通过。\n\n\`\`\`\nmain() {\n    let x: u64;\n    let x_ref: &u64;\n    let x_ref2: &u64;\n    x = 5;\n    x_ref = &x;	//correct\n    //x_ref = &mut x;	//error\n    x_ref2 = &x;	\n    _ = move(x_ref);\n    _ = move(x_ref2);\n    return;\n}\n\`\`\`\n\n\n\n### 实战演习\n\n接下来，我们要建立查看当前系统中一共有多少个城堡的过程。\n\n1. 在\`BuildCastle\`模块声明一个名为\`castlesum()\`的过程，该过程无参数，返回值是一个\`u64\`型变量，表示城堡总数，注意这里为了与前面所声明的\`CastleSum\`资源区分开，过程名我们全使用小写字母；\n2. 在该过程的第一行声明一个名为\`CastleSum_ref\`的可变借用资源变量，我们将在之后几章中完善它的使用。\n\n\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    // 在这里输入代码\n\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第五章 borrow_global_mut()",
            instruction: `## 第五章 \`borrow_global_mut()\` \n\n在第三章中，我们学习了\`move_to_sender()\`的用法，本章中我们将介绍另一个模块操作：\`borrow_global_mut()\`。\n\n\`borrow_global_mut()\`也是一个实现了泛型的过程，参数是一个\`address\`变量，作用是全局借用，会返回指定地址下的对应类型的资源的**可变借用**。\n\n\`borrow_global_mut()\`的具体使用格式为：\`借用资源名 = borrow_global_mut<所需资源名>(地址)\`。例如：\`x_ref = borrow_global_mut<T>(0x0000)\`将地址\`0x0000\`的\`T\`资源借用给\`x_ref\`变量。\n\n很显然，\`borrow_global_mut()\`要求目标地址必须拥有所需借用的资源，如果目标地址没有该资源，则借用将失败。\n\n也就是说，一旦我们会在过程中使用\`borrow_global_mut()\`，我们需要在过程的一开始就告诉Move编译器这个过程将会借用什么样的资源，Move语言通过\`acquires T\`来实现这一操作。\n\n注意：Move中还有一个类似的操作：\`borrow_global()\`，该过程返回指定地址下的对应类型的资源的**不可变借用**。\n\n### \`acquires\`\n\n\`acquires\`可以理解为一个注释，它告诉字节码验证器当前过程（或其中调用的过程）会从全局状态借用或移动哪些资源类型，这些注释允许字节码验证器确保在全局状态下不存在对值的悬挂引用。\n\n注：悬挂引用是指当两个指针同时指向一个地址时，通过一个指针删除了该地址的数据，另一个指针出现指向空地址的问题。\n\n从编程角度来说，我们需要在以下三种情况使用\`acquires\`：\n\n1. 使用\`borrow_global_mut<T>\`；\n2. 使用\`move_from<T>\`；（我们将在之后的课程中介绍）\n3. 过程中调用了需要\`acquires T\`的过程。\n\n接下来让我们通过一个例子来学习\`acquires\`的使用：\n\n\`\`\`\nmodule A {\n    resource T1{v: u64}\n    public test(addr: address) acquires T1 {\n        let x: &mut Self.T1;\n        x = borrow_global_mut<T1>(get_txn_sender());\n        _ = move(x);\n        return;\n    }\n}\n\`\`\`\n\n该例中，我们从调用过程的地址借用\`T1\`资源，并存储在\`x\`中，由于使用了\`borrow_global_mut<T1>\`，我们需要在过程的开始检查资源\`T1\`是否存在，因此在声明过程的那一行最后写了\`acquires T1\`。\n\n（本章内容参考： https://community.libra.org/t/how-could-i-understand-the-keyword-acquires/1832  ）\n\n### 实战演习\n\n1. 在声明了可变借用后，通过\`borrow_global_mut()\`对\`CastleSum_ref\`进行初始化，其参数为管理员地址，暂定为\`0x0000000\`；\n2. 由于使用了\`borrow_global()\`，因此还需要在该过程的声明部分添加\`acquires\`语句。\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    //Add acquires here\n    public castlesum(): u64\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        // 在这里输入代码\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第六章 解引用 ",
            instruction: `## 第六章 解引用 \n\n如果你比较熟悉C语言，那么在看到前文中的借用\`&\`时，相信你也一定能想到解引用\`*\`。Move语言中也同样可以进行解引用，其用法与C语言中的十分接近。\n\n解引用(\`Deref\`)是引用(\`Ref\`)的反操作。\n\n在Move语言中，与给定结构（比如结构体或者资源）的字段交互的唯一方法是引用。因此，为了访问结构中的某些值，我们必须先对该字段进行引用，再通过解引用来创建一个绑定到该字段的值的新变量。\n\n简单来说就是，我们可以通过借用\`&\`获取资源的引用，然后通过解引用\`*\`获取该引用的值。\n\n\`\`\`\nfield_ref = &move(rsc).field;\nfield_value = *move(field_ref);\n\`\`\`\n\n当我们需要访问某个资源时，我们可以将借用和解引用组合起来使用，也就是\`*&\`，这样就能获取到某个资源的值，并可以在借用结束后归还所有权。\n\n例如，使用\`*&move(T).value\`，我们可以获取到资源\`T\`中名为\`value\`的成员变量值，当借用结束后，该资源及其成员变量的所有权不会被改变。\n\n最后，我们通过分析\`*&move(rsc).field\`总结一下常用的三个对变量和字段的操作：\`move()\`、\`&\`和\`*\`。\n\n\`*&move(rsc).field\`是一个由三部分指令组合起来的操作：变量的\`move()\`、对某一字段的借用和从借用中读取值。\n\n1. \`move(rsc)\`\n\n   每次访问一个局部变量时，我们都可以对它进行\`move()\`或者\`copy()\`操作。如果使用\`copy()\`，则意味着我们获取了该变量的一个副本；如果使用\`move()\`，则意味着我们转移了该值的所有权，在为该局部变量分配新值之前，不能再次访问它。\n\n2. \`&move(rsc).field\`\n\n   这是对一个字段的借用操作。访问一个结构中某字段的唯一方法是引用。在该操作中，原本对\`move(rsc)\`的引用被扩展为对字段\`field\`的引用，具体来说，我们当前所引用的内容不再是\`move(rsc)\`，而变成了\`field\`。\n\n3. \`*&move(rsc).field\`\n\n   这是一个解引用操作，它从一个借用中读取值。当我们进行解引用时，原本的借用并不会被改变，而是得到一个该借用的值的副本。具体来说，就是当前所访问的内容从\`&move(rsc).field\`变成了该值的副本。\n\n\n（本章内容参考：https://community.libra.org/t/meaning/1253/2）\n\n### 实战演习\n\n最后，我们需要获取城堡总数的数值，并将其返回。\n\n1. 通过\`*&\`获取\`CastleSum_ref\`这一资源中成员变量的值，并将其作为过程的返回值。\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        // 在这里输入代码\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        ]
}

const lesson5 = {
    lessonserial: "第5课",
    title: "",
    intro: ["上一课中，我们建立了城堡账户这一模块，但并没有实现它的具体功能，本课中，我们将实现账户的基本功能：建立和发布。","事件的声明;事件句柄的建立;事件消息的发送"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "第一章 搭建账户的框架",
            instruction: `## 第一章 搭建账户的框架\n\n还记得在第三课中，我们为了学习资源的建立而创建的\`CastleAccount\`模块和\`CastleAccount\`资源吗？在本章中，我们将实现城堡账户\`CastleAccount\`的基础功能。\n\n我们希望一个城堡账户的模块可以实现以下基础功能：\n\n- 新建一个账户，并同时为该账户建立城堡；\n- 将账户发布到发送方的地址。\n\n因此，在本章中，我们首先建立起该模块的框架，即资源和过程的声明。\n\n### 实战演习\n\n1. 修改资源\`CastleAccount\`的成员变量为\`new_castle\`，它的类型是\`BuildCastle\`模块中的资源\`Castle\`；\n\n2. 因为我们要在新建账户的同时实现城堡的建立，所以需要为过程\`newAccount()\`提供城堡的名字，修改过程\`newAccount()\`，为该过程添加类型为\`bytearray\`的参数\`name\`；\n\n3. 我们的城堡系统不删除账户，而是将账户发布出去，因此要将原本的\`desAccount()\`过程修改成名为\`publishAccount()\`的\`public\`过程，它的参数为\`account\`，参数类型是\`CastleAccount\`，该过程无返回值，因此在过程结束时只需要\`return\`。\n\n\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        //修改这里的代码\n        a: u64\n    }\n    //添加过程的参数\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n    //添加发布账户的过程\n\n}",
                    answer: "module CastleAccount {\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle\n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public publishAccount (account: Self.CastleAccount)\n    {\n        return;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第二章 建立账户",
            instruction: `## 第二章 建立账户\n\n在接下来的课程中，我们将使用已经学习过的方法来完善前一章中声明的几个过程，进而实现城堡账户的建立，并在该过程中同时建立城堡。\n\n具体来说，建立账户的过程的返回值是一个新建的账户资源，该账户的成员变量是一个新建的城堡资源。我们需要将之前在\`main()\`中实现的建立城堡的过程迁移到建立账户的过程中，并将该新建的城堡作为被返回账户的成员变量，这样就实现了在建立账户的同时建立城堡。\n\n### 实战演习\n\n1. 在\`newAccount()\`过程中实现原本由\`main()\`实现的功能，并在\`CastleAccount\`模块开始的地方导入实现这些功能所需的其他模块。\`main()\`中的内容不需要进行修改，</u>我们会在下一章修改\`main()\`。注意：这里在调用\`newCastle()\`过程后，不需要再调用\`desCastle()\`过程来销毁城堡资源；\n2. 在\`newAccount()\`过程中返回新建的账户资源。\n\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n     //在这里导入所需模块\n\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle\n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        //在这里输入代码        \n\n    }\n    public publishAccount (account: Self.CastleAccount)\n    {\n        return;\n    }\n}",
                    answer: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle\n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        \n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle)};\n    }\n    public publishAccount (account: Self.CastleAccount)\n    {\n        return;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第三章 发布账户",
            instruction: `## 第三章 发布账户\n\n我们希望将建立的账户发布到调用该过程的地址，这样城堡和它的主人可以产生对应关系。我们在第四课的第三章中介绍了发布资源的方式，也就是\`move_to_sender()\`的用法，如果记不清了可以复习一下。\n\n### 实战演习\n\n1. 在\`publishAccount()\`过程中使用\`move_to_sender()\`，发布账户资源；\n2. 修改\`main()\`的内容：将之前建立城堡的一系列操作删去，声明一个名为\`account\`的变量，类型为\`CastleAccount\`，记得在\`main()\`前导入所需的模块；\n3. 调用\`newAccount()\`和\`publishAccount()\`这两个过程来完成账户的建立和发布。\n\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount 和 main.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle\n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        \n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle)};\n    }\n    //在这里添加acquires\n    public publishAccount (account: Self.CastleAccount)\n    {\n        //在这里输入代码        \n\n    }\n}\n\n//在这里导入账户模块\nmain(name: bytearray) {\n    //在这里输入代码\n\n    return;\n}",
                    answer: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle\n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        \n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n       move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n}\n\nimport Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
            ]
        },
        {
            title: "第四章 事件",
            instruction: `## 第四章 事件\n\n**事件**是合约和区块链通信的一种机制。通过“监听”某些事件，你的前端应用会做出相应的反应。换句话说，我们往往会通过事件将一些希望前端得到的信息发送给它。Libra在\`Event\`模块中声明了关于事件的资源及基础操作，我们在使用时可以通过\`import 0x0.Event;\`来导入该模块。\n\n在使用事件前，我们首先要通过声明结构体的方式声明一个事件，例如：\n\n\`\`\`\nstruct Event {\n        x: u64\n}\n\`\`\`\n\n该事件的名称为\`Event\`，而我们要通过事件向前端发送的信息为\`x: u64\`。\n\n接下来要声明事件句柄，声明语句为\`let 句柄名: Event.Handle<Self.事件名>\`，例如：\n\n\`\`\`\nlet event_handle: Event.Handle<Self.Event>;\n\`\`\`\n\n我们需要将该句柄添加到与事件相关的资源的成员变量中，从而可以在需要发送事件的时候访问该句柄，例如：\n\n\`\`\`\nresource T {\n		events: Event.Handle<Self.Event>\n}\n\`\`\`\n\n我们通过\`Event\`模块中的\`new_event_handle()\`过程来建立事件句柄，该过程使用发送方的\`HandleIdGenerator\`生成唯一的事件句柄，可以将事件发送给该句柄。\n\n建立句柄的语句为：\`句柄名 = Event.new_event_handle<Self.事件名>()\`，例如：\n\n\`\`\`\nevent_handle = Event.new_event_handle<Self.Event>();\n\`\`\`\n\n在建立好句柄后，我们就可以通过\`Event\`模块中的\`emit_event()\`过程将带有信息的事件发送到句柄，而前端程序会通过该句柄获取事件信息。\n\n发送事件的语句为\`Event.emit_event<Self.事件名>(&mut move(资源借用).资源中的事件变量, move(事件名))\`，例如：\n\n\`\`\`\nEvent.emit_event<Self.Event>(&mut move(resource_ref).events, move(event));\n\`\`\`\n\n注意，这里我们要在发送事件前完成资源的借用，因此需要为该过程添加\`acquires\`和相关参数。\n\n### 实战演习\n\n1. 导入\`Event\`模块，在账户资源中添加事件句柄\`account_events\`这一成员变量；\n2. 在账户资源下面添加\`AccountEvent\`这一结构体，其成员变量为\`flag: u64\`；\n3. 修改新建账户的过程\`newAccount()\`：在该过程中建立句柄，并为其返回值添加\`account_events\`相关的内容；\n4. 我们希望在发布账户时，向前端发送一个信号，该信号为\`flag: u64 \`，值为\`1\`，请在发布账户的过程\`publishAccount()\`中添加事件句柄的声明和事件的发送，记得添加\`acquires\`。\n\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    //在这里导入所需模块\n\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        //在这里添加事件句柄\n\n    }\n    //在这里添加结构体\n\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        //在这里添加句柄相关的代码\n\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        //修改这里的返回值\n        return CastleAccount { new_castle: move(castle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        //在这里添加发送事件相关的代码\n\n       move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n}",
                    answer: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        {
            title: "第五章 完善城堡的建立",
            instruction: `## 第五章 完善城堡的建立\n\n在上一课中，我们建立了统计城堡数量的资源，并实现了它的销毁和发布。本章中我们要实现在建立城堡的同时，将城堡数量增加一个。\n\n### 实战演习\n\n1. 修改\`newCastle()\`过程的内容，声明一个名为\`sum_ref\`的变量，该变量是对\`CastleSum\`的可变借用（\`CastleSum\`是在前面课程中所声明的用于统计城堡数量的资源）；\n2. 在\`newCastle()\`过程中，再声明一个\`u64\`型变量\`sum_ref_value\`，用来存储\`sum_ref\`对应的解引用；\n3. 在\`newCastle()\`过程的返回值前添加修改城堡计数器的操作：首先使用\` borrow_global_mut\`为\`sum_ref\`赋值，管理员所在地址为\`0x0000000\`；接下来使用解引用对\`sum_ref_value\`赋值，最后让借用的\`sum_ref\`的成员变量值等于当前城堡数（即\`sum_ref_value\`）+1。由于在这里使用了\`borrow_global_mut\`，我们需要为该过程添加\`acquires CastleSum\`。\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        //声明相关变量\n\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        //修改计数变量的值\n\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum {\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
    ]
}

const lesson6 = {
    lessonserial: "第6课",
    title: "",
    intro: ["在前五课中，我们建立了城堡和城堡账户，并实现了其基础功能，在这一过程中，我们学习了Move语言的基础语法知识和相关操作。本课中，我们将为城堡添加一项游戏性的功能：等级提升。","变量的声明、初始化、所有权和使用;模块的声明和使用;过程的声明和调用;资源的声明和访问控制"],
    key: 6,
    total: 5,
    chapters: [
        {
            title: "第一章 城堡如何升级 ",
            instruction: `## 第一章 城堡如何升级 \n\n在过去的课程中，我们实现了建立城堡的功能，我们的城堡具有名字、序列号、等级、经济实力与军事实力这些属性。\n\n每个新建立的城堡等级为1级，经济实力与军事实力的初始值则根据序列号中的种族位决定。\n\n在接下来的课程中，我们会为城堡添加一些游戏性的功能，比如，升级。\n\n具体来说，我们的城堡通过吞并系统随机生成的土地，可以提升经济实力，当经济实力达到一定值时，城堡将自动升级。\n\n### 土地类型\n\n当玩家向系统发送吞并土地的请求时，系统会为玩家随机生成一块土地。\n\n土地一共有4种类型。吞并不同类型的土地，城堡的经济实力增长幅度也不同。\n\n不同土地类型出现的概率以及引起的经济增长幅度如下表所示：\n\n|                  | 类型1 | 类型 2 | 类型 3 | 类型 4 |\n| :--------------: | :---: | :----: | :----: | :----: |\n|       概率       |  75%  |  15%   |   8%   |   2%   |\n| 经济实力增长幅度 |  5%   |  10%   |  20%   |  40%   |\n\n### 城堡等级\n\n城堡的等级\`r\`与该等级的经济实力上限\`u\`的关系为 \`u(r)=10*r+2ʳ\`，当吞并土地后的经济实力达到上限时，城堡的等级将随之增加1级。\n\n### 实战演习\n\n演示城堡吞并土地增加实力进而升级的过程。\n\n`,
            type: 1,
            show(){
                return <L6c1 lang="0"/>
            }
        },
        {
            title: "第二章 获取城堡数据 ",
            instruction: `## 第二章 获取城堡数据 \n\n我们的任务分为以下三个步骤：\n\n1. 获取当前城堡的数据；\n2. 根据土地类型增加城堡的经济实力值；\n3. 根据城堡的经济实力值判断是否需要提升城堡等级。\n\n需要注意的是，城堡是资源，而在Move语言中，资源类型有着极其严格的访问控制和安全限制，我们不能直接读取城堡的等级或者修改其实力值。\n\n还记得在上一课的第五章中我们是如何修改资源\`CastleSum\`中的成员变量值吗？通过借用！在本课中，我们同样要通过借用的方式来获取城堡的数据。\n\n这时我们会面临新的问题：我们将城堡账户的资源发布到了用户地址，因此使用\`borrow_global_mut\`获取到的是城堡账户这一资源类型，而我们需要的城堡资源是城堡账户的一个成员变量，也就是说，我们需要获取一个资源的子资源。\n\n根据上一课的学习，我们可以通过如下的代码来获取发布到某个地址的资源的成员变量值。但是，如果我们尝试将资源\`T1\`的成员变量\`a\`从\`u64\`**改为**资源类型，就会发现这样的代码无法使用了。\n\n\`\`\`\nmodule T\n{\n    resource T1\n    {\n        a: u64\n    }\n    public fun(): u64 acquires T1\n    {\n        let add: address;\n        let ref: &mut Self.T1;\n        let x: u64;\n        add = get_txn_sender();\n        ref = borrow_global_mut<T1>(move(add));\n        x = *&move(ref).a;\n        return move(x);\n    }\n}\n\`\`\`\n\n问题出在\`x = *&move(ref).a\`这一步。\`*&move(ref).a\`这一操作可以分解为借用\`ref.a\`和解引用，而解引用进行了对\`ref.a\`的\`copy\`，当\`ref.a\`还是\`u64\`型变量时，这样的操作是完全正确的；当我们将其改为资源类型时，由于资源无法被\`copy\`，解引用这一步就会失败。\n\n那么要如何获取一个资源的子资源呢？请你先尝试思考这个问题，有一定思路后再继续阅读下面的方法。\n\n我们的目的是从当前地址获取城堡账户，再从城堡账户中获取对应的城堡资源，最后修改该城堡资源中的成员变量（经济实力值和等级）。因此，我们可以考虑在\`BuildCastle\`模块中声明一个用于处理升级中数据变化的过程，该过程的参数应该是对城堡资源的可变借用；而在\`CastleAccount\`模块中声明进行土地吞并的过程，这样，我们就可以在后者（土地吞并）中通过借用的方式获取城堡资源，再调用前者（升级）来修改城堡资源的成员变量。\n\n### 实战演习\n\n1. 在\`CastleAccount\`模块中的\`publishAccount()\`过程下面，声明土地吞并的过程\`annexation()\`，该过程没有参数和返回值，因此在最后一行直接添加\`return\`；\n2. 在\`annexation()\`过程中，仿照课程所给示例，获取对当前地址下城堡账户中的城堡资源的借用，其中，地址变量名为\`add\`，\`CastleAccount\`的可变借用名为\`ref\`，\`Castle\`的可变借用名为\`t\`；\n3. 最后调用\`BuildCastle\`模块中城堡升级的过程，过程名为\`upgrade()\`，调用时的参数为上一步中获取到的城堡借用，我们将在接下来的几章中实现该过程。\n\n提示：a. 这里需要获取的是对城堡资源的借用，因此不需要解引用；\n\n​            b. 在该过程中我们使用了\`borrow_global_mut()\`，因此在过程名后面要记得添加\`acquires\`。\n\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    //在这里声明并完成annexation()过程\n\n}",
                    answer: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    public annexation () acquires CastleAccount\n    {\n        let add: address;\n        let ref: &mut Self.CastleAccount;\n        let t: &mut BuildCastle.Castle;\n        add = get_txn_sender();\n        ref = borrow_global_mut<CastleAccount>(move(add));\n        t = &mut move(ref).new_castle;\n        BuildCastle.upgrade(move(t));\n        return;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        {
            title: "第三章 修改城堡实力",
            instruction: `## 第三章 修改城堡实力\n\n上一章中，我们解决了最难的问题——资源的访问，接下来我们要实现城堡升级的过程\`upgrade()\`。\n\n在该过程中，我们需要实现以下具体功能：\n\n1. 生成随机土地；\n2. 根据土地类型，增加城堡的经济实力值。\n\n在第二课中，我们曾实现了生成随机数的过程\`myrand()\`，本章中我们使用该过程来实现生成随机土地的功能。\n\n具体来说，我们会生成一个1~100的随机整数，该整数若小于等于2，则土地类型为4，若介于2和8之间，则土地类型为3，若介于8和15之间，则土地类型为2，若大于15，则土地类型为1。\n\n接下来，我们就可以采用与上一章中示例完全相同的方法，修改经济实力值。\n\n### 实战演习\n\n1. 在\`BuildCastle\`模块中声明\`upgrade()\`过程，该过程的参数是一个城堡资源\`ref\`的可变借用，没有返回值；\n2. 在\`upgrade()\`过程中声明经济实力值\`x: u64\`和随机数\`rand: u64\`，并为\`x\`赋值为\`ref\`的\`economic\`字段；\n3. 通过随机数过程，判断对应的土地类型；\n4. 根据土地类型，实现城堡经济实力值的增长。\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n    //在这里声明并完成upgrade()过程\n\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n    public upgrade(ref: &mut Self.Castle)\n    {\n        let x: u64;\n        let rand: u64;\n        x = *&copy(ref).economic;\n        if (copy(rand)<=15)\n        {\n            if(copy(rand)<=8)\n            {\n                if(copy(rand)<=2)\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*40/100;\n                }\n                else\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*20/100;\n                }\n            }\n            else\n            {\n                *(&mut copy(ref).economic) = copy(x) + move(x)*10/100;\n            }\n            \n        }\n        else\n        {\n            *(&mut copy(ref).economic) = copy(x) + move(x)*5/100;\n        }\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    public annexation () acquires CastleAccount\n    {\n        let add: address;\n        let ref: &mut Self.CastleAccount;\n        let t: &mut BuildCastle.Castle;\n        add = get_txn_sender();\n        ref = borrow_global_mut<CastleAccount>(move(add));\n        t = &mut move(ref).new_castle;\n        BuildCastle.upgrade(move(t));\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        {
            title: "第四章 提升城堡等级",
            instruction: `## 第四章 提升城堡等级\n\n接下来我们要实现城堡升级的功能。\n\n从本质上来说，提升等级与增长经济实力的逻辑是相同的，都是对资源中某个字段值的修改。\n\n但是需要注意的是，由于多了一些变量和操作，我们需要谨慎判断\`move\`和\`copy\`的使用。\n\n### 实战演习\n\n1. 在\`upgrade()\`过程中声明随机数的下面，声明城堡等级\`r: u64\`和该等级对应的经济实力上限值\`u: u64\`；\n2. 在经济实力值增长的代码下面，为\`r\`赋值为\`ref\`的\`level\`字段，并根据\`r\`的值来初始化\`u\`；\n3. 根据增长后的经济实力值与\`u\`的大小关系，判断城堡是否需要增加一级。\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n    public upgrade(ref: &mut Self.Castle)\n    {\n        let x: u64;\n        let rand: u64;\n        //在这里输入代码\n\n        x = *&copy(ref).economic;\n        if (copy(rand)<=15)\n        {\n            if(copy(rand)<=8)\n            {\n                if(copy(rand)<=2)\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*40/100;\n                }\n                else\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*20/100;\n                }\n            }\n            else\n            {\n                *(&mut copy(ref).economic) = copy(x) + move(x)*10/100;\n            }\n            \n        }\n        else\n        {\n            *(&mut copy(ref).economic) = copy(x) + move(x)*5/100;\n        }\n        //在这里输入代码\n\n        return;\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n    public upgrade(ref: &mut Self.Castle)\n    {\n        let x: u64;\n        let rand: u64;\n        let r: u64;\n        let u: u64;\n        x = *&copy(ref).economic;\n        if (copy(rand)<=15)\n        {\n            if(copy(rand)<=8)\n            {\n                if(copy(rand)<=2)\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*40/100;\n                }\n                else\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*20/100;\n                }\n            }\n            else\n            {\n                *(&mut copy(ref).economic) = copy(x) + move(x)*10/100;\n            }\n            \n        }\n        else\n        {\n            *(&mut copy(ref).economic) = copy(x) + move(x)*5/100;\n        }\n        r = *&copy(ref).level;\n        u = 10 * copy(r) + Math.pow (2, copy(r));\n        if ( *(&mut copy(ref).economic) > move(u))\n        {\n            *(&mut move(ref).level) = move(r) + 1;\n        }\n        else\n        {\n            *(&mut move(ref).level) = move(r);\n        }\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    public annexation () acquires CastleAccount\n    {\n        let add: address;\n        let ref: &mut Self.CastleAccount;\n        let t: &mut BuildCastle.Castle;\n        add = get_txn_sender();\n        ref = borrow_global_mut<CastleAccount>(move(add));\n        t = &mut move(ref).new_castle;\n        BuildCastle.upgrade(move(t));\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        {
            title: "第五章 增加限制",
            instruction: `## 第五章 增加限制\n\n到此为止，我们已经实现了城堡升级的功能！\n\n但是城堡的升级必须加以限制，我们不希望玩家可以随心所欲地增长城堡的经济实力和等级。\n\n由于Move语言目前仍然没有实现获取时间的功能，我们选择通过区块高度来限制土地吞并的次数，区块高度每增加100，玩家可以获得一次吞并土地的机会。\n\n具体来说，我们会在账户中记录该账户上次成功发起土地吞并时的区块高度，当玩家试图吞并土地时，我们会检查当前区块高度是否比上次的区块高度多100，如果是，则进行\`upgrade()\`操作，反之，则不进行操作。\n\n### 实战演习\n\n1. 为\`CastleAccount\`资源添加\`height: u64\`（位置为\`new_castle\`的下面），该变量用来记录该账户上次成功发起土地吞并时的区块高度;\n2. 在\`newAccount()\`过程中，将变量\`height: u64\`初始化为建立账户时的区块高度（声明位置为\`SerialNum\`下面，初始化赋值位置为\`castle\`下面），同时导入\`Block\`模块；\n3. 在\`annexation()\`过程中声明 \`h1: u64\`和\`h2: u64\`（声明位置为\`t\`下面）: \`h1\`用来记录城堡账户资源中的区块高度，\`h2\`用来记录调用该过程时的区块高度；\n4. 在\`t = &mut move(ref).new_castle;\`下面获取该城堡账户所记录的区块高度值\`h1\`，并初始化\`h2\`；\n5. 比较\`h1\`和\`h2\`的差值，判断是否要调用\`upgrade()\`进行升级；\n6. 检查该过程中的\`move\`和\`copy\`是否使用正确。\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    //在这里导入Block模块\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        //在这里输入代码\n\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        //在这里输入代码\n\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        //在这里输入代码\n\n        //修改返回值\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    public annexation () acquires CastleAccount\n    {\n        let add: address;\n        let ref: &mut Self.CastleAccount;\n        let t: &mut BuildCastle.Castle;\n        //在这里输入代码\n\n        add = get_txn_sender();\n        ref = borrow_global_mut<CastleAccount>(move(add));\n        t = &mut move(ref).new_castle;\n        //为upgrade()增加判定条件\n        BuildCastle.upgrade(move(t));\n        return;\n    }\n}",
                    answer: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    import 0x0.Block;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        height: u64,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {                \n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let height: u64;\n        let castle: BuildCastle.Castle; \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        height = Block.get_current_height();\n        return CastleAccount { new_castle: move(castle), height: move(height), account_events: move(event_handle)};\n    }    \n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    public annexation () acquires CastleAccount\n    {\n        let add: address;\n        let ref: &mut Self.CastleAccount;\n        let t: &mut BuildCastle.Castle;\n        let h1: u64;\n        let h2: u64;\n        add = get_txn_sender();\n        ref = borrow_global_mut<CastleAccount>(move(add));\n        t = &mut copy(ref).new_castle;\n        h1 = *&copy(ref).height;\n        h2 = Block.get_current_height();\n        if (copy(h2)-copy(h1) >= 100)\n        {\n            BuildCastle.upgrade(move(t));\n            *(&mut move(ref).height) = move(h2);\n        }\n        else\n        {\n            _ = move(t);\n            *(&mut move(ref).height) = move(h1);\n        }\n        return;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n    public upgrade(ref: &mut Self.Castle)\n    {\n        let x: u64;\n        let rand: u64;\n        let r: u64;\n        let u: u64;\n        x = *&copy(ref).economic;\n        if (copy(rand)<=15)\n        {\n            if(copy(rand)<=8)\n            {\n                if(copy(rand)<=2)\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*40/100;\n                }\n                else\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*20/100;\n                }\n            }\n            else\n            {\n                *(&mut copy(ref).economic) = copy(x) + move(x)*10/100;\n            }\n            \n        }\n        else\n        {\n            *(&mut copy(ref).economic) = copy(x) + move(x)*5/100;\n        }\n        r = *&copy(ref).level;\n        u = 10 * copy(r) + Math.pow (2, copy(r));\n        if ( *(&mut copy(ref).economic) > move(u))\n        {\n            *(&mut move(ref).level) = move(r) + 1;\n        }\n        else\n        {\n            *(&mut move(ref).level) = move(r);\n        }\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        ]
}


const lessons = [lesson1, lesson2, lesson3, lesson4, lesson5, lesson6];

export default lessons;

