import React from 'react';
import L1c1 from '../L1C1/L1C1'

const lesson1 = {
    info : {
        name: "移动城堡",
        subname: ["Libra Move的游戏化课程", "*基于Libra move Commit 61649eb"],
        intro: "在现有的区块链系统中，比特币对“货币”进行编程，以太坊对“应用”进行编程，与之相比，Libra对“资产”进行编程。\n\n在Libra 中我们可以定义一些比货币更复杂的资产类型，这种资产被称为 “资源”。Libra利用Move语言限制对资源的操作来防止不恰当的修改，从而提高资产的安全性。\n\nMove为 Libra 区块链提供安全、可编程的基础，该语言针对“资产”进行编程的方式，和对安全性的严格限制，使其十分适合用于发行数字货币、处理区块链交易以及验证器管理。\n\n在本课程中，我们使用Move语言来搭建一个城堡并实现城堡扩张和对战等功能，以帮助初学者更快速地学习这门语言。",
        goback: "←目录",
        editor: "编辑器",
        lesson: "教程",
        copyAnswer: "复制答案",
        learnmore: "了解更多",
        start: "开始学习",
        indexpage:"https://www.learnlibramove.com/index-cn.html",
        learninide:["本课程代码能够在ChainIDE中编译通过","前往ChainIDE"],
        practice: "现在开始",
    },
    local:{
        hint: "提示",
        previous: "上一章",
        next: "下一章",
        catalog: "目录",
        checkcode: "检查代码",
        showAnswer: "显示答案",
        hideAnswer: "隐藏答案",
        contitle: ["恭喜完成本章~", "恭喜完成本课~", "精彩还在继续"],
        concontent: ["点击“继续前进”，迎接新的挑战吧！", "本课到此结束，点击“返回”回到目录页！点击“下一课”继续学习关于Libra的新知识！", "Hi~恭喜你已经完成目前课程的所有内容了~更多课程将不久之后为大家呈现。现在，让我们前往ChainIDE编写自己的Libra Move合约吧！"],
        concontinue: ["继续前进", "返回", "前往ChainIDE", "下一课"],
        shut: "关闭窗口",
        target: "课程简介",
        keypoint: "知识点",
        detail: "查看详情"
    },
    lessonserial: "第1课",
    title: "",
    intro: ["在课程1中，我们将引导你为自己的城堡奠基，你的城堡具有专属的独一无二的外观以及你意想不到的生物居住在里面。", "如何建立一个合约;Move中的模块;Move中的main();变量及数据类型;Move中的过程"],
    key: 1,
    total: 5,
    chapters: [
        {
            title: "第一章 概述",
            instruction: `## 第一章 概述\n\n在第一课中我们将学习如何建立一个城堡。\n\n- 我们将通过模块来建立新的城堡\n- 我们的城堡会被保存在数据库（Libra区块链）中\n\n在之后的章节中，我们城堡的功能会逐渐增加，比如增强自身的实力、与其他玩家的城堡发生战争等，但在此之前，我们首先需要实现建立城堡的功能。 \n\n### 城堡有哪些属性？\n\n每个城堡具有名字、序列号、等级、经济实力与军事实力。其中，序列号决定城堡的外观和城堡中的生物种族，等级决定了城堡的价值，经济实力与军事实力会影响城堡在与其他城堡进行交互时的表现。\n\n### 序列号如何影响城堡？\n\n城堡的外观和种族由序列号决定，序列号是一个8位整数，比如：83451029。\n\n序列号的每一位对应着城堡的一个属性，具体如下：\n\n|  1   |  2   |  3   |    4     |    5     |    6     |  7   |    8     |\n| :--: | :--: | :--: | :------: | :------: | :------: | :--: | :------: |\n| 大小 | 样式 | 颜色 | 徽标样式 | 徽标颜色 | 徽标位置 | 种族 | 特殊标识 |\n\n出于游戏趣味性的考虑，我们将序列号设定为根据建立城堡时的区块深度随机产生，而不是由用户自主决定，当然这并不意味着城堡的外观是不确定的，因为在建立城堡的同时序列号就是一个固定值了。每个新建立的城堡的名字由用户输入，等级初始值为1级，初始经济实力和军事实力由序列号中的种族位决定，其对应关系如下：\n\n|  种族位  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| 经济实力 |  6   |  8   |  3   |  7   |  4   |\n| 军事实力 |  6   |  3   |  8   |  4   |  7   |\n\n### 实战演习\n\n1. 请拖动页面右侧的滑块，探索不同序列号对应的城堡外观。\n\n\n **了解了这些基础内容后，点击下一章，继续学习Move语言**。\n\n`,
            type: 1, 
            show(){
                return <L1c1 lang="0"/>
            }
        },
        {
            title: "第二章 合约与模块",
            instruction: `## 第二章 合约中的模块\n\n合约是在区块链上运行的计算机程序，我们通过运行合约从而在区块链上完成一系列操作，比如转账、购买商品等。\n\nMove合约整体的代码被分为两部分：\n\n- 由\`modules:\`开头的模块部分\n- 由\`script:\`开头的\`main()\`\n\n我们将在本章介绍\`modules\`部分，在下一章介绍\`script\`部分。\n\n### 模块\n\n模块部分包含了整个合约所需要用到的模块（\`Module\`），模块是Move合约的基本封装单元，所有部署在 Libra 上的模块都是全局的。\n\n模块中可以定义 结构体(\`Struct\`)、资源(\`Resource\`)和 过程(\`Procedure\`），这些概念我们将在后续章节中进行介绍。\n\n模块类似于以太坊中的智能合约，也类似于Java语言中的类。我们可以把模块看成一个整体具有一定功能的代码块，通过使用接口来访问模块的内部信息。\n\n例如，\`LibraCoin\`模块是Libra官方发布的Libra币模块。该模块中有对Libra币的定义和实现Libra币的转账、充值等操作的过程。开发人员在引入该模块后，就可以通过接口来实现相关功能。\n\n#### 如何建立模块\n\n我们通过\`module 模块名 { }\`的方式来建立一个模块。\n\n#### 如何引用模块\n\n类似于Java中“包名 + 类名”的引用方式，Move通过“地址+模块名”的方式来引用\`import\`一个模块，例如:\n\n\`import 0x0.LibraCoin\`\n\n这里的\`LibraCoin\`是模块名，\`0x0\`是发布该模块的账户地址。每个用户都可以在区块链上发布自己的模块，也可以通过这种方式引用他人发布的模块。所有Libra官方发布的模块地址都是\`0x0\`。\n\n导入同一个文件中的模块时，可以直接使用\`import Transaction.模块名\`，例如\n\n\`import Transaction.LibraCoin\`\n\n### 实战演习\n\n为了建立我们的城堡，我们要先建立一个名为\`BuildCastle\`的模块，我们将在该模块中逐渐实现建立城堡的一系列功能。\n\n1. 建立一个空模块\`BuildCastle\`\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//在这里输入代码",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "第三章 合约中的main()",
            instruction: `## 第三章 合约中的\`main()\`\n\n上一章中我们学会了如何建立一个模块，接下来我们要在这个模块的基础上，完善合约的内容。\n\n我们可以在合约中嵌入一段一次性执行的代码，这段代码被称为交易脚本（Transaction Script），并且不能被其他代码调用。交易脚本由\`script:\`作为开始的标识符。\n\n\`main()\`是执行交易脚本的入口。我们将类似\`main()\`形式的代码块称为“过程”，并将在后续章节中详细介绍过程的概念，\`main()\`是一种特殊的过程，它只会被调用一次，且无法被其他过程调用。\n\n注意，包括\`main()\`在内的每个过程都必须以\`return\`结尾，Move编译器非常字面化：它直接翻译源代码，而不会做一些其他的事情，比如插入丢失的\`return\`'。\n\n在编写Move合约的时候，我们通常将所有操作写在普通过程（指除了\`main()\`以外的过程）中，而将普通过程放入模块中，最后在\`script\`部分中导入模块，并以\`main()\`为入口，调用模块中的过程来完成一系列操作，整体思路如下图所示。\n\n<img src=${require("../../static/images/lesson1/pic_1_2_1_zh.png")} style="width:80%;position:relative;left:10%">\n\n\n\n注意，当我们需要在模块中导入其他模块时，导入语句需要出现在模块内部的第一行，也就是\`module 模块名\`的下一行。而当我们需要在\`script\`部分中导入模块时，导入语句出现在\`script\`部分的第一行，也就是\`script: \`的下一行，\`main()\`的前一行。\n\n综上所述，下面就是一个最基本的空合约： \n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### 实战演习\n\n在已经建立好的\`BuildCastle\`模块基础上，建立一个空合约。\n\n1. 首先添加\`modules: \`和 \`script: \`；\n2. 在\`script\`的下一行添加\`main()\`，记得在\`main()\`中添加\`return\`语句；\n3. 在\`script\`部分中通过\`import\`导入模块（在\`main()\`的前一行）。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//在这里输入代码\nmodule BuildCastle {\n\n}\n//在这里输入代码\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: "第四章 变量绑定与数据类型",
            instruction: `## 第四章 变量绑定与数据类型\n\n### **变量绑定**\n\n变量绑定是指将一些值绑定到一个变量上，这样可以在之后使用他们。\n\n与Rust语言类似，Move语言通过let关键字来绑定变量，形式如下：\`let 变量名: 变量类型;\`  例如：\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\n在绑定变量之后就可以进行初始化了，可以直接使用等号\`=\`来初始化，例如：\n\n\`\`\`\nx = 5;\n\`\`\`\n\n需要注意的是，所有过程中的变量绑定都需要在最开始进行，也就是说，所有的\`let\`语句都需要放到最前面，在代码块中间加入\`let\`语句会导致编译失败。\n\n### 数据类型\n\n目前，Move语言支持以下数据类型：\n\n- 布尔（\`boolean\`）\n- 64位无符号整数（\`uint64\`）\n- 地址（\`address\`）\n- 字节数组（\`bytes\`）\n- 结构体（\`struct\`）\n- 资源（\`resource\`），这是Move语言特有的类型\n\n其中，\`boolean\`类型使用\`bool\`关键字，\`uint64\`类型使用\`u64\`关键字，\`address\`类型使用\`address\`关键字，\`bytes\`使用\`bytearray\`关键字。我们可以通过如下的方式声明不同类型的变量：\n\n\`\`\`\nmain() {\n    //变量绑定 \n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //变量初始化\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h "123abc";\n    return;\n}\n\`\`\`\n\n也可以声明资源和结构体：\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\n其中，\`f1\`和\`f2\`是变量名。\n\n 需要注意的是，因为Move指令不会自动初始化，所以我们无法使用未经初始化的变量。\n\n### 实战演习\n\n我们的城堡序列号将由一个8位数字组成，因此我们要通过模运算\`%\`来将随机生成的序列号限制为8位整数。在此之前，我们首先需要一个名为\` SerialDigits\` 的变量，用它表示序列号位数，这是本章的任务。\n\n在\`main()\`过程中定义 \`SerialDigits\` 为 u64 数据类型, 并赋值为 8。 \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //在这里输入代码\n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 过程",
            instruction: `## 第五章 过程\n\n如第二章所说，在模块中我们可以定义过程，过程类似于其他语言中的函数。\n\n### 过程的声明\n\n在声明一个过程的时候，我们需要声明其可见性、名称、参数和返回值，格式如下：\n\n\`可见性 过程名( 参数名 ) : 返回值类型\`\n\n需要注意的是：在过程没有参数的情况下，不需要声明参数名；在没有返回值的情况下，不需要声明返回类型。\n\n模块中的过程有两种可见性：\n\n- 公有（public）：公有过程可以被其他模块调用\n- 私有（private）：私有过程只能被同模块的过程调用。模块中的资源都是私有的，只有通过公有过程才能被其他模块访问\n\n当要声明的过程既没有参数也没有返回值时，我们使用如下的方式声明：\n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\n当要声明的过程有参数时，则改写为如下形式：\n\n\`\`\`\npublic Procedure(a: u64, b: u64) { //参数是其他类型或者有更多（更少）参数时，形式是类似的\n    return;\n}\n\n\`\`\`\n\n需要注意的是，过程本身也可以作为参数传入其他过程。\n\n如果要声明的过程有返回值，则改写为如下形式：\n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 { //返回值是其他类型时，形式是类似的\n    return 1;\n}\n\n\`\`\`\n\n在以上的例子中，我们定义的都是公有过程（public），如果要声明私有过程，可以直接去掉\`public\`。\n\n### 过程的调用\n\n过程通过 \`模块名.过程名\` 的方式调用，如果调用同模块的过程，则通过 \`Self.过程名\` 来调用。\n\n如下就是一个声明并调用过程的例子：\n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //声明了一个公有过程，过程名是Procedure\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //调用过程，其中Contract是模块名\n    return;\n}\n\n\`\`\`\n\n### 实战演习\n\n在前面的章节中，我们提到要通过模运算\`%\`来将序列号转为8位整数，具体来说，一个数字模10<sup>n</sup>得到的结果就是n位整数，因此在这里我们要通过过程来计算10<sup>8</sup>。\n\n1. 在\`BuildCastle\`模块的上面建立一个数学运算的模块\`Math\`，它将包括本课程中所有的数学运算过程。\n2. 在新建的模块中声明幂运算的过程\`pow()\`，具体如下：\n   - 参数：类型为u64的底数 x 和指数 n\n   - 返回值：类型为u64的幂运算结果\n   - 过程内容：暂时是空的，为了编译通过，我们暂且让它的返回值是1。我们将在下一章来实现它的功能。\n3. 在\`main()\`前导入数学运算模块\`Math\`，并在\`SerialDigits\`后面声明一个名为\`SerialLimit\`的\`u64\`变量，它代表序列号的位数限制。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \n//在这里输入代码\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//在这里输入代码\n\nmain() {\n    let SerialDigits: u64;\n    //在这里输入代码\n\n    SerialDigits = 8;\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },    
    ]
};

const lesson2 = {
    lessonserial: "第2课",
    title: "",
    intro: ["在课程1中，我们学习了变量相关的操作，并成功声明了城堡的序列号，为城堡的建立奠定第一块基石。在课程2中，我们将引导你搭建城堡的框架，亲手打造自己的城堡世界。","所有权;Move中的程序结构;结构体的建立和使用;Move中的常用运算符;Move中的多返回值过程"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "第一章 所有权",
            instruction: `## 第一章 所有权\n\n### 所有权的使用\n\n在前面的内容中，我们提到了“绑定”这个词，实际上，绑定是指所有权的绑定，只有在某标识符拥有某值的所有权时，我们才可以通过该标识符来访问该值。\n\n当我们将一个值绑定到某个名字（标识符）时，是将该值（资源）的所有权绑定到这个标识符。例如：\n\n\`\`\`\nlet x: u64;\nx = 3;\n\n\`\`\`\n\n当我们通过\`let\`关键字将标识符\`x\`和类型为\`u64\`、值为3的资源绑定后，\`x\`就拥有了对3的所有权。在绑定期间，该标识符独享该资源的所有权，可以访问、更改该值，但是一旦将绑定转移给其他标识符后，该标识符不再拥有对该值的所有权。\n\n### 所有权的转移\n\n当我们希望转移所有权时，出于内存安全的设计，我们必须使用\`move()\`来进行所有权的转移，而不能直接用\`=\`。\n\n也就是说，在Move语言中，标识符之间不能使用\`=\`连接，只有标识符和值可以使用\`=\`连接。例如以下代码就是错误的示例：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //error\n\n\`\`\`\n\n接下来，我们通过具体的代码来说明所有权的转移：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); //将3的所有权从标识符x转移(move)给标识符y\nz = move(x); //error: 此时标识符x已经失去所有权，成为一个未经初始化的变量，因此move(x)失败\nz = move(y); //将3的所有权从标识符y转移(move)给标识符z\nx = 3; 	//重新初始化标识符x\nz = move(x); //此时可以通过move将3的所有权从标识符x转移给标识符z\n\n\`\`\`\n\n### 所有权的复制\n\n在一些情况下，我们希望可以在不转移所有权的情况下，让一个标识符的值等于另一个标识符的值，这个时候就需要使用过程\`copy()\`，一个标识符经过\`copy\`后，依旧可以继续被访问。例如：\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); //将3的所有权从标识符x复制（copy）给标识符y\nz = move(x); //将3的所有权从标识符x转移（move）给标识符z\n\n\`\`\`\n\n需要注意的是，当我们调用过程并传入参数的时候，不能直接使用参数名，而需要使用\`move(参数名)\`或\`copy(参数名)\`的方式，将所有权传入过程，要根据参数在代码前后的使用情况来决定使用\`move\`还是\`copy\`。\n\n### 实战演习\n\n在上一课中我们已经声明了\`SerialLimit\`，本章中我们希望\`SerialLimit\`的值等于10<sup>SerialDigits</sup>。为此，我们需要调用\`pow()\`过程来初始化\`SerialLimit\`，该过程的参数分别是10和\`SerialDigits\`。\n\n上述任务需要将一个变量作为参数传递到\`pow()\`过程中，因此涉及到了所有权的转移，而\`SerialDigits\`在之后的内容中也许还会再次使用，因此要使用\`copy()\`。此时\`pow()\`过程还是空的，我们将在下一章实现它。\n\n在\`main()\`中通过调用\`pow()\`过程初始化\`SerialLimit\`，调用过程的方式为\`模块名.过程名\`，是在上一章中介绍的，如果发现自己遗忘了，可以复习一下。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //在这里输入代码\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第二章 程序结构",
            instruction: `## 第二章 程序结构\n\n与其他语言类似，在Move语言中也有常用的程序结构，比如选择和循环。\n\n我们可以通过\`if-else\`语句来实现简单的选择结构，具体规则如下：\n\n1. 分支语句必须由双大括号\`{}\`包括起来，即便只有一句也需要，如下的例子就是错误的：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;	//这里 x = 3 需要有大括号\n       return;\n   }\n   \`\`\`\n\n2. 分支语句的分号\`;\`在每句结束后面加，不需要在大括号后面加分号，如下的例子也是错误的：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;\n       else {\n           x = 5\n       };	//这里的分号应该出现在上一行结尾\n       return;\n   }\n   \`\`\`\n\n3. 如果一个标识符的初始化是在分支语句中进行，那么当分支语句并不包含所有情况时，分支结束后该标识符无法被访问，如下的例子是错误的：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       }	//这里仅在if分支中对变量x进行了初始化，而在else分支对应的情况下，中变量x是未经初始化的，因此我们无法在后面使用copy来访问x\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n   而如果分支包含了所有情况，则分支结束后可以访问该标识符，如下的例子是正确的：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } else {\n           x = 43;\n       }	//这里的两个分支包含了true和false，也就是说无论什么情况，变量x都将被初始化，因此我们可以在后面使用copy\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \`\`\`\n\n4. 在分支语句中使用\`move()\`时，一定要注意所有权问题，在分支中被\`move()\`的标识符，在分支结束后不应该再次被访问，如下的例子是错误的：\n\n   \`\`\`\n   main() {\n       let x: u64;\n       let y: u64;\n       x = 0;\n       if (true) {\n           y = move(x);	//在该分支中我们将变量x的所有权转移给变量y，因此在后面的代码中，我们不能再次通过copy(x)来访问变量x\n       }\n       assert(copy(x) == 0, 42);\n       return;\n   }\n   \`\`\`\n\n我们也可以通过\`loop\`实现循环结构，由于篇幅原因，本章不进行详细介绍，我们将在后续的章节中介绍。\n\n### 实战演习\n\n幂函数最常见的实现方式是递归，如下是一个C语言中的幂函数实例：\n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\n\`\`\`\n\n请模仿以上程序，在\`Math\`模块中实现\`pow()\`的具体内容，注意变量的所有权问题，并恰当地使用\`copy\`和\`move\`。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //在这里输入代码\n        \n        return 1; //删去这句return\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第三章 结构体",
            instruction: `## 第三章 结构体\n\nMove语言中的结构体与其他语言的类似，是由一系列具有相同类型或不同类型的数据构成的数据集合。通过\`struct 结构体名{数据1: 类型, 数据2: 类型, ...}\`的方式声明，例如：\n\n\`\`\`\nmodule Test {\n	//空结构体\n  	struct Empty1 { }\n  	//有两个成员的结构体\n  	struct T { a: u64, b: u64, }\n}\n\n\`\`\`\n\n注意：\n\n- 结构体只能在模块的最前面进行声明，而不能在过程中声明\n- 结构体也可以被\`copy\`或者\`move\`\n\n关于结构体的更多使用，我们将在后续章节使用到时再介绍。\n\n### 实战演习\n\n在\`BuildCastle\`模块中声明结构体\`Castle\`，它包含5个成员：\`name(bytearray)\`, \`SerialNum(u64)\`, \`level(u64)\`, \`economic(u64) \`和\`military(u64)\`。\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//在这里输入代码\n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "第四章 运算操作",
            instruction: `## 第四章 运算操作\n\n在前面章节中，我们已经用到了一些基础运算，例如加法、乘法等，这一章中我们将具体了解Move已经实现了的几种运算操作。\n\nMove语言目前实现了如下几种数学运算：加 \`+\`  减 \`-\` 乘\`*\`除\`/\`模\`%\`，具体使用实例如下：\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\n\`\`\`\n\n还实现了比较运算：大于\`>\`、小于\`<\`、等于\`==\`、大于等于\`>=\`、小于等于\`<=\`、不等于\`!=\` ，具体实例如下：\n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\n\`\`\`\n\n此外，Move还实现了几种位运算和布尔运算等，由于篇幅原因，本章不进行详细介绍，我们将在后续的章节中介绍。\n\n### 实战演习\n\n我们希望根据当前区块的深度来生成随机的城堡序列号。\n\n最基础的随机数生成算法是通过模运算来实现的。\n\n如下是C语言中实现简单伪随机数的代码示例，很显然，这样的程序得到的随机数序列取决于\`next\`初始值的选择。\n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\n\`\`\`\n\n在这段程序的基础上，我们稍作修改，即可得到如下根据种子\`seed\`生成一个随机数的程序：\n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\n\`\`\`\n\n我们可以用与其他语言完全相同的方式，通过模运算让这段代码最终生成指定范围内的随机数。具体来说，想要生成从\`m\`到\`n\`的随机数，可以使用以下代码：\n\n\`\`\`c\nmyrand(seed) % (n - m + 1) + m;\n\n\`\`\`\n\n1. 请仿照上述的随机数生成程序，在\`Math\`模块中添加生成随机数的过程\`myrand()\`，并实现其具体功能。\n2. 请在\`BulidCastle\`模块中添加并实现公有过程\`generateSerial()\`，该过程根据区块深度调用\`Math\`模块的\`myrand\`过程来生成随机的8位序列号（即生成10<sup>7</sup>到10<sup>8</sup>-1之间的随机数），参数是序列号位数限制\`SerialLimit\`，返回值是\`u64\`。\n   - 区块深度可通过\`Block\` 模块中的 \`get_current_height()\` 方法获取。\n   - \`Block\`模块的地址是\`0x0\`。\n   - 请在正确的地方导入\`Math\`模块和\`Block\`模块。\n3. 在\`main()\`中声明\`SerialNum\` 并通过\`generateSerial()\`过程初始化。\n\n\n`
            ,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //在这里输入代码\n    \n}\nmodule BuildCastle {\n    //在这里输入代码\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //在这里输入代码\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //在这里输入代码\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //在这里输入代码\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 多返回值过程",
            instruction: `## 第五章 多返回值过程\n\n第五章中我们介绍了过程，并通过实例说明了有返回值的过程应该如何使用。但是，在很多场景中，我们往往希望一个过程可以有多个返回值，本章中，我们将介绍如何编写多返回值的过程。\n\n根据第五章可知，单返回值的过程可以这样声明：\n\n\`\`\`\npublic 过程名(参数名1，参数名2，...) : 返回值类型 {...}\n\n\`\`\`\n\n类似地，我们以两个返回值的过程为例，多返回值的过程声明方式为：\n\n\`\`\`\npublic 过程名(参数名1，参数名2，...) : 返回值类型 * 返回值类型 {...}\n\n\`\`\`\n\n调用方式为：\n\n\`\`\`\n变量1, 变量2, ...  = 模块名.过程名( 参数1, 参数2, ...)\n\n\`\`\`\n\n在使用多返回值过程的时候，有以下几点需要注意：\n\n1. 当多返回值过程与单返回值过程进行运算时，实际发生运算的只有多返回值过程的最后一个返回值与单返回值过程的返回值。\n\n   比如在下面的例子中，Line 2有一个多返回值过程，在Line 18调用它的时候，前两个返回值均为该过程运算后的结果，而第三个返回值则需要再与过程\`bar()\`进行运算。\n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\n\`\`\`\n\n2. 一个多返回值过程可以直接作为另一个多参数过程的参数。\n\n   例如在下面的代码中，Line 2中有两个返回值的过程直接成为了Line 23中有三个参数的过程的前两个参数。\n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\n\`\`\`\n\n3. 如果一个多返回值过程的返回语句是出现在分支语句中，那么一定要检查每个分支的返回值类型和数量是否统一。\n\n   比如在下面的代码中，\`bar()\`过程的返回值出现在Line 6 ~ Line 10，两个return语句的返回值均为u64，与过程声明的返回类型一致。\n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\n\`\`\`\n\n### 实战演习\n\n在\`BuildCastle\`模块中添加\`racial_judgment()\`过程，并实现其功能：根据序列号判断城堡所对应的种族，返回对应的初始经济实力与军事实力。\n\n1. 通过模运算和除法运算从序列号中截取出种族位（序列号的第7位）；\n2. 通过分支语句判断种族位所对应的经济实力与军事实力数值，种族位与实力值的对照关系如下表：\n\n|  种族位  | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------: | :--: | :--: | :--: | :--: | :--: |\n| 经济实力 |  6   |  8   |  3   |  7   |  4   |\n| 军事实力 |  6   |  3   |  8   |  4   |  7   |\n\n3. 该过程有两个\`u64\`返回值，一个是经济实力值，一个是军事实力值。\n\n提示：\n\n如何从n位数中截取第m位？\n\n- n位数Num，如果要取前x位，可通过取整除法Num / 10<sup>x</sup>，该运算得到的结果就是前x位所对应的数字，例如，54312 / 10<sup>5-2</sup>=54；\n- n位数Num，如果要取末x位，可通过模运算Num / 10<sup>n-x</sup>，该运算得到的余数就是末x位所对应的数字，例如，54312 / 10<sup>2</sup>=12；\n- n位数Num，如果要取中间x位，则先通过上述运算将问题转变为取前x位或取后x位，再进一步计算。\n\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //在这里输入代码\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "第六章 完善城堡设计",
            instruction: `## 第六章 完善城堡设计\n\n在第三章中我们学习了如何声明一个结构体，本章中我们将继续学习如何初始化一个结构体，并在\`main()\`过程中使用它。\n\n如下图所示，我们往往通过构造一个过程来实现结构体的初始化，并将结构体的声明与初始化过程写入同一个模块中，用于初始化结构体的过程所对应的返回值类型是结构体类型，并通过返回一个成员变量为初始值的结构体来实现结构体的初始化。\n\n<img src=${require("../../static/images/lesson2/pic_2_6_1_zh.png")} style="width:80%;position:relative;left:10%">\n\n例如：\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\n\`\`\`\n\n在这个例子中，我们在模块\`Bar\`中声明了一个结构体\`T\`，并通过名为\`new\`的过程将结构体的成员变量初始化为该过程的参数。\n\n在\`new\`过程中，我们返回了一个结构体\`T\`，其成员变量\`baz\`的值是该过程的参数\`m\`。\n\n注意，上述代码中Line 6 ~ Line 8形式上很像结构体的定义，但它是一个\`return\`语句，因此句末有一个分号。\n\n当我们要在\`main()\`过程或其他过程中使用结构体\`T\`时，可以通过\`let\`关键字将变量声明为结构体类型，并调用\`new\`过程进行初始化。\n\n例如：以下代码将变量\`x\`初始化为成员变量值等于10的结构体\`T\`：\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\n\`\`\`\n\n### 实战演习\n\n在之前的章节中，我们学习了**如何建立一个合约**，**Move中的模块**、**变量与数据类型及其所有权**，**Move中的过程及多返回值过程**，**Move中的程序结构**，**结构体的建立和使用**，**Move中的常用运算符** 等知识点，现在我们已经完成了建立城堡所需要的几个重要过程，接下来要把它们组合起来，并在\`main()\`过程中实现城堡的建立。\n\n1. 在\`BuildCastle\`模块中添加\`newCastle\`过程，用于初始化一个结构体\`Castle\`类型的变量，该过程有两个参数：\n\n   - \`_name (bytearray)\`：城堡名\n   - \`_SerialNum (u64)\`：城堡序列号\n\n   注意：为了与\`main()\`中的\`name\`和\`SerialNum\`有所区分，我们在参数名的前面加了下划线。\n\n   该过程有一个返回值，类型为\`Self.Castle\`。\n\n   请模仿课程中的示例，在该过程中根据上述参数（\`_name\`, \`_SerialNum\`）完成一个城堡数据的初始化。\n\n   提示：城堡的名字和序列号初始化为参数对应的值，城堡的等级初始化为1，城堡的经济实力和军事实力初始化为调用\`racial_judgment()\`过程所计算出的值。\n\n2. 在\`main()\`过程中，城堡的名字是由用户输入的，因此\`name\`这一参数是外部输入，我们需要给\`main()\`过程添加一个名为\`name\`的参数，其类型为\`bytearray\`。\n\n3. 在\`main()\`中添加\`castle\`变量并初始化，提醒：要记得把\`let\`语句插入到前面。\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //在这里输入代码\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n//修改这里\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //在这里输入代码\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //在这里输入代码\n    \n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial: "第3课",
    title: "",
    intro: ["在之前的课程中，我们已经建立了一个基础的城堡架构。在接下来的第三课中，我们将为城堡添砖加瓦，让它看起来更安全一些。","资源的概念;如何建立和销毁资源;如何建立一个多文件结构"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "第一章 资源",
            instruction: `## 第一章 资源 \n\n在现有的区块链系统中，比特币对"货币"进行编程，以太坊对"应用"进行编程，与之相比，Libra对"资产"进行编程，这种资产被称为 “资源”，是一种比货币更复杂的资产类型。\n\nMove规定，对资源的操作必须满足以下两个约束条件：\n\n- **稀缺性保障**：资源总量必须受控，不允许用户随意复制、重用或丢弃资源。\n- **访问控制**：对资源的访问必须满足某种预先定义的规则。\n\n为满足上述两个约束条件，在Move合约中，资源只能由定义该资源的模块创建或销毁，且只能接受\`move()\`操作，换句话说，我们不能用\`copy()\`复制资源。\n\nMove编译器通过字节码静态验证上述安全性约束是否被满足，它将拒绝运行未通过字节码验证的程序代码。\n\n对于初学者而言，可以暂且将资源理解为受限制的结构体。\n\n资源的声明与结构体类似，是通过\`resource 资源名{数据1: 类型, 数据2: 类型, ...}\`的方式声明。\n\n下面是对Libra币这一资源的声明示例：\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### 实战演习\n\n出于安全性的考虑，我们需要将城堡这一结构体修改为资源。\n\n1. 请将\`Castle\`的类型从结构体改为资源。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//修改这里的struct\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "第二章 资源的建立",
            instruction: `## 第二章 资源的建立\n\n为了使用资源，我们首先需要实现建立资源的过程，该过程的返回值类型为资源类型。\n\n例如，下面的代码就是上一课提到的\`LibraCoin\`的建立过程，该过程创建了一个值为0的资源变量\`T\`。\n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\n可以看出，资源的建立与结构体的初始化十分相似。\n\n### 实战演习\n\n接下来我们要实现建立资源的过程。\n\n本章中，我们将引入账户的概念，每个玩家都拥有一个账户，该账户有其对应的城堡，我们希望通过账户将城堡与玩家关联起来。\n\n我们将在之后的课程中介绍关于账户的具体功能及操作，本章暂时只建立和账户相关的模块与资源。\n\n1. 在\`BuildCastle\`模块下面建立名为\`CastleAccount\`的模块。\n\n2. 在新建的模块中声明\`CastleAccount\`资源，出于练习的目的，该资源暂时只有一个\`u64\`变量，变量名为\`a\`，我们会在以后要用到它的时候重新完善该资源。\n\n3. 实现建立\`CastleAccount\`资源的过程\`newAccount\`，该过程将资源中的变量\`a\`初始化为0。 \n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//在这里建立新模块\n//在模块中声明账户资源\n//在模块中实现建立账户的过程\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "第三章 资源的销毁",
            instruction: `## 第三章 资源的销毁\n\n因为Move语言中没有垃圾回收机制，因此资源使用完后，必须被显式地销毁。\n\n在Move代码中，我们通常通过\`Move()\`将资源的绑定置为空，从而实现资源的销毁。\n\n让我们来看一个简单的例子，这是\`LibraCoin\`的销毁过程：\n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n        T { value } = move(coin);\n        return;\n}\n\`\`\`\n\n在该过程中，我们首先在过程内部声明一个成员变量为\`value(u64)\`的局部资源变量\`T\`，接下来将我们要销毁的\`coin\`通过\`move()\`重新绑定到局部资源变量\`T\`。当过程结束时，局部资源变量\`T\`被自动销毁，而\`coin\`资源变成了没有绑定、也无法再被访问使用的资源。由于系统会将没有绑定的资源回收，这样资源\`coin\`就被销毁了。\n\n### 实战演习\n\n我们已经完成了\`Castle\`资源和\`CastleAccount\`资源的建立，接下来要实现它们的销毁过程。\n\n1. 在\`BuildCastle\`模块中建立\`desCastle\`过程，并仿照课程中的示例完成该过程，该过程的参数名为\`castle\`，过程中的临时变量名与之前的课程中所使用的保持一致。\n2. 在\`CastleAccount\`模块中建立\`desAccount\`过程，并仿照课程中的示例完成该过程，该过程的参数名为\`account\`，过程中的临时变量名为\`num\`。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    //在这里实现销毁资源Castle的过程\n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //在这里实现销毁资源CastleAccount的过程\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "第四章 资源的使用",
            instruction: `## 第四章 资源的使用\n\n在建立了资源之后，我们就可以使用资源啦。\n\n资源的使用与结构体几乎一样，不同的地方在于，我们需要在使用完资源后，销毁该资源。\n\n在本章中，我们假设仅在当前交易脚本中使用资源，暂时不把资源发送给某个地址，因此在\`main()\`结束前需要销毁资源。\n\n接下来，我们结合一个例子来理解资源的使用，并复习资源的建立与销毁。\n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\n在该实例中，我们声明了一个\`MoneyHolder\`模块，该模块中有一个资源\`T\`，该资源通过Line 5的过程建立，并通过Line 8的过程销毁。\n\n需要注意的是，资源T的成员变量也是一个资源。因此，在销毁\`T\`的时候，需要进行两次销毁（即Line 10和Line 11），其中，第二次销毁是调用了\`LibraCoin\`模块中销毁\`coin\`的过程\`LibraCoin.destroy_zero()\`。这些内容是前两章中所涉及的知识点，如果有所遗忘请及时复习。\n\n接下来，我们看该实例的\`script\`部分，\`main()\`过程中的前两行分别声明了两个资源变量，其中一个是\`LibraCoin.T\`，另一个是我们自己声明的\`MoneyHolder.T\`。在声明变量之后，我们随之要进行变量的初始化，因为未经初始化的变量无法被使用。\n\nLine 21中的\` LibraCoin.zero()\`是\`LibraCoin.T\`这一资源的初始化过程，该过程被定义在Libra官方的\`LibraCoin\`模块中，在此不进行分析。\n\nLine 22中的\`MoneyHolder.new(move(coin))\`是我们定义的建立资源过程，在通过该过程初始化\`money_holder\`后，就可以使用该变量啦。\n\n注意：这里的参数是\`move(coin)\`，而不是\`copy(coin)\`，即便在后面的内容中仍然想使用\`coin\`这一变量，我们依旧不能使用\`copy()\`，因为\`coin\`是资源，而资源只能\`move()\`，不能\`copy()\`。\n\n在本实例中，我们不对\`money_holder\`进行操作，因此接下来就需要销毁它，从而结束合约。注意，这里过程中的参数同样是要使用\`move()\`，而不能使用\`copy()\`。\n\n总体来说，使用资源的完整流程，是先通过\`let\`声明资源变量，再调用建立资源的过程初始化该变量，使用完以后调用销毁资源的过程来销毁变量，如下图所示。\n\n<img src=${require("../../static/images/lesson3/pic_3_4_1_zh.png")} style="width:80%;position:relative;left:10%">\n\n\n\n### 实战演习\n\n在前面的章节中，我们已经完成了城堡的建立和销毁过程，但此时该合约仍然无法顺利编译成功的，因为我们还需要在\`main()\`中完善资源的建立和销毁。\n\n注：由于账户资源暂时没有实际作用，我们先不在\`main()\`中调用它。如果需要使用\`CastleAccount\`资源，我们可以通过\`newAccount\`和\`desAccount\`来创建和销毁它。\n\n1. 在\`main()\`中加入销毁\`Castle\`资源的语句。\n\n`
,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //在这里输入代码\n\n    return;\n}",
                    answer:"modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "第五章 拆分文件",
            instruction: `## 第五章 拆分文件\n\n学到这一课时，相信你已经注意到我们的代码文件越来越长，我们希望把它分成多个文件以便于管理，增加代码的可读性。\n\n因此在这一章，我们清理了下右边的代码，现在你可以看到，编辑器的顶部多了几个选项卡，可以尝试单击标签来切换文件。\n\n可以看到，选项卡分为活动选项卡和固定选项卡，其中活动选项卡是可以编辑的，这也是我们实战演习中会修改并检查的文件，而固定选项卡是只读的，我们可以在学习的过程中查看，但不能对其进行修改。\n\n一般来说，我们会将一个模块放在一个文件中，然后在要使用它的地方通过\`import 地址.模块名\`的方式导入该模块，这是在第一课第二章中所介绍过的内容。这样，我们可以方便地维护、管理和更新不同的模块功能。\n\n### 实战演习\n\n我们已经建立了一个多文件的结构，并完成了模块的拆分，接下来请将之前完成的交易脚本部分加入到文件中。\n\n1. 请浏览已经建立好的模块，并在当前活动的选项卡中完成交易脚本的内容。\n\n`,
            type: 0, 
            codes:[ 
                {
                    title: "contract.mvir",
                    code:"//在这里输入代码",
                    answer:"import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code:"module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code:"module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code:"module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lesson4 = {
    lessonserial: "第4课",
    title: "",
    intro: ["在上一课中，我们让城堡变得更加安全了，但这还不够，我们还需要设计相应的访问控制，本课中，我们将继续加固城堡。","assert()的使用方法;内置命令中的get_txn_sender(),move_to_sender()和borrow_globla();借用和可变借用;acquires的用法;解引用的用法"],
    key: 4,
    total: 6,
    chapters: [
        {
            title: "第一章 资源的统计 ",
            instruction: `## 第一章 资源的统计 \n\n在上一课中，我们提到对资源的操作需要满足稀缺性保障和访问控制的特点。因此，作为玩家持有的最重要的资源——城堡，我们需要保障其合理数量以及访问权限。\n\n为实现上述目的，我们可以在系统中添加一个计数器变量，每当新建一个城堡时，就更新该变量的值，并为该变量设置一个访问权限，只有管理员才可以访问该变量。\n\n考虑到上述计数器变量需要安全性保障和访问权限的限制，我们将它的类型定义为资源，通过对资源的操作来实现一系列相关功能。（注：接下来的设计思路是模仿\`LibraCoin\`模块进行的，有兴趣的读者可以阅读该模块的代码。）\n\n### 实战演习\n\n首先，我们需要声明城堡总数的资源。\n\n1. 在\`BuildCastle\`模块中声明名为\`CastleSum\`的资源，该资源有一个\`u64\`成员变量\`sum\`。\n\n\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //在这里输入代码\n\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第二章 初始化过程的权限控制",
            instruction: `## 第二章 初始化过程的权限控制\n\n根据第三课，我们知道资源在使用前需要被初始化。因此，在声明了\`CastleSum\`资源后，我们需要初始化它，以便后续使用。此时，我们面临两个问题：\n\n1. 初始化\`CastleSum\`的过程应该仅允许管理员在区块链系统刚建立时调用一次。换句话说，我们需要实现初始化过程的权限控制；\n2. 该资源在初始化后应当被发送到管理员所对应的地址，而不是最后在交易脚本中被销毁掉。\n\n我们将在本章解决第一个问题，在下一章解决第二个问题。\n\n针对第一个问题，我们需要学习两个新的内联过程。\n\n### \`assert()\`\n\n\`assert()\`是一个在很多编程语言中被广泛使用的操作，其作用是检查“不应该”发生的情况。\`assert()\`常常被用于在函数开始处检验传入参数的合法性，以及在函数结束时，判断结果的正确性。（注：其他语言中的函数相当于Move语言中的过程）\n\n在Move语言中，\`assert()\`有两个参数，第一个参数是一个表达式，程序在运行到\`assert()\`这一句时，会检查该表达式是否成立，如果成立，则继续执行；反之，则终止程序并输出错误码，错误码的值为第二个参数。\n\n下面的例子是一个简单的\`assert()\`的示例。\n\n\`\`\`\nmain() {\n  assert(1 + 2 == 3, 99);\n  return;\n}\n\n\`\`\`\n\n在该例中，程序判定\`1+2\`是否为3。若是，则无任何信息输出，反之，则会输出错误码99。\n\n### \`get_txn_sender()\`\n\n在Move语言中，有许多用于访问系统数据的内置命令，\`get_txn_sender()\`是其中的一个，它的功能是获取当前交易发送方的地址。\n\n下面是一个使用实例： \n\n\`\`\`\nmain() {\n    let sender: address;\n    let addr: address;\n    sender = get_txn_sender();\n    addr = 0x0;\n    assert(copy(sender) != copy(addr), 42);\n    return;\n}\n\n\`\`\`\n\n从该例中可以看出，\`get_txn_sender()\`的返回值是一个\`address\`型变量，我们通过\`变量名 = get_txn_sender()\`的方式将当前执行\`main()\`的账户地址赋值给一个\`address\`型变量。\n\n\n\n### 实战演习\n\n接下来，我们要建立初始化城堡总量的过程，并将该过程限制为只允许管理员账户调用。\n\n1. 在\`BuildCastle\`模块的\`desCastle()\`过程下面声明初始化城堡总量这一资源的过程，名为\`iniCastleSum()\`，该过程为公有过程，没有返回值。\n2. 通过\`assert()\`和\`get_txn_sender()\`的结合实现资源的权限控制。具体来说，通过\`assert()\`来判断当前的账户地址是否与管理员地址一致，如果不一致，则抛出错误信息并终止程序。这里，我们假设管理员账户地址为\`0x0000000\`，错误码为1。\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    //在这里输入代码\n\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第三章 资源的发送 ",
            instruction: `## 第三章 资源的发送 \n\n接下来，我们要完成将资源\`CastleSum\`发送到管理员地址，该操作可以通过\`move_to_sender()\`来实现。\n\n\`move_to_sender()\`是一个模块操作，它的作用是将一个资源发送到当前账户对应的地址存储，使用形式如下：\n\n\`move_to_sender<n>(e)\`，\n\n其中，\`n\`是资源类型，\`e\`是资源表达式。在解释该操作之前，我们首先要介绍一下泛型\`<>\`。\n\n### 泛型 \n\n泛型是程序设计语言的一种特性，它允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，这些可变部分在使用前必须作出指明。\n\n简单来说，我们可以通过泛型来使得一个过程可以同时被多种类型的变量使用，而不需要修改过程本身的代码。\n\n例如，一个实现了访问资源A的过程，在不使用泛型时，它的返回值类型是资源A的类型。此时，如果我们希望对资源B进行同样的操作，就需要再次声明一个内容完全相同、只有返回值不同的过程。这样的代码对开发人员来说是无意义的重复工作，并增加了代码的复杂性和冗余度。如果在这种情况下，我们使用泛型，那么相同的过程只需要完成一次，在具体调用时指明资源类型就可以在所有的资源上进行相同的操作。\n\n因此，泛型可以理解为把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。泛型为开发者提供了一种高性能的编程方式，能够提高代码的重用性和类型的安全性。\n\n在本章中，我们暂且先不考虑如何实现泛型过程，只考虑如何使用它。在Move语言中使用泛型的方式很简单：\`过程名<类型>(参数表达式)\`\n\n### \`move_to_sender()\`\n\n我们通过一个例子来具体地学习\`move_to_sender()\`。\n\n\`\`\`\npublic initialize() {\n        assert(get_txn_sender() == 0xA550C18, 1);\n        move_to_sender<MintCapability>(MintCapability{});\n        move_to_sender<MarketCap>(MarketCap { total_value: 0 });\n        return;\n}\n\`\`\`\n\n这是\`LibraCoin\`中对市场总量的初始化过程。Line 2通过\`assert()\`来判断当前账户是否为管理员账户，这是上一章中学到的知识点。Line 3和Line 4都是对\`move_to_sender()\`的使用，这两行分别将资源\`MintCapability\`和资源\`MarketCap\`发送到当前账户对应的地址，其中\`MintCapability\`是一个无成员变量的资源，它表示挖矿权限，而\`MarketCap\`的成员变量\`total_value\`则被初始化为0。\n\n总体来说，上述过程首先检查当前账户是否为管理员账户，如果是，则将挖矿权限赋予当前账户，并将市场容量（即当前系统中的所有\`LibraCoin\`的总和）置为0，并发送市场容量到当前账户。\n\n### 实战演习\n\n最后，我们要初始化城堡总数的资源，并将该资源发送给管理员账户。\n\n1. 在\`iniCastleSum()\`过程中通过\`move_to_sender()\`将我们已经声明过的\`CastleSum\`资源初始化为0，并发送给当前账户（即管理员账户，地址为\`0x0000000\`）。记得在过程结束时添加\`return\`。\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        //在这里输入代码\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第四章 借用 ",
            instruction: `## 第四章 借用 \n\n在实现了城堡总量的初始化后，我们希望可以随时查看当前系统中一共有多少个城堡。\n\n这样的功能乍一看很容易实现，只需要访问\`CastleSum\`资源并输出其成员变量\`sum\`的值即可。但是要注意，我们已经知道，资源不能被\`copy()\`，只能被\`move()\`，当我们将\`CastleSum\`通过\`move()\`传入访问它的过程时，原本的资源变量将失去所有权，这就导致我们每访问一次，都需要重新将\`CastleSum\`重新初始化并发送到管理员账户——这显然是极其不合理的。\n\n所有权一方面提高了资源的安全性，另一方面也使得访问和改变资源的值变得十分困难。面对这样的问题，Libra Move引入借用的概念。\n\n<u>借用是指对所有权的借用</u>，又被称作引用，它的机制很像我们在其他语言中学习到的“读写锁”，即同一时刻，只能拥有一个“写锁”，或只能拥有多个“读锁”，不允许“写锁”和“读锁”在同一时刻同时出现。\n\nMove语言会在编译的时候检查借用的安全性，而不是运行时检查，这也避免了出现死锁、野指针等问题。\n\nMove通过\`&\`来实现借用。例如：\n\n\`\`\`\nmain() {\n    let x: u64;\n    let x_ref: &u64;\n    let y: u64;\n    x = 5;\n    x_ref = &x;\n    //y = copy(x);	//error\n    _ = move(x_ref);\n    y = copy(x);	//correct\n    return;\n}\n\`\`\`\n\n从这段代码中我们可以看出，声明一个借用的方式是：\`let 借用变量名: &借用变量类型\`。\n\n在声明借用后，就可以通过\`借用变量名: = &被借用变量名\`来实现借用。\n\n在借用期间，原变量的所有权被借走，我们无法在此期间通过\`copy()\`或其他方式来访问原变量。\n\n类似于资源需要显式销毁一样，借用是需要归还的，我们同样需要在不再使用借用时，或者在\`main()\`结束之前，显式地解除借用。\n\n例如，在这段代码中，我们通过\`_ = move(x_ref);\`来解除借用，其中\`_\`表示Move语言中的临时变量，这项操作将\`x_ref\`的所有权转移给临时变量，而临时变量会在使用结束后自动销毁，这样就解除了\`x_ref\`的借用。 \n\n \n\n### 可变借用\`mut\`\n\n像“读写锁”机制分为“读锁”和“写锁”一样，借用也分为“可变借用\`&mut\`”与“不可变借用\`&\`”。\n\n可变借用可以在借用期间修改原始变量的值，而不可变借用则只能读取。\n\n同一时刻，一个变量最多只有一个可变借用，或者有多个不可变借用，但是两种借用不能同时出现。\n\n例如，下面的例子是能成功编译的，而如果我们将\`x_ref = &x;\`改为\`x_ref = &mut x;\`，则会导致编译无法通过。\n\n\`\`\`\nmain() {\n    let x: u64;\n    let x_ref: &u64;\n    let x_ref2: &u64;\n    x = 5;\n    x_ref = &x;	//correct\n    //x_ref = &mut x;	//error\n    x_ref2 = &x;	\n    _ = move(x_ref);\n    _ = move(x_ref2);\n    return;\n}\n\`\`\`\n\n\n\n### 实战演习\n\n接下来，我们要建立查看当前系统中一共有多少个城堡的过程。\n\n1. 在\`BuildCastle\`模块声明一个名为\`castlesum()\`的过程，该过程无参数，返回值是一个\`u64\`型变量，表示城堡总数，注意这里为了与前面所声明的\`CastleSum\`资源区分开，过程名我们全使用小写字母；\n2. 在该过程的第一行声明一个名为\`CastleSum_ref\`的可变借用资源变量，我们将在之后几章中完善它的使用。\n\n\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    //在这里输入代码\n\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第五章 borrow_global()",
            instruction: `## 第五章 \`borrow_global()\`\n\n在第三章中，我们学习了\`move_to_sender()\`的用法，本章中我们将介绍另一个模块操作：\`borrow_global()\`。\n\n\`borrow_global()\`也是一个实现了泛型的过程，参数是一个\`address\`变量，作用是全局借用，会返回指定地址下的对应类型的资源的**可变借用**。\n\n\`borrow_global()\`的具体使用格式为：\`借用资源名=borrow_global<所需资源名>(地址)\`。例如：\`x_ref = borrow_global<T>(0x0000)\`将地址\`0x0000\`的\`T\`资源借用给\`x_ref\`变量。\n\n很显然，\`borrow_global()\`要求目标地址必须拥有所需借用的资源，如果目标地址没有该资源，则借用将失败。\n\n也就是说，一旦我们会在过程中使用\`borrow_global()\`，我们需要在过程的一开始就告诉Move编译器这个过程将会借用什么样的资源，Move语言通过\`acquires T\`来实现这一操作。\n\n### \`acquires\`\n\n\`acquires\`可以理解为一个注释，它告诉字节码验证器当前过程（或其中调用的过程）会从全局状态借用或移动哪些资源类型，这些注释允许字节码验证器确保在全局状态下不存在对值的悬挂引用。\n\n注：悬挂引用是指当两个指针同时指向一个地址时，通过一个指针删除了该地址的数据，另一个指针出现指向空地址的问题。\n\n从编程角度来说，我们需要在以下三种情况使用\`acquires\`：\n\n1. 使用\`borrow_global<T>\`；\n2. 使用\`move_from<T>\`；（我们将在之后的课程中介绍）\n3. 过程中调用了需要\`acquires T\`的过程。\n\n接下来让我们通过一个例子来学习\`acquires\`的使用：\n\n\`\`\`\nmodule A {\n    resource T1{v: u64}\n    public test(addr: address) acquires T1 {\n        let x: &mut Self.T1;\n        x = borrow_global<T1>(get_txn_sender());\n        _ = move(x);\n        return;\n    }\n}\n\`\`\`\n\n该例中，我们从调用过程的地址借用\`T1\`资源，并存储在\`x\`中，由于使用了\`borrow_global<T1>\`，我们需要在过程的开始检查资源\`T1\`是否存在，因此在声明过程的那一行最后写了\`acquires T1\`。\n\n（本章内容参考： https://community.libra.org/t/how-could-i-understand-the-keyword-acquires/1832 ）\n\n### 实战演习\n\n1. 在声明了可变借用后，通过\`borrow_global()\`对\`CastleSum_ref\`进行初始化，其参数为管理员地址，暂定为\`0x0000000\`；\n2. 由于使用了\`borrow_global()\`，因此还需要在该过程的声明部分添加\`acquires\`语句。\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    //在这里添加acquires\n    public castlesum(): u64\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        //在这里输入代码\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global<CastleSum>(0x0000000);\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "第六章 解引用 ",
            instruction: `## 第六章 解引用 \n\n如果你比较熟悉C语言，那么在看到前文中的借用\`&\`时，相信你也一定能想到解引用\`*\`。Move语言中也同样可以进行解引用，其用法与C语言中的十分接近。\n\n解引用(\`Deref\`)是引用(\`Ref\`)的反操作。\n\n在Move语言中，与给定结构（比如结构体或者资源）的字段交互的唯一方法是引用。因此，为了访问结构中的某些值，我们必须先对该字段进行引用，再通过解引用来创建一个绑定到该字段的值的新变量。\n\n简单来说就是，我们可以通过借用\`&\`获取资源的引用，然后通过解引用\`*\`获取该引用的值。\n\n\`\`\`\nfield_ref = &move(rsc).field;\nfield_value = *move(field_ref);\n\`\`\`\n\n当我们需要访问某个资源时，我们可以将借用和解引用组合起来使用，也就是\`*&\`，这样就能获取到某个资源的值，并可以在借用结束后归还所有权。\n\n例如，使用\`*&move(T).value\`，我们可以获取到资源\`T\`中名为\`value\`的成员变量值，当借用结束后，该资源及其成员变量的所有权不会被改变。\n\n最后，我们通过分析\`*&move(rsc).field\`总结一下常用的三个对变量和字段的操作：\`move()\`、\`&\`和\`*\`。\n\n\`*&move(rsc).field\`是一个由三部分指令组合起来的操作：变量的\`move()\`、对某一字段的借用和从借用中读取值。\n\n1. \`move(rsc)\`\n\n   每次访问一个局部变量时，我们都可以对它进行\`move()\`或者\`copy()\`操作。如果使用\`copy()\`，则意味着我们获取了该变量的一个副本；如果使用\`move()\`，则意味着我们转移了该值的所有权，在为该局部变量分配新值之前，不能再次访问它。\n\n2. \`&move(rsc).field\`\n\n   这是对一个字段的借用操作。访问一个结构中某字段的唯一方法是引用。在该操作中，原本对\`move(rsc)\`的引用被扩展为对字段\`field\`的引用，具体来说，我们当前所引用的内容不再是\`move(rsc)\`，而变成了\`field\`。\n\n3. \`*&move(rsc).field\`\n\n   这是一个解引用操作，它从一个借用中读取值。当我们进行解引用时，原本的借用并不会被改变，而是得到一个该借用的值的副本。具体来说，就是当前所访问的内容从\`&move(rsc).field\`变成了该值的副本。\n\n\n（本章内容参考： https://community.libra.org/t/meaning/1253/2 ）\n\n### 实战演习\n\n最后，我们需要获取城堡总数的数值，并将其返回。\n\n1. 通过\`*&\`获取\`CastleSum_ref\`这一资源中成员变量的值，并将其作为过程的返回值。\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global<CastleSum>(0x0000000);\n        //在这里输入代码\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        ]
}

const lessons = [lesson1, lesson2, lesson3, lesson4];

export default lessons;

