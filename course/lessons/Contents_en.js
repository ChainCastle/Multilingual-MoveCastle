import React from 'react';
import L1c1 from './L1C1/L1C1'

const lesson1 = {
    info: {
        name: "Move Castle",
        subname: ["Learning Libra Move within 7 days", "*Based on Libra Commit 61649eb"],
        intro: "In the existing blockchain system, with \"currency\" and \"application\" programmed by Bitcoin and Ethereum respectively, Libra, by contrast, programs \"asset\".\n\nIn Libra,  one can define some types of assets called \"resources\" that are more complex than currency. Libra prevents inappropriate modifications by limiting resource utilization with Move programming language, thereby improving asset security.\n\nMove provides a secure and programmable foundation for Libra blockchain. The way that Move programs  \"assets\" with strict  security restrictions makes it suitable for issuing digital currencies, processing blockchain transactions and managing validators.\n\nIn this course, we build a castle by using Move programming language, implementing castle expansion and battle functions to help beginners learn the language much more effectively.",
        goback: "←Back",
        editor: "Editor",
        lesson: "Lesson",
        copyAnswer: "Copy Answer",
        learnmore: "Learn More",
        start: "Start",
        indexpage:"https://learnlibramove.com/",
        learninide:["The code in the course can be compiled in ChainIDE","Go to ChainIDE"],
        practice: "Start Now",
    },
    local: {
        hint: "HINT",
        previous: "PREVIOUS",
        next: "NEXT",
        catalog: "CONTENT",
        checkcode: "Check Answer",
        showAnswer: "Show Answer",
        hideAnswer: "Hide Answer",
        contitle: ["Congratulations that you have completed this chapter!", "Congratulations that you have completed this LESSON!", "KEEP GOING!"],
        concontent: ["Click \"Continue\" to meet new challenges !", "Click \"Back\" to back to the catalog page ! Click \"Go to ChainIDE\" to practice in it!", "Hi~ congratulations, you have completed all the lessons of the course now. More lessons will be presented soon. Now let's go to ChainIDE and write our own Libra Move contracts to have fun !"],
        concontinue: ["Continue", "Back", "Go to ChainIDE", "Next Lesson"],
        shut: "close",
        target: "Introduction",
        keypoint: "Knowledge Points",
        detail: "View Details"
    },
    lessonserial: "Lesson 1",
    title: "",
    intro: ["In Lesson 1, we will guide you to build your own castle world in a step-by-step way. Your castle will have a unique appearance with unexpected creatures living in it.","How to create a contract;Modules in Move;main() in Move;Variables and data type;Procedures in Move"]
    ,
    key: 1,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 Introduction",
            instruction: `## Chapter 1 Introduction\n\nIn this chapter, we will learn how to build a castle.\n\n​	- We will use modules to build a new castle\n\n​	- Our castle will be stored in the database, i.e., Libra Blockchain\n\nIn the following, we will add more functions to our castle, such as enhancing its power, fighting with other castles. But before that, we should first realize the function of creating a castle.\n\n### What are the properties of the castle?\n\nEach castle has its name, serial number, level, economic  and military powers. The serial number determines the appearance of the castle and the race of creatures in the castle. The level determines the value of the castle. The economic and military powers affect the performance of the castle when interacting with other castles.\n\n### How does the serial number affect the castle?\n\nThe appearance of a castle and its race are decided by an 8-digit integer, which is named as the serial number, such as 83451029.\n\nEach digit of the serial number corresponds to a property of the castle. In particular,\n\n|  1   |   2   |   3   |     4      |     5      |       6       |  7   |     8      |\n| :--: | :---: | :---: | :--------: | :--------: | :-----------: | :--: | :--------: |\n| size | style | color | logo style | logo color | logo position | race | special ID |\n\nThe name of each newly built castle is input by the user; the serial number is randomly generated according to the depth of the current block; the level is initialized as 1; the initial economic and military powers are determined by the race digit in the serial number. The corresponding relationships are defined as follows:\n\n|   Race digit   | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------------: | :--: | :--: | :--: | :--: | :--: |\n| Economic power |  6   |  8   |  3   |  7   |  4   |\n| Military power |  6   |  3   |  8   |  4   |  7   |\n\n### Practical Exercise\n\n1. Please drag the slider on the right side of the page to explore the appearance of the castle corresponding to a specific serial number.\n\n\n **With the above basic knowledge, you can click the Next Chapter button to continue learning Move.**\n\n\n`,
            type: 1, 
            show() {
                return <L1c1 lang="1" />
            }
        },
        {
            title: "Chapter 2 Modules in a Contract",
            instruction: `## Chapter 2 Modules in a Contract\n\nA contract is a computer program that runs on a blockchain. We use a contract to complete a series of operations on the blockchain, such as transferring money, purchasing goods, and so on.\n\nThe overall code of a contract in Move is divided into the following two parts:\n\n​	\- module part starting with modules:\n\n​	\- \`main()\` starting with script:\n\nWe'll introduce the modules section in this chapter and the script section in the next.\n\n### Modules\n\nThe module part contains the modules needed for a contract. A module is the basic package unit of the Move contract and all modules deployed on Libra are global.\n\nIn a module, we can define \`Struct\`, \`Resource\` and \`Procedure\`, which will be introduced in subsequent chapters.\n\nThe module is similar to the smart contract in Ethereum, as well as the class in Java. We can regard the module as a code block with a certain function, which uses the interface to access the internal information of the module.\n\nFor example, the \`Libracoin\` module is officially released by Libra, which defines Libra Coin and has the process of transferring  Libra Coin as well as recharge. After the developer introduces the module, the interface can be used to implement related functions.\n\n#### How to build a module\n\nWe create a module with the format of \`module module_name { }\`.\n\n#### How to import a module\n\nSimilar to \`package name + class name\` in java, Move employs \`address + module name\` to import a module. For example,\n\n\`import 0x0.LibraCoin\`\n\nwhere \`LibraCoin\` is the module name and  \`0x0\` is the account address for publishing the module.  Each user can publish his or her own module on the blockchain, or import modules published by others in this way. The address of all modules published by Libra are \`0x0\`.\n\nWhen importing modules from the same file, we can use \`import Transaction.module name\` to achieve this goal. For example,\n\n\`import Transaction.LibraCoin\`\n\n### Practical Exercise\n\nTo build our castle, we'll start with a module called \`BuildCastle\`, in which we'll gradually implement a series of castle building functions.\n\n1. Build an empty module \`BuildCastle\`\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "//Enter the code here",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "Chapter 3 main() in a Contract",
            instruction: `## Chapter 3 \`main()\` in a Contract\n\n### main()\n\nWe learned how to build a module in the previous chapter, and we will complete the contract based on the module in this chapter. \n\nWe can embed a piece of one-time execution code in a contract, which is called Transaction Script and cannot be called by other codes. The Transaction Script starts with \`script:\`.\n\n\`main()\` is the entry to execute the transaction script. We name code blocks like \`main()\` as \"procedures\" and will detail their concepts in subsequent chapters. \`main()\` is actually a special procedure.\n\nNote that all procedures, including \`main()\`, should end with \`return\`. Move compiler is literal: it will translate the source code directly without doing anything else, such as inserting a missing \`return\`.\n\nWhen writing the Move contract, we usually write all operations in the ordinary procedures rather than  \`main()\`, and put the ordinary procedures into the modules. Finally, we import the modules in the script section,  calling the procedures in the module with \`main()\` as the entrance to complete a series of operations. The overall idea is shown in the figure below.\n\n<img src=${require("../static/images/lesson1/pic_1_2_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\nNotice that when we need to import other modules in a module, the import statement should appear at the first line of the module, i.e., the next line of the module name. And when we need to import a module in the script section, the import statement should appear at the first line of this section, i.e., the next line of \`script:\`, and the first line of \`main()\`.\n\nIn summary, we present a basic example of an empty contract as follows:\n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### Practical Exercise\n\nIn order to build our castle, we first need create an empty contract including a module named \`BuildCastle\` and \`main()\`.\n\n1. First, add \`modules:\` and \`script:\`;\n3. Add \`main()\` in the next line of \`script:\`. Remember to add \`return\` in \`main()\`;\n4. Import the module in the script section (at the line before \`main()\`).\n\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "//Enter the code here\nmodule BuildCastle {\n\n}\n//Enter the code here\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 4  Variable binding and data type",
            instruction: `## Chapter 4  Variable binding and data type\n\n### Variable binding\n\nVariable binding refers to binding some values to a variable so that they can be used later.\n\nSimilar to Rust, Move uses \`let\` to bind variables, which follows the format of  \`let variable: variable type;\`. For example,\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\nAfter variable binding, we can use \`=\` to initialize the variable. For example,\n\n\`\`\`\nx = 5;\n\`\`\`\n\nIt is worth noting that  variables should be bound at first in any process.  In other words, all \`let\` lines should be put at the very beginning; otherwise, inserting any \`let\` line within the code block will lead to the compilation error.\n\n### Data Types\n\nAt present, Move supports the following data types:\n\n​	\- \`boolean\`\n\n​	\- \`uint64\`\n\n​	\- \`address\`\n\n​	\- \`bytes\`\n\n​	\- \`struct\`\n\n​	\- \`resource\` (a unique data type in Move)\n\nwhere boolean-type data should be declared as \`bool\`, uint64-type data should be declared as \`u64\`, address-type data as \`address\`, and bytes-type data as \`bytearray\`. For example, we can declare variables as follows:\n\n\`\`\`\nmain() {\n    //Variable bindings\n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //Initialize\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h \"123abc\";\n    return;\n}\n\`\`\`\n\nWe can also declare resource and struct as follows:\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\nwhere \`f1\` and \`f2\` are two variables.\n\nNote that since Move cannot automatically initialize variables, we should not use variables without initialization.\n\n### Practical Exercise\n\nThe serial number of a castle serial consists of an 8-digit number, so we use a modulo operation (\`%\`) to limit the randomly generated serial numbers to 8-bit integers.  Before that, we first need a variable called \`SerialDigits\`, which is used to represent the number of digits in a serial number. This is the main task in this chapter.\n\nIn the process of \`main()\`, we declare \`SerialDigits\` as \`u64\` and initialize it as 8.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 Procedures",
            instruction: `## Chapter 5 Procedures\n\nAs mentioned in Chapter 2,  \`procedures\` can be defined in modules, which are similar to \`functions\` in other programming languages.\n\n### Declaration of a Procedure\n\nTo declare a procedure, we need to declare its visibility, name, parameters, and return value(s) in the following format:\n\n\`Visibility Process name (parameter name): The type of return value\`\n\nIt should be noted that in the case where the procedure has no parameter, there is no need to declare the parameter name; in the case of no return value, there is no need to declare the return type.\n\nThe process in the module has two kinds of visibility:\n\n​	\- public: public procedures can be called by other modules\n\n​	\- private: private procedures can only be called by procedures in the same module. The resources in the module are private and can only be accessed by other modules through public procedures.\n\nWhen the procedure to be declared has neither parameters nor return values, it should be declared in the following format:\n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\nWhen the procedure to be declared has parameters, we should declare it as:\n\n\`\`\`\npublic Procedure(a: u64, b: u64) { //The form is similar when the types of parameters are different or when there are more (or fewer) parameters\n    return;\n}\n\n\n\`\`\`\n\nNote that the procedure itself can also be employed a parameter of other procedures .\n\nIf the procedure to be declared has return values, it should be declared as:<u></u>\n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 { //The form is similiar When type of the return value is different\n    return 1;\n}\n\n\n\`\`\`\n\nIn the above examples, we only define public procedures. If you want to declare a private procedure, then just delete \`public\`.\n\n### Call a Procedure \n\nA procedure is called by \`module name.procedure name\`. If a procedure  needs to be called by another procedure in the same module,  we should use the format of  \`Self.procedure name\`.\n\nThe following is an example of declaring and calling a procedure:\n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //A public procedure is declared whose name is Procedure\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //Call the procedure whose module name is Contract\n    return;\n}\n\n\n\`\`\`\n\n### Practical Exercise\n\nAs mentioned in the previous chapter,  we will use the modulo operation (\`%\`) to convert the serial number to an 8-bit integer. Specifically, a number modulo 10<sup>n</sup> results in an n-digit integer, so here we employ a procedure to calculate 10<sup>8</sup>. \n\n1. Create a \`Math\` module before the \`BuildCastle\` module, which will include all the math operations in this course.\n\n2. Declare the procedure \`pow()\` to conduct the power operation in the newly created module as follows:\n\n   ​    \- Parameters: the base x and the exponent n of type \`u64\`\n\n   ​    \- Return value: the power operation result of type \`u64\`\n\n   ​    \- Process content: temporarily empty. In order to compile successfully, let's set its return value as 1. We will implement its function in the next chapter.\n\n3. Import the \`Math\` module before \`main()\` and declare a \`u64\` variable named \`SerialLimit\` after \`SerialDigits\`, which represents the number of digits in the serial number.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \n//Enter the code here\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//Enter the code here\n\nmain() {\n    let SerialDigits: u64;\n    //Enter the code here\n\n    SerialDigits = 8;\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
    ]
};

const lesson2 = {
    lessonserial: "Lesson 2",
    title: "",
    intro: ["In the first lesson, we have learned variable-related operations, successfully declaring the serial number of a castle, which lays the first cornerstone for establishing the castle. In Lesson 2, we will guide you to build the framework of the castle,  creating your own castle world. ","Ownership;Program structs  in Move;Structures;Arithmetic operations;Procedures with multiple return values"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "Chapter 1 Ownership",
            instruction: `## Chapter 1 Ownership\n\n### The usage of ownership\n\nIn the previous chapters, we mentioned the word \"binding\". In fact,the word refers to binding of ownership. Only when an identifier has  the ownership of some value can we access this value through the identifier.\n\nWhen binding a value to a name (an identifier), we bind the ownership of this value (resource) to the identifier. For example:\n\n\`\`\`\nlet x: u64;\nx = 3;\n\n\`\`\`\n\nWhen we bind the resource with type (\`u64\`) and value (\`3\`) to identifier \`x\` through the statement \`let\`, \`x\` has the ownership of this resource, during which the identifier retains exclusive ownership of the resource, such as accessing and changing its value. However,  the identifier will no longer have value ownership once the binding has been transferred to another identifier.\n\n### The transfer of ownership\n\nWhen we are going to transfer ownership, we have to use \`move()\` function, instead of equal sign (\`=\`), to implement for reasons of memory safety.\n\nThat is, in Move, identifiers can’t be connected with equal sign (\`=\`), which can only be used between identifiers and values. For example,the following code is incorrect:\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //error\n\n\`\`\`\n\nWe give an example to illustrate how to transfer ownership as follows:\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); //Move the ownership of 3 from identifier x to identifier y.\nz = move(x); //error: now, the identifier x has lost ownership and is an uninitialized variable, so move(x) fails\nz = move(y); //Move the ownership of 3 from identifier y to identifier z.\nx = 3; 	//Reinitialize the identifier x.\nz = move(x); //At this point, the ownership of 3 can be transferred from identifier x to identifier z by move().\n\n\`\`\`\n\n### The copy of ownership\n\nBy using \`copy()\` function, the value of an identifier is able to equal to that of another identifier without transferring the ownership.  In this case,  the identifier can still be accessed even after implemented by the function \`copy()\` .  For instance, \n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); //Copy the onwship of 3 from identifier x to identifier y.\nz = move(x); //Move the onwship of 3 from identifier x to identifier z.\n\n\`\`\`\n\nIt should be noted that when calling a procedure and passing in parameters, we are not allowed to use the parameters directly. Instead, we need transfer ownership to the procedure by using functions of \`move (the parameter name)\` or \`copy(the parameter name) \`, and which one should be implemented depends on how to use the parameters.\n\n### Practical Exercise\n\nIn the previous lesson we declared \`SerialLimit\`. In this chapter,  we would like to set the value of this parameter to 10<sup>SerialDigits</sup>, thereby calling \`pow()\` function to initialize \`SerialLimit\`, which has two parameters, 10 and \`SerialDigits\` respectively.\n\nThe task above requires passing a variable as a parameter to the \`pow()\` procedure, which involves the ownership transfer. Considering \`SerialDigits\` may be used again in the following chapters,  we use \`copy()\` function instead. At this point the \`pow()\` function is still undefined, which will be implemented in the next chapter.\n\nThe parameter \`SerialLimit\` will be initialized by calling the \`pow()\` function in the \`main()\` procedure, in the form of \`module name.function name\`, which has been introduced in the previous chapter. You’d better review if you have forgotten.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 2 The structs of a program",
            instruction:`## Chapter 2 The structs of a program\n\nSimilar to other languages, Move also has common program structures such as selection and looping.\n\nWe can implement simple selection structure by using if-else statement, with the following specific rules:\n\n1. The branch statements must be enclosed in braces ( \`{}\` ), even if there is only one statement. The following example is incorrect:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;	//Here x = 3 should be in {}.\n       return;\n   }\n   \n   \`\`\`\n\n2. There’s no need for braces to end with semicolon that is added to the end of each branch statement. The following example is also incorrect:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;\n       else {\n           x = 5\n       };	//The semicolon here should appear at the end of the previous line.\n       return;\n   }\n   \n   \`\`\`\n\n3. If an identifier is initialized in a branch statement that doesn’t contain all cases, the identifier can’t be accessed after the branch ends. The example as follow is wrong:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       }	//Here, the variable x is initialized only in the if branch, whereas in the case of the else branch, it is uninitialized. so we cannot use copy(x) later.\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \n   \`\`\`\n\n   With the branch containing all cases, the identifier can be accessed after the end of the branch, as shown in the following example:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } else {\n           x = 43;\n       }	//The two branches here contain true and false, which means that the variable x will be initialized no matter what happens. So we can use copy(x) later\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \n   \`\`\`\n\n4. When using the move() function in a branch statement, make sure to be aware of ownership problem. The identifier implemented by this function shouldn’t be accessed again after the branch ends. The following example is incorrect:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       let y: u64;\n       x = 0;\n       if (true) {\n           y = move(x);	//In this branch we transfer ownership of the variable x to the variable y, so in the following code, we cannot access the variable x again by copy(x).\n       }\n       assert(copy(x) == 0, 42);\n       return;\n   }\n   \n   \`\`\`\n\nWe can also implement the looping structure through \`loop\`. This chapter is not going to give detailed information due to limited space, and that will be introduced in subsequent chapter.\n\n### Practical Exercise\n\nRecursion is the most common way to implement power function. Here is an example of power function in C language as follow:\n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\n\n\`\`\`\n\nPlease emulate the above program and implement the \`pow()\` function in the \`Math\` module, paying attention to variable ownership problem and using  \`copy()\` and \`move()\` functions appropriately.\n\n\n`
,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //Enter the code here\n        \n        return 1; //Delete the code here\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 3 Structs",
            instruction: `## Chapter 3 Structs\n\nStructure in Move, similar to that in other languages, is a data set consisting of a collection of data with the same or different types . We can declare a structure in the form of \`struct name{data: type, data: type, ...}.  \`For instance,\n\n\`\`\`\nmodule Test {\n	//Empty struct\n  	struct Empty1 { }\n  	//Struct with two members\n  	struct T { a: u64, b: u64 }\n}\n\n\`\`\`\n\nNote:\n\n- Structures can only be declared at the very beginning of a module rahter than in a procedure\n- Structures can also be implemented by \`copy ()\` or \`move ()\` functions\n\nMore on structures will be introduced and covered in subsequent chapters.\n\n### Practical Exercise\n\nPlease declare a structure named \`Castle\` in the \`BuildCastle\` module, which contains five members: \`name (bytearray)\`, \`SerialNum (u64)\`, \`level (u64)\`, \`economic (u64)\` and \`military (u64)\`.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//Enter the code here\n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 4  Arithmetic operations",
            instruction: `## Chapter 4  Arithmetic operations\n\nIn the previous sections, we have used some basic arithmetic operations, such as addition and multiplication. In this chapter, we will take a closer look at  the arithmetic operations that Move has implemented.\n\nAt present, Move has realized the following arithmetic operations: addition \`+\`, subtraction \`-\`, multiplication \`*\`, division \`/\` and module \`%\`. The specific examples of using them are as follows:\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\n\n\`\`\`\n\nMove has also implemented the comparison operations, such as  greater than \`>\`, less than \`<\`, equal to \`==\`, greater than or equal to \`>=\`, less than or equal to \`<=\` and not equal to \`!=\`. The corresponding examples are detailed as: \n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\n\n\`\`\`\n\nIn addition, several kinds of bit operations and boolean operations are also implemented in Move. We will introduce them in the following chapters in detail.\n\n### Practical Exercise\n\nIn our game, the serial number of a castle is randomly generated according to the height of the current block. \n\nThe most basic algorithm to generate random number is implemented by the modular operation.\n\nThe following is an example that implements a simple pseudo-random number using C programming language. Obviously, the sequence of random numbers produced by such a program depends on the initial value of next.\n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\n\`\`\`\n\nThrough slightly modifying the above procedure, we can get the following program that generates a random number according to the input seed: \n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\n\`\`\`\n\nIn the same way as in any other language, we can take advantage of modular operations to make our program eventually generate random numbers within a specified range. In detail, to generate random numbers from m to n,  we can use the following code:\n\n\`\`\`c\nmyrand(seed) % (n - m + 1) + m;\n\n\`\`\`\n\n1. Following the above random number generation program, please add the random number generation procedure \`myrand()\` in the \`Math\` module, and then implement its specific functions.\n2. Please add and implement the public procedure \`generateSerial()\` in the \`BulidCastle\` module, which calls the \`myrand\` procedure in the \`Math\` module to generate a random 8-bit serial number (i.e., a random number between 10^<sup>7</sup>and 10<sup>8-1</sup>) based on the height of the current block.\n   - The height of the current block can be obtained by the \`get_current_height()\` method in the \`Block\` module.\n   - The address of the module \`Block\` is \`0x0\`.\n   - Import \`Math\` and \`Block\` modules in the correct places.\n3. Declare \`SerialNum\` in main() and initialize it through the \`generateSerial()\` procedure.\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //Enter the code here\n    \n}\n\nmodule BuildCastle {\n    //Enter the code here\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //Enter the code here\n    \n}\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //Enter the code here\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 Procedures with multiple return values",
            instruction: `## Chapter 5 Procedures with multiple return values\n\nIn Chapter 5, we introduced the procedure and illustrated how to use the procedure with a single return value. However, in many scenarios, we need to use a procedure with multiple return values, which will be introduced in this chapter.\n\nAccording to Chapter 5, we can declare a procedure with a single return value as follows:\n\n\`\`\`\npublic procedure name( parameter name 1，parameter name 2，...) : reture type {...}\n\n\`\`\`\n\nSimilarly, we take the procedure with two return values as an example, which can be declared as follows:\n\n\`\`\`\npublic procedure name( parameter name 1，parameter name 2，...) : reture type * reture type {...}\n\n\`\`\`\n\nAnd the calling method is:\n\n\`\`\`\nvariable 1, variable 2, ...  = module name.procedure name( parameter name 1，parameter name 2，... )\n\n\`\`\`\n\nWhen using the procedures with multiple return values, we need to pay attention to the following points:\n\n1. When a procedure with multiple return values is operated with another one having a single return value, only the last return value of the first procedure is involved.\n\n   Take the following code as an example, when Line 2 is called in Line 18 as a procedure with multiple return values, the first two return values are the operation results of this procedure while the last one should be derived after operating with the procedure \`bar()\`.\n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\n\`\`\`\n\n2. A procedure with multiple return values can function as  a parameter of another procedure with multiple parameters.\n\n   For example, in the following code block, the procedure with multiple return values in Line 2 becomes the first two parameters in the procedure in Line 25 with three parameters. \n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\n\`\`\`\n\n3. If the Return statement of a procedure with multiple return values apprears at a Switch statement, it is necessary to check that whether the type and number of return values in each branch are uniform.\n\n   For example, the return value of the procedure \`bar()\` appears in Lines 6 ~10, and both return values are with type \`u64\`, which is consistent with the return type when declaring the procedure.\n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\n\n\`\`\`\n\n### Practical Exercise\n\nAdd the \`racial_judgment()\` procedure to the \`BuildCastle\` module and realize its function: determine the race of the castle based on the serial number, and return the corresponding initial economic  and military powers.\n\n1. Extract the race digit from the serial number, i.e., the 7th digit of the serial number, by modulo and division operations;\n2. Determine the economic and military powers corresponding to the race through the Switch statement, where the relationship between the race and the values of two powers is as follows:\n\n|   race digit   | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------------: | :--: | :--: | :--: | :--: | :--: |\n| economic power |  6   |  8   |  3   |  7   |  4   |\n| military power |  6   |  3   |  8   |  4   |  7   |\n\n3. This procedure has two return values in type u64, one for economic power and the other for military power.\n\nTips: How to extract the m-th digit from an n-digit number?\n\n- For an n-digit Num, if you want to extract the first x digits, you can use rounding division Num / 10<sup>n-x</sup>. The result of this operation is the number corresponding to the first x digits. For example, 54312 / 10<sup>5-2</sup>=54;\n- For an n-digit Num, if you want to extract the last x digits, you can use the modulo operation Num / 10<sup>x</sup>, whose r is the number corresponding to the last x digits. For example, 54312 % 10<sup>2</sup> =12;\n- For an n-digit Num, if you want to take the middle x digits, you should convert the problem to one of the above two problems, and then further calculate the final result.\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //Enter the code here\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 6 Refine the design of a castle",
            instruction: `## Chapter 6 Refine the design of a castle\n\nIn Chapter 3, we learned how to declare a struct. In this chapter, we will continue to learn how to initialize a struct and use it in the \`main()\` procedure.\n\nAs shown in the figure below, we often create a procedure to initialize a struct, which should be declared and initialized in the same module. The return value of the procedure used to initialize the struct is with struct type, which initializes the struct by returning a struct with initial member variable values. \n\n<img src=${require("../static/images/lesson2/pic_2_6_1_en.png")} style="width:80%;position:relative;left:10%">\n\nFor example,\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\n\`\`\`\n\nIn this example, we declare a struct \`T\` in the module \`Bar\` and initialize the member variables of the struct with the parameters of the procedure by a procedure named new.\n\nIn the new procedure, we return a struct \`T\` whose value of the member variable \`baz\` is the parameter \`m\` of the procedure.\n\nNote that in the above code, the codes from Line 6 to Line 8 are formally similar to the definition of a struct, which is actually a  return statement. Therefore,  there is a semicolon at the end of it.\n\nWhen we want to use struct \`T\` in \`main()\` or other procedures, we can declare the variable as a struct type using let statement and call the new procedure to initialize it. \n\nFor example, the following code initializes the variable \`x\` to a struct \`T\` with a member variable value 10.\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\n\n\`\`\`\n\n### Practical Exercise\n\nIn the previous chapters, we have learned several important processes to build a castle, so the next step is to combine them and build the castle in the \`main()\` procedure.\n\n1. Add the \`newCastle\` procedure to the \`BuildCastle\` module to initialize a struct-type \`Castle\` variable, where the procedure has two parameters:\n\n   - \`_name (bytearray)\`, indicating the name of our castle\n   - \`_SerialNum (u64)\`, identifying the serial number of the castle\n\n   Note: In order to distinguish from the name and \`SerialNum\` in \`main()\`, we put an underscore in front of the above parameter names.\n\n   This procedure has a return value of type \`Self.Castle\`.\n\n   Please follow the example in our course to initialize a castle based on two parameters，namely \`_name\`, and \`_SerialNum\`.\n\n   Tips: the castle's name and serial number are initialized to the corresponding values. In addition, the castle's level is initialized to 1. And the castle's economic and military powers are initialized to the values calculated by calling the \`racial_judgment()\` procedure.\n\n2. In the main procedure, the name of the castle is entered by the user, so the name parameter is an external input. In this case, we need to add a parameter named name to the \`main()\` procedure with the type bytearray. \n\n3. Add the castle variable to \`main()\` and initialize it. Note: Remember to insert the let statement in the beginning.\n\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //Enter the code here\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n//Modify the content here\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //Enter the code here\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial: "Lesson 3",
    title: "",
    intro: ["In the previous lessons, we have created a basic castle framework. In the third lesson, we are going to build a fortified castle. ","The concept of resources;How to create and destroy resources;How to create a multi-file structure"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 Resources",
            instruction: `## Chapter 1 Resources\n\nIn the existing Blockchain systems, Bitcoin programs “currencies” and Ethereum programs “applications”; Libra, by contrast, programs “assets”, named as “resources”, which are a more complex assets type than currencies.\n\nMove stipulates that the operation of resources has to meet the following two constraints:\n\n- **Scarcity guarantee**:  The total amount of resources must be under control and users are not allowed to copy, reuse or discard resources arbitrarily.\n\n- **Access control**: Resource access must satisfy certain predefined rules.\n\nTo meet the above two constraints, in a Move contract, a resource can only be created or destroyed by the module that defines it and can only be operated with the  \`move()\` function. That is, we are not allowed to replicate resources with the \`copy()\` function.\n\nMove compiler statically verifies that if the above security constraints are met through bytecode, which will refuse to run a program failed to pass the bytecode validation.\n\nFor beginners, a resource can be regarded as a restricted structure for the time being.\n\nDeclaration of a resource is similar to that of a structure: \`resource name {data: type, data: type, ...} \`.\n\nHere is an instance of declaring the \`LibraCoin\` resource: \n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### **Practical exercise**\n\nFor security reasons, we require the castle structure to be modified into a resource.\n\n1. Please change the type of \`Castle\` from structure to resource.\n\n   \n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//Modify the \"struct\" here\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 2  Resource Creation",
            instruction: `## Chapter 2  Resource Creation\n\nTo use a resource, we first need to implement the procedure of creating a resource, the return value type of which is resource.\n\nFor example, the following code creates the procedure \`LibraCoin\` mentioned in the previous lesson, which creates a resource variable \`T\` with a value of 0. \n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\nAs you can see, the creation of resource is similar to the initialization of structure. \n\n### **Practical exercise**\n\nNext we are going to implement the procedure of creating resources. \n\nIn this chapter, we will introduce the concept of 'account',  where each player has an account with corresponding castle. By this means, we associate the castle with the player.  \n\nSpecific functions and operations of an account will be introduced in subsequent courses. This chapter only focuses on creating modules and resources related to the account. \n\n1. Create a module named \`CastleAccount\` below the \`BuildCastle\` module.\n2. Declare  the \`CastleAccount\` resource in the newly created module. For practice, the resource only has one \`u64\` variable named \`a\` for now, which we will refine in the following chapters.\n3. Implement the procedure \`newAccount\` to create the \`CastleAccount\` resource, which initializes the variable \`a\` in the resource to 0.\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//Enter the code here\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Chapter 3 Resource Destruction",
            instruction: `## Chapter 3 Resource Destruction\n\nFor the reason that there is no garbage collection mechanism in Move, resources have to be explicitly destroyed after used.\n\nIn Move, a resource is usually destroyed by setting the resource's binding to null through the \`move()\` function.\n\nLet's take a look at a simple instance as follows, which is the destruction procedure for \`LibraCoin\` :\n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n        T { value } = move(coin);\n        return;\n}\n\`\`\`\n\nIn this procedure, we first declare a local resource variable \`T\` with a member variable \`value(u64)\`, and then rebind the resource \`coin\`, which we want to destroy, to the local resource variable \`T\` through the \`move()\` function. At the end of the procedure, the local resource variable\`T\`  will be automatically destroyed. Consequently, the \`coin\`resource becomes unbound and can no longer be accessed. Since the system will recycle unbound resources, destruction of the resource \`coin\` is achieved as a result.\n\n\n\n### **Practical exercise**\n\nNow that we have created the \`Castle\` and the \`CastleAccount\` resources, we are about to implement their destruction procedures.\n\n1. Create the \`desCastle\` procedure in the \`BuildCastle\` module according to the example in this lesson. The parameter name in this procedure is \`castle\` and the temporary variable name is the same as that used in the previous lesson.\n2. Create the \`desAccount\` procedure in the \`CastleAccount\` module according to the example in this lesson. The parameter name in this procedure is \`account\` and we name the temporary variable \`num\`.\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    //Enter the code here\n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //Enter the code here\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Chapter 4 Resource Usage",
            instruction: `## Chapter 4 Resource Usage\n\nWith the resources created, we can use them now.\n\nUsage on resources is almost the same as that on structures, except that we are supposed to destroy a resource after having used it.\n\nIn this chapter, we assume that resources are only used in the current transaction script and will not be sent to any address for the time being, which means that the resources need to be destroyed at the end of  \`main()\`.\n\nNext we are going to understand how to use resources with an example as well as review the creation and destruction of resources.\n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\nIn this instance, we declare a module named \`MoneyHolder\` with a resource \`T\` that is created with the procedure in Line 5 and destroyed through the procedure in Line 8.\n\nIt should be noted that the member variable of resource \`T\` is also a resource. Therefore, when destroying \`T\`, two destructions (Line 10 and Line 11) are required, where the second destruction is to call the \`LibraCoin.destroy_zero()\` procedure in the \`LibraCoin\` module to destroy \`coin\`.  What have been mentioned above is the knowledge points involved in the first two chapters. If you have something forgotten, please go back to review them.\n\nNext let’s look at the \`script\` part of this instance. The first two lines in the \`main()\` procedure declare two resource variables, one of which is \`LibraCoin.T\` and the other is \`MoneyHolder.T\` declared by us. After declaring the variables, we will then initialize them on the ground that uninitialized variables cannot be operated.\n\nThe function\`LibraCoin.zero()\` in Line 21 aims  to initialize the resource \`LibraCoin.T\`, which is defined in Libra's official \`LibraCoin\` module and won’t be further analyzed here.\n\n\`MoneyHolder.new(move(coin))\` in Line 22 is the resource creation procedure we defined to initialize \`money_holder\`,  so that we can  use this variable now. \n\nNote: The argument here is \`move(coin)\` instead of \`copy(coin)\`. Even if you might want to use the \`coin\` variable in the following,  you are still not allowed to use the \`copy()\` function, for the reason that \`coin\` is a resource and resources can only be operated by the \`move()\` function rather than the \`copy()\` function.\n\nIn this instance, we are not going to implement any operations on \`money_holder\`, and thereby the next step is to destroy it before terminating the contract. Note that the parameters in this procedure also use the \`move()\` function, instead of \`copy()\`.\n\nIn general, to use a resource, we should first declare the resource variable through  the\`let\` statement, then call the resource creation procedure to initialize the variable, and finally implement the destruction process to destroy it when we have finished to use the resource, as shown in the following figure.\n\n<img src=${require("../static/images/lesson3/pic_3_4_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n### **Practical exercise**\n\nIn the previous chapter, while we have completed the procedures of creating and destroying the castle, the contract still cannot be compiled successfully, since we are also required to refine  the resource creation and destruction in the \`main()\` procedure.\n\nNote: Since the account resource has no practical effect for the time being, we will not call it in \`main()\` here. If the \`CastleAccount\` resource needs to be used, we are able to create or destroy it with the\`newAccount\` and \`desAccount\` functions respectively.\n\n1. Add a statement to destroy the \`Castle\` resource in \`main()\`.\n\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //Enter the code here\n\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 Splitting files",
            instruction: `## Chapter 5 Splitting files\n\nBy the time you are here, I believe that you have noticed that the file is getting longer and longer. Thus, it’d be better if we divide it into multiple files for the sake of efficient management and readability improvement.\n\nIn this chapter, we have cleaned up the code on the right. Now as you can see, there are a few more tabs at the top of the editor and you are free to click on each tab to switch files.\n\nAs shown above, the tabs are divided into active and fixed tabs. The active tabs are editable, which are also the files that we are going to modify and check in practical exercise. While the fixed tabs are read-only, it is implied that we are entitled to check the files in the studying process but not allowed to make modifications.\n\nTypically, we place a module in a file and then import it by\`import address.module name\`, as described in Chapter 2 of Lesson 1. In this way, it is more convenient for us to maintain, manage and update different module functions.\n\n### **Practical exercise**\n\nNow that we have created a multi-file structure and split the module, please add the previously completed transaction script part to the file.\n\n1. Please browse through the created module and complete the transaction script in the current active tab.`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "//Enter the code here",
                    answer: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lessons = [lesson1, lesson2, lesson3];

export default lessons;

