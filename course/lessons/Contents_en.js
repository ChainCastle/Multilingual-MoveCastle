import React from 'react';
import L1c1 from '../L1C1/L1C1'
import L6c1 from '../L6C1/L6C1'

const lesson1 = {
    info: {
        name: "Move Castle",
        subname: ["Learning Libra Move within 7 days", "*Based on Libra Commit 61649eb"],
        intro: "In the existing blockchain system, with \"currency\" and \"application\" programmed by Bitcoin and Ethereum respectively, Libra, by contrast, programs \"asset\".\n\nIn Libra,  one can define some types of assets called \"resources\" that are more complex than currency. Libra prevents inappropriate modifications by limiting resource utilization with Move programming language, thereby improving asset security.\n\nMove provides a secure and programmable foundation for Libra blockchain. The way that Move programs  \"assets\" with strict  security restrictions makes it suitable for issuing digital currencies, processing blockchain transactions and managing validators.\n\nIn this course, we build a castle by using Move programming language, implementing castle expansion and battle functions to help beginners learn the language much more effectively.",
        goback: "←Back",
        editor: "Editor",
        lesson: "Lesson",
        copyAnswer: "Copy Answer",
        learnmore: "Learn More",
        start: "Start",
        indexpage:"https://learnlibramove.com/",
        learninide:["The code in the course can be compiled in ChainIDE","Go to ChainIDE"],
        practice: "Start Now",
    },
    local: {
        hint: "HINT",
        previous: "PREVIOUS",
        next: "NEXT",
        catalog: "CONTENT",
        checkcode: "Check Answer",
        showAnswer: "Show Answer",
        hideAnswer: "Hide Answer",
        contitle: ["Congratulations that you have completed this chapter!", "Congratulations that you have completed this LESSON!", "KEEP GOING!"],
        concontent: ["Click \"Continue\" to meet new challenges !", "Click \"Back\" to back to the catalog page ! Click \"next lesson\" to continue to learn new knowledge about the Libra!", "Hi~ congratulations, you have completed all the lessons of the course now. More lessons will be presented soon. Now let's go to ChainIDE and write our own Libra Move contracts to have fun !"],
        concontinue: ["Continue", "Back", "Go to ChainIDE", "Next Lesson"],
        shut: "close",
        target: "Introduction",
        keypoint: "Knowledge Points",
        detail: "View Details"
    },
    lessonserial: "Lesson 1",
    title: "",
    intro: ["In Lesson 1, we will guide you to build your own castle world in a step-by-step way. Your castle will have a unique appearance with unexpected creatures living in it.","How to create a contract;Modules in Move;main() in Move;Variables and data type;Procedures in Move"]
    ,
    key: 1,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 Introduction",
            instruction: `## Chapter 1 Introduction\n\nIn this chapter, we will learn how to build a castle.\n\n​	- We will use modules to build a new castle\n\n​	- Our castle will be stored in the database, i.e., Libra Blockchain\n\nIn the following, we will add more functions to our castle, such as enhancing its power, fighting with other castles. But before that, we should first realize the function of creating a castle.\n\n### What are the properties of the castle?\n\nEach castle has its name, serial number, level, economic  and military powers. The serial number determines the appearance of the castle and the race of creatures in the castle. The level determines the value of the castle. The economic and military powers affect the performance of the castle when interacting with other castles.\n\n### How does the serial number affect the castle?\n\nThe appearance of a castle and its race are decided by an 8-digit integer, which is named as the serial number, such as 83451029.\n\nEach digit of the serial number corresponds to a property of the castle. In particular,\n\n|  1   |   2   |   3   |     4      |     5      |       6       |  7   |     8      |\n| :--: | :---: | :---: | :--------: | :--------: | :-----------: | :--: | :--------: |\n| size | style | color | logo style | logo color | logo position | race | special ID |\n\nThe name of each newly built castle is input by the user; the serial number is randomly generated according to the depth of the current block; the level is initialized as 1; the initial economic and military powers are determined by the race digit in the serial number. The corresponding relationships are defined as follows:\n\n|   Race digit   | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------------: | :--: | :--: | :--: | :--: | :--: |\n| Economic power |  6   |  8   |  3   |  7   |  4   |\n| Military power |  6   |  3   |  8   |  4   |  7   |\n\n### Practical Exercise\n\n1. Please drag the slider on the right side of the page to explore the appearance of the castle corresponding to a specific serial number.\n\n\n **With the above basic knowledge, you can click the Next Chapter button to continue learning Move.**\n\n\n`,
            type: 1, 
            show() {
                return <L1c1 lang="1" />
            }
        },
        {
            title: "Chapter 2 Modules in a Contract",
            instruction: `## Chapter 2 Modules in a Contract\n\nA contract is a computer program that runs on a blockchain. We use a contract to complete a series of operations on the blockchain, such as transferring money, purchasing goods, and so on.\n\nThe overall code of a contract in Move is divided into the following two parts:\n\n​	- module part starting with modules:\n\n​	- \`main()\` starting with script:\n\nWe'll introduce the modules section in this chapter and the script section in the next.\n\n### Modules\n\nThe module part contains the modules needed for a contract. A module is the basic package unit of the Move contract and all modules deployed on Libra are global.\n\nIn a module, we can define \`Struct\`, \`Resource\` and \`Procedure\`, which will be introduced in subsequent chapters.\n\nThe module is similar to the smart contract in Ethereum, as well as the class in Java. We can regard the module as a code block with a certain function, which uses the interface to access the internal information of the module.\n\nFor example, the \`Libracoin\` module is officially released by Libra, which defines Libra Coin and has the process of transferring  Libra Coin as well as recharge. After the developer introduces the module, the interface can be used to implement related functions.\n\n#### How to build a module\n\nWe create a module with the format of \`module module_name { }\`.\n\n#### How to import a module\n\nSimilar to \`package name + class name\` in java, Move employs \`address + module name\` to import a module. For example,\n\n\`import 0x0.LibraCoin\`\n\nwhere \`LibraCoin\` is the module name and  \`0x0\` is the account address for publishing the module.  Each user can publish his or her own module on the blockchain, or import modules published by others in this way. The address of all modules published by Libra are \`0x0\`.\n\nWhen importing modules from the same file, we can use \`import Transaction.module name\` to achieve this goal. For example,\n\n\`import Transaction.LibraCoin\`\n\n### Practical Exercise\n\nTo build our castle, we'll start with a module called \`BuildCastle\`, in which we'll gradually implement a series of castle building functions.\n\n1. Build an empty module \`BuildCastle\`\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "//Enter the code here",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "Chapter 3 main() in a Contract",
            instruction: `## Chapter 3 \`main()\` in a Contract\n\n### main()\n\nWe learned how to build a module in the previous chapter, and we will complete the contract based on the module in this chapter. \n\nWe can embed a piece of one-time execution code in a contract, which is called Transaction Script and cannot be called by other codes. The Transaction Script starts with \`script:\`.\n\n\`main()\` is the entry to execute the transaction script. We name code blocks like \`main()\` as \"procedures\" and will detail their concepts in subsequent chapters. \`main()\` is actually a special procedure.\n\nNote that all procedures, including \`main()\`, should end with \`return\`. Move compiler is literal: it will translate the source code directly without doing anything else, such as inserting a missing \`return\`.\n\nWhen writing the Move contract, we usually write all operations in the ordinary procedures rather than  \`main()\`, and put the ordinary procedures into the modules. Finally, we import the modules in the script section,  calling the procedures in the module with \`main()\` as the entrance to complete a series of operations. The overall idea is shown in the figure below.\n\n<img src=${require("../../static/images/lesson1/pic_1_2_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\nNotice that when we need to import other modules in a module, the import statement should appear at the first line of the module, i.e., the next line of the module name. And when we need to import a module in the script section, the import statement should appear at the first line of this section, i.e., the next line of \`script:\`, and the first line of \`main()\`.\n\nIn summary, we present a basic example of an empty contract as follows:\n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### Practical Exercise\n\nIn order to build our castle, we first need create an empty contract including a module named \`BuildCastle\` and \`main()\`.\n\n1. First, add \`modules:\` and \`script:\`;\n3. Add \`main()\` in the next line of \`script:\`. Remember to add \`return\` in \`main()\`;\n4. Import the module in the script section (at the line before \`main()\`).\n\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "//Enter the code here\nmodule BuildCastle {\n\n}\n//Enter the code here\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 4  Variable binding and data type",
            instruction: `## Chapter 4  Variable binding and data type\n\n### Variable binding\n\nVariable binding refers to binding some values to a variable so that they can be used later.\n\nSimilar to Rust, Move uses \`let\` to bind variables, which follows the format of  \`let variable: variable type;\`. For example,\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\nAfter variable binding, we can use \`=\` to initialize the variable. For example,\n\n\`\`\`\nx = 5;\n\`\`\`\n\nIt is worth noting that  variables should be bound at first in any process.  In other words, all \`let\` lines should be put at the very beginning; otherwise, inserting any \`let\` line within the code block will lead to the compilation error.\n\n### Data Types\n\nAt present, Move supports the following data types:\n\n​	- \`boolean\`\n\n​	- \`uint64\`\n\n​	- \`address\`\n\n​	- \`bytes\`\n\n​	- \`struct\`\n\n​	- \`resource\` (a unique data type in Move)\n\nwhere boolean-type data should be declared as \`bool\`, uint64-type data should be declared as \`u64\`, address-type data as \`address\`, and bytes-type data as \`bytearray\`. For example, we can declare variables as follows:\n\n\`\`\`\nmain() {\n    //Variable bindings\n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //Initialize\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h \"123abc\";\n    return;\n}\n\`\`\`\n\nWe can also declare resource and struct as follows:\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\nwhere \`f1\` and \`f2\` are two variables.\n\nNote that since Move cannot automatically initialize variables, we should not use variables without initialization.\n\n### Practical Exercise\n\nThe serial number of a castle serial consists of an 8-digit number, so we use a modulo operation (\`%\`) to limit the randomly generated serial numbers to 8-bit integers.  Before that, we first need a variable called \`SerialDigits\`, which is used to represent the number of digits in a serial number. This is the main task in this chapter.\n\nIn the process of \`main()\`, we declare \`SerialDigits\` as \`u64\` and initialize it as 8.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 Procedures",
            instruction: `## Chapter 5 Procedures\n\nAs mentioned in Chapter 2,  \`procedures\` can be defined in modules, which are similar to \`functions\` in other programming languages.\n\n### Declaration of a Procedure\n\nTo declare a procedure, we need to declare its visibility, name, parameters, and return value(s) in the following format:\n\n\`Visibility Process name (parameter name): The type of return value\`\n\nIt should be noted that in the case where the procedure has no parameter, there is no need to declare the parameter name; in the case of no return value, there is no need to declare the return type.\n\nThe process in the module has two kinds of visibility:\n\n​	- public: public procedures can be called by other modules\n\n​	- private: private procedures can only be called by procedures in the same module. The resources in the module are private and can only be accessed by other modules through public procedures.\n\nWhen the procedure to be declared has neither parameters nor return values, it should be declared in the following format:\n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\nWhen the procedure to be declared has parameters, we should declare it as:\n\n\`\`\`\npublic Procedure(a: u64, b: u64) { //The form is similar when the types of parameters are different or when there are more (or fewer) parameters\n    return;\n}\n\n\n\`\`\`\n\nNote that the procedure itself can also be employed a parameter of other procedures .\n\nIf the procedure to be declared has return values, it should be declared as:<u></u>\n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 { //The form is similiar When type of the return value is different\n    return 1;\n}\n\n\n\`\`\`\n\nIn the above examples, we only define public procedures. If you want to declare a private procedure, then just delete \`public\`.\n\n### Call a Procedure \n\nA procedure is called by \`module name.procedure name\`. If a procedure  needs to be called by another procedure in the same module,  we should use the format of  \`Self.procedure name\`.\n\nThe following is an example of declaring and calling a procedure:\n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //A public procedure is declared whose name is Procedure\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //Call the procedure whose module name is Contract\n    return;\n}\n\n\n\`\`\`\n\n### Practical Exercise\n\nAs mentioned in the previous chapter,  we will use the modulo operation (\`%\`) to convert the serial number to an 8-bit integer. Specifically, a number modulo 10<sup>n</sup> results in an n-digit integer, so here we employ a procedure to calculate 10<sup>8</sup>. \n\n1. Create a \`Math\` module before the \`BuildCastle\` module, which will include all the math operations in this course.\n\n2. Declare the procedure \`pow()\` to conduct the power operation in the newly created module as follows:\n\n   ​    - Parameters: the base x and the exponent n of type \`u64\`\n\n   ​    - Return value: the power operation result of type \`u64\`\n\n   ​    - Process content: temporarily empty. In order to compile successfully, let's set its return value as 1. We will implement its function in the next chapter.\n\n3. Import the \`Math\` module before \`main()\` and declare a \`u64\` variable named \`SerialLimit\` after \`SerialDigits\`, which represents the number of digits in the serial number.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \n//Enter the code here\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//Enter the code here\n\nmain() {\n    let SerialDigits: u64;\n    //Enter the code here\n\n    SerialDigits = 8;\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
    ]
};

const lesson2 = {
    lessonserial: "Lesson 2",
    title: "",
    intro: ["In the first lesson, we have learned variable-related operations, successfully declaring the serial number of a castle, which lays the first cornerstone for establishing the castle. In Lesson 2, we will guide you to build the framework of the castle,  creating your own castle world. ","Ownership;Program structs  in Move;Structures;Arithmetic operations;Procedures with multiple return values"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "Chapter 1 Ownership",
            instruction: `## Chapter 1 Ownership\n\n### The usage of ownership\n\nIn the previous chapters, we mentioned the word \"binding\". In fact,the word refers to binding of ownership. Only when an identifier has  the ownership of some value can we access this value through the identifier.\n\nWhen binding a value to a name (an identifier), we bind the ownership of this value (resource) to the identifier. For example:\n\n\`\`\`\nlet x: u64;\nx = 3;\n\n\`\`\`\n\nWhen we bind the resource with type (\`u64\`) and value (\`3\`) to identifier \`x\` through the statement \`let\`, \`x\` has the ownership of this resource, during which the identifier retains exclusive ownership of the resource, such as accessing and changing its value. However,  the identifier will no longer have value ownership once the binding has been transferred to another identifier.\n\n### The transfer of ownership\n\nWhen we are going to transfer ownership, we have to use \`move()\` function, instead of equal sign (\`=\`), to implement for reasons of memory safety.\n\nThat is, in Move, identifiers can’t be connected with equal sign (\`=\`), which can only be used between identifiers and values. For example,the following code is incorrect:\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //error\n\n\`\`\`\n\nWe give an example to illustrate how to transfer ownership as follows:\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); //Move the ownership of 3 from identifier x to identifier y.\nz = move(x); //error: now, the identifier x has lost ownership and is an uninitialized variable, so move(x) fails\nz = move(y); //Move the ownership of 3 from identifier y to identifier z.\nx = 3; 	//Reinitialize the identifier x.\nz = move(x); //At this point, the ownership of 3 can be transferred from identifier x to identifier z by move().\n\n\`\`\`\n\n### The copy of ownership\n\nBy using \`copy()\` function, the value of an identifier is able to equal to that of another identifier without transferring the ownership.  In this case,  the identifier can still be accessed even after implemented by the function \`copy()\` .  For instance, \n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); //Copy the onwship of 3 from identifier x to identifier y.\nz = move(x); //Move the onwship of 3 from identifier x to identifier z.\n\n\`\`\`\n\nIt should be noted that when calling a procedure and passing in parameters, we are not allowed to use the parameters directly. Instead, we need transfer ownership to the procedure by using functions of \`move (the parameter name)\` or \`copy(the parameter name) \`, and which one should be implemented depends on how to use the parameters.\n\n### Practical Exercise\n\nIn the previous lesson we declared \`SerialLimit\`. In this chapter,  we would like to set the value of this parameter to 10<sup>SerialDigits</sup>, thereby calling \`pow()\` function to initialize \`SerialLimit\`, which has two parameters, 10 and \`SerialDigits\` respectively.\n\nThe task above requires passing a variable as a parameter to the \`pow()\` procedure, which involves the ownership transfer. Considering \`SerialDigits\` may be used again in the following chapters,  we use \`copy()\` function instead. At this point the \`pow()\` function is still undefined, which will be implemented in the next chapter.\n\nThe parameter \`SerialLimit\` will be initialized by calling the \`pow()\` function in the \`main()\` procedure, in the form of \`module name.function name\`, which has been introduced in the previous chapter. You’d better review if you have forgotten.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 2 The structs of a program",
            instruction:`## Chapter 2 The structs of a program\n\nSimilar to other languages, Move also has common program structures such as selection and looping.\n\nWe can implement simple selection structure by using if-else statement, with the following specific rules:\n\n1. The branch statements must be enclosed in braces ( \`{}\` ), even if there is only one statement. The following example is incorrect:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;	//Here x = 3 should be in {}.\n       return;\n   }\n   \n   \`\`\`\n\n2. There’s no need for braces to end with semicolon that is added to the end of each branch statement. The following example is also incorrect:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;\n       else {\n           x = 5\n       };	//The semicolon here should appear at the end of the previous line.\n       return;\n   }\n   \n   \`\`\`\n\n3. If an identifier is initialized in a branch statement that doesn’t contain all cases, the identifier can’t be accessed after the branch ends. The example as follow is wrong:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       }	//Here, the variable x is initialized only in the if branch, whereas in the case of the else branch, it is uninitialized. so we cannot use copy(x) later.\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \n   \`\`\`\n\n   With the branch containing all cases, the identifier can be accessed after the end of the branch, as shown in the following example:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } else {\n           x = 43;\n       }	//The two branches here contain true and false, which means that the variable x will be initialized no matter what happens. So we can use copy(x) later\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \n   \`\`\`\n\n4. When using the move() function in a branch statement, make sure to be aware of ownership problem. The identifier implemented by this function shouldn’t be accessed again after the branch ends. The following example is incorrect:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       let y: u64;\n       x = 0;\n       if (true) {\n           y = move(x);	//In this branch we transfer ownership of the variable x to the variable y, so in the following code, we cannot access the variable x again by copy(x).\n       }\n       assert(copy(x) == 0, 42);\n       return;\n   }\n   \n   \`\`\`\n\nWe can also implement the looping structure through \`loop\`. This chapter is not going to give detailed information due to limited space, and that will be introduced in subsequent chapter.\n\n### Practical Exercise\n\nRecursion is the most common way to implement power function. Here is an example of power function in C language as follow:\n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\n\n\`\`\`\n\nPlease emulate the above program and implement the \`pow()\` function in the \`Math\` module, paying attention to variable ownership problem and using  \`copy()\` and \`move()\` functions appropriately.\n\n\n`
,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //Enter the code here\n        \n        return 1; //Delete the code here\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 3 Structs",
            instruction: `## Chapter 3 Structs\n\nStructure in Move, similar to that in other languages, is a data set consisting of a collection of data with the same or different types . We can declare a structure in the form of \`struct name{data: type, data: type, ...}.  \`For instance,\n\n\`\`\`\nmodule Test {\n	//Empty struct\n  	struct Empty1 { }\n  	//Struct with two members\n  	struct T { a: u64, b: u64 }\n}\n\n\`\`\`\n\nNote:\n\n- Structures can only be declared at the very beginning of a module rahter than in a procedure\n- Structures can also be implemented by \`copy ()\` or \`move ()\` functions\n\nMore on structures will be introduced and covered in subsequent chapters.\n\n### Practical Exercise\n\nPlease declare a structure named \`Castle\` in the \`BuildCastle\` module, which contains five members: \`name (bytearray)\`, \`SerialNum (u64)\`, \`level (u64)\`, \`economic (u64)\` and \`military (u64)\`.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//Enter the code here\n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 4  Arithmetic operations",
            instruction: `## Chapter 4  Arithmetic operations\n\nIn the previous sections, we have used some basic arithmetic operations, such as addition and multiplication. In this chapter, we will take a closer look at  the arithmetic operations that Move has implemented.\n\nAt present, Move has realized the following arithmetic operations: addition \`+\`, subtraction \`-\`, multiplication \`*\`, division \`/\` and module \`%\`. The specific examples of using them are as follows:\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\n\n\`\`\`\n\nMove has also implemented the comparison operations, such as  greater than \`>\`, less than \`<\`, equal to \`==\`, greater than or equal to \`>=\`, less than or equal to \`<=\` and not equal to \`!=\`. The corresponding examples are detailed as: \n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\n\n\`\`\`\n\nIn addition, several kinds of bit operations and boolean operations are also implemented in Move. We will introduce them in the following chapters in detail.\n\n### Practical Exercise\n\nIn our game, the serial number of a castle is randomly generated according to the height of the current block. \n\nThe most basic algorithm to generate random number is implemented by the modular operation.\n\nThe following is an example that implements a simple pseudo-random number using C programming language. Obviously, the sequence of random numbers produced by such a program depends on the initial value of next.\n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\n\`\`\`\n\nThrough slightly modifying the above procedure, we can get the following program that generates a random number according to the input seed: \n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\n\`\`\`\n\nIn the same way as in any other language, we can take advantage of modular operations to make our program eventually generate random numbers within a specified range. In detail, to generate random numbers from m to n,  we can use the following code:\n\n\`\`\`c\nmyrand(seed) % (n - m + 1) + m;\n\n\`\`\`\n\n1. Following the above random number generation program, please add the random number generation procedure \`myrand()\` in the \`Math\` module, and then implement its specific functions.\n2. Please add and implement the public procedure \`generateSerial()\` in the \`BulidCastle\` module, which calls the \`myrand\` procedure in the \`Math\` module to generate a random 8-bit serial number (i.e., a random number between 10^<sup>7</sup>and 10<sup>8-1</sup>) based on the height of the current block.\n   - The height of the current block can be obtained by the \`get_current_height()\` method in the \`Block\` module.\n   - The address of the module \`Block\` is \`0x0\`.\n   - Import \`Math\` and \`Block\` modules in the correct places.\n3. Declare \`SerialNum\` in main() and initialize it through the \`generateSerial()\` procedure.\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //Enter the code here\n    \n}\n\nmodule BuildCastle {\n    //Enter the code here\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //Enter the code here\n    \n}\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //Enter the code here\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 Procedures with multiple return values",
            instruction: `## Chapter 5 Procedures with multiple return values\n\nIn Chapter 5, we introduced the procedure and illustrated how to use the procedure with a single return value. However, in many scenarios, we need to use a procedure with multiple return values, which will be introduced in this chapter.\n\nAccording to Chapter 5, we can declare a procedure with a single return value as follows:\n\n\`\`\`\npublic procedure name( parameter name 1，parameter name 2，...) : reture type {...}\n\n\`\`\`\n\nSimilarly, we take the procedure with two return values as an example, which can be declared as follows:\n\n\`\`\`\npublic procedure name( parameter name 1，parameter name 2，...) : reture type * reture type {...}\n\n\`\`\`\n\nAnd the calling method is:\n\n\`\`\`\nvariable 1, variable 2, ...  = module name.procedure name( parameter name 1，parameter name 2，... )\n\n\`\`\`\n\nWhen using the procedures with multiple return values, we need to pay attention to the following points:\n\n1. When a procedure with multiple return values is operated with another one having a single return value, only the last return value of the first procedure is involved.\n\n   Take the following code as an example, when Line 2 is called in Line 18 as a procedure with multiple return values, the first two return values are the operation results of this procedure while the last one should be derived after operating with the procedure \`bar()\`.\n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\n\`\`\`\n\n2. A procedure with multiple return values can function as  a parameter of another procedure with multiple parameters.\n\n   For example, in the following code block, the procedure with multiple return values in Line 2 becomes the first two parameters in the procedure in Line 25 with three parameters. \n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\n\`\`\`\n\n3. If the Return statement of a procedure with multiple return values apprears at a Switch statement, it is necessary to check that whether the type and number of return values in each branch are uniform.\n\n   For example, the return value of the procedure \`bar()\` appears in Lines 6 ~10, and both return values are with type \`u64\`, which is consistent with the return type when declaring the procedure.\n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\n\n\`\`\`\n\n### Practical Exercise\n\nAdd the \`racial_judgment()\` procedure to the \`BuildCastle\` module and realize its function: determine the race of the castle based on the serial number, and return the corresponding initial economic  and military powers.\n\n1. Extract the race digit from the serial number, i.e., the 7th digit of the serial number, by modulo and division operations;\n2. Determine the economic and military powers corresponding to the race through the Switch statement, where the relationship between the race and the values of two powers is as follows:\n\n|   race digit   | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------------: | :--: | :--: | :--: | :--: | :--: |\n| economic power |  6   |  8   |  3   |  7   |  4   |\n| military power |  6   |  3   |  8   |  4   |  7   |\n\n3. This procedure has two return values in type u64, one for economic power and the other for military power.\n\nTips: How to extract the m-th digit from an n-digit number?\n\n- For an n-digit Num, if you want to extract the first x digits, you can use rounding division Num / 10<sup>n-x</sup>. The result of this operation is the number corresponding to the first x digits. For example, 54312 / 10<sup>5-2</sup>=54;\n- For an n-digit Num, if you want to extract the last x digits, you can use the modulo operation Num % 10<sup>x</sup>, whose r is the number corresponding to the last x digits. For example, 54312 % 10<sup>2</sup> =12;\n- For an n-digit Num, if you want to take the middle x digits, you should convert the problem to one of the above two problems, and then further calculate the final result.\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //Enter the code here\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 6 Refine the design of a castle",
            instruction: `## Chapter 6 Refine the design of a castle\n\nIn Chapter 3, we learned how to declare a struct. In this chapter, we will continue to learn how to initialize a struct and use it in the \`main()\` procedure.\n\nAs shown in the figure below, we often create a procedure to initialize a struct, which should be declared and initialized in the same module. The return value of the procedure used to initialize the struct is with struct type, which initializes the struct by returning a struct with initial member variable values. \n\n<img src=${require("../../static/images/lesson2/pic_2_6_1_en.png")} style="width:80%;position:relative;left:10%">\n\nFor example,\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\n\`\`\`\n\nIn this example, we declare a struct \`T\` in the module \`Bar\` and initialize the member variables of the struct with the parameters of the procedure by a procedure named new.\n\nIn the new procedure, we return a struct \`T\` whose value of the member variable \`baz\` is the parameter \`m\` of the procedure.\n\nNote that in the above code, the codes from Line 6 to Line 8 are formally similar to the definition of a struct, which is actually a  return statement. Therefore,  there is a semicolon at the end of it.\n\nWhen we want to use struct \`T\` in \`main()\` or other procedures, we can declare the variable as a struct type using let statement and call the new procedure to initialize it. \n\nFor example, the following code initializes the variable \`x\` to a struct \`T\` with a member variable value 10.\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\n\n\`\`\`\n\n### Practical Exercise\n\nIn the previous chapters, we have learned several important processes to build a castle, so the next step is to combine them and build the castle in the \`main()\` procedure.\n\n1. Add the \`newCastle\` procedure to the \`BuildCastle\` module to initialize a struct-type \`Castle\` variable, where the procedure has two parameters:\n\n   - \`_name (bytearray)\`, indicating the name of our castle\n   - \`_SerialNum (u64)\`, identifying the serial number of the castle\n\n   Note: In order to distinguish from the name and \`SerialNum\` in \`main()\`, we put an underscore in front of the above parameter names.\n\n   This procedure has a return value of type \`Self.Castle\`.\n\n   Please follow the example in our course to initialize a castle based on two parameters，namely \`_name\`, and \`_SerialNum\`.\n\n   Tips: the castle's name and serial number are initialized to the corresponding values. In addition, the castle's level is initialized to 1. And the castle's economic and military powers are initialized to the values calculated by calling the \`racial_judgment()\` procedure.\n\n2. In the main procedure, the name of the castle is entered by the user, so the name parameter is an external input. In this case, we need to add a parameter named name to the \`main()\` procedure with the type bytearray. \n\n3. Add the castle variable to \`main()\` and initialize it. Note: Remember to insert the let statement in the beginning.\n\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //Enter the code here\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n//Modify the content here\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //Enter the code here\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial: "Lesson 3",
    title: "",
    intro: ["In the previous lessons, we have created a basic castle framework. In the third lesson, we are going to build a fortified castle. ","The concept of resources;How to create and destroy resources;How to create a multi-file structure"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 Resources",
            instruction: `## Chapter 1 Resources\n\nIn the existing Blockchain systems, Bitcoin programs “currencies” and Ethereum programs “applications”; Libra, by contrast, programs “assets”, named as “resources”, which are a more complex assets type than currencies.\n\nMove stipulates that the operation of resources has to meet the following two constraints:\n\n- **Scarcity**: The total amount of resources must be under control and users are not allowed to copy, reuse or discard resources arbitrarily.\n\n- **Permission control**: The operation of resources must satisfy certain predefined rules.\n\nTo meet the above two constraints, in a Move contract, a resource can only be created or destroyed by the module that defines it and can only be operated with the  \`move()\` function. That is, we are not allowed to replicate resources with the \`copy()\` function.\n\nMove compiler statically verifies that if the above security constraints are met through bytecode, which will refuse to run a program failed to pass the bytecode validation.\n\nFor beginners, a resource can be regarded as a restricted structure for the time being.\n\nDeclaration of a resource is similar to that of a structure: \`resource name {data: type, data: type, ...} \`.\n\nHere is an instance of declaring the \`LibraCoin\` resource: \n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### **Practical exercise**\n\nFor security reasons, we require the castle structure to be modified into a resource.\n\n1. Please change the type of \`Castle\` from structure to resource.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//Modify the \"struct\" here\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 2  Resource Creation",
            instruction: `## Chapter 2 Resource Creation\n\nTo use a resource, we first need to implement the procedure of creating a resource, the return value type of which is resource.\n\nFor example, the following code creates the procedure \`LibraCoin\` mentioned in the previous lesson, which creates a resource variable \`T\` with a value of 0. \n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\nAs you can see, the creation of resource is similar to the initialization of structure. \n\n### **Practical exercise**\n\nNext we are going to implement the procedure of creating resources. \n\nIn this chapter, we will introduce the concept of 'account',  where each player has an account with corresponding castle. By this means, we associate the castle with the player.  \n\nSpecific functions and operations of an account will be introduced in subsequent courses. This chapter only focuses on creating modules and resources related to the account. \n\n1. Create a module named \`CastleAccount\` below the \`BuildCastle\` module.\n2. Declare  the \`CastleAccount\` resource in the newly created module. For practice, the resource only has one \`u64\` variable named \`a\` for now, which we will refine in the following chapters.\n3. Implement the procedure \`newAccount\` to create the \`CastleAccount\` resource, which initializes the variable \`a\` in the resource to 0.`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//Enter the code here\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Chapter 3 Resource Destruction",
            instruction: `## Chapter 3 Resource Destruction\n\nSince there is no garbage collection mechanism in Move language, the lifecycle of resources we declare and create in the smart contract will draw to an end as the contract expires. Therefore, resources have to be destroyed by \`Unpack\` in the module where the resources were created. \n\nIn the case that we have desire to store certain resource permanently in the blockchain system, we are required to publish it to the global storage, associating it with an address in the blockchain. \n\nIn this lesson, we begin with how to destroy resources and will cover the release of resources in the following sections.\n\nSpecifically, we can unpack and destroy a resource by \`resource name { member variable } = move ( resource to be destroyed )\`.\n\nLet's take a look at a simple instance as follows, which is the destruction procedure for \`LibraCoin\` :\n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n        T { value } = move(coin);\n        return;\n}\n\`\`\`\n\nIn this procedure, we first declare a local resource variable \`T\` with a member variable \`value(u64)\`, and then rebind the resource \`coin\`, which we want to destroy, to the local resource variable \`T\` through the \`move()\` function. At the end of the procedure, the local resource variable\`T\`  will be automatically destroyed. Consequently, the \`coin\`resource becomes unbound and can no longer be accessed. Since the system will recycle unbound resources, destruction of the resource \`coin\` is achieved as a result.\n\n\n\n### **Practical exercise**\n\nNow that we have created the \`Castle\` and the \`CastleAccount\` resources, we are about to implement their destruction procedures.\n\n1. Create the \`desCastle\` procedure in the \`BuildCastle\` module according to the example in this lesson. The parameter name in this procedure is \`castle\` and the temporary variable name is the same as that used in the previous lesson.\n2. Create the \`desAccount\` procedure in the \`CastleAccount\` module according to the example in this lesson. The parameter name in this procedure is \`account\` and we name the temporary variable \`num\`.`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    //Enter the code here\n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //Enter the code here\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Chapter 4 Resource Usage",
            instruction: `## Chapter 4 Resource Usage\n\nWith the resources created, we can use them now.\n\nUsage on resources is almost the same as that on structures, except that we are supposed to destroy a resource after having used it.\n\nIn this chapter, we assume that resources are only used in the current transaction script and will not be sent to any address for the time being, which means that the resources need to be destroyed at the end of  \`main()\`.\n\nNext we are going to understand how to use resources with an example as well as review the creation and destruction of resources.\n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\nIn this instance, we declare a module named \`MoneyHolder\` with a resource \`T\` that is created with the procedure in Line 5 and destroyed through the procedure in Line 8.\n\nIt should be noted that the member variable of resource \`T\` is also a resource. Therefore, when destroying \`T\`, two destructions (Line 10 and Line 11) are required, where the second destruction is to call the \`LibraCoin.destroy_zero()\` procedure in the \`LibraCoin\` module to destroy \`coin\`.  What have been mentioned above is the knowledge points involved in the first two chapters. If you have something forgotten, please go back to review them.\n\nNext let’s look at the \`script\` part of this instance. The first two lines in the \`main()\` procedure declare two resource variables, one of which is \`LibraCoin.T\` and the other is \`MoneyHolder.T\` declared by us. After declaring the variables, we will then initialize them on the ground that uninitialized variables cannot be operated.\n\nThe function\`LibraCoin.zero()\` in Line 21 aims  to initialize the resource \`LibraCoin.T\`, which is defined in Libra's official \`LibraCoin\` module and won’t be further analyzed here.\n\n\`MoneyHolder.new(move(coin))\` in Line 22 is the resource creation procedure we defined to initialize \`money_holder\`,  so that we can  use this variable now. \n\nNote: The argument here is \`move(coin)\` instead of \`copy(coin)\`. Even if you might want to use the \`coin\` variable in the following,  you are still not allowed to use the \`copy()\` function, for the reason that \`coin\` is a resource and resources can only be operated by the \`move()\` function rather than the \`copy()\` function.\n\nIn this instance, we are not going to implement any operations on \`money_holder\`, and thereby the next step is to destroy it before terminating the contract. Note that the parameters in this procedure also use the \`move()\` function, instead of \`copy()\`.\n\nIn general, to use a resource, we should first declare the resource variable through  the\`let\` statement, then call the resource creation procedure to initialize the variable, and finally implement the destruction process to destroy it when we have finished to use the resource, as shown in the following figure.\n\n### **Practical exercise**\n\nIn the previous chapter, while we have completed the procedures of creating and destroying the castle, the contract still cannot be compiled successfully, since we are also required to refine  the resource creation and destruction in the \`main()\` procedure.\n\nNote: Since the account resource has no practical effect for the time being, we will not call it in \`main()\` here. If the \`CastleAccount\` resource needs to be used, we are able to create or destroy it with the\`newAccount\` and \`desAccount\` functions respectively.\n\n1. Add a statement to destroy the \`Castle\` resource in \`main()\`.`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //Enter the code here\n\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 Splitting files",
            instruction: `## Chapter 5 Splitting files\n\nBy the time you are here, I believe that you have noticed that the file is getting longer and longer. Thus, it’d be better if we divide it into multiple files for the sake of efficient management and readability improvement.\n\nIn this chapter, we have cleaned up the code on the right. Now as you can see, there are a few more tabs at the top of the editor and you are free to click on each tab to switch files.\n\nAs shown above, the tabs are divided into active and fixed tabs. The active tabs are editable, which are also the files that we are going to modify and check in practical exercise. While the fixed tabs are read-only, it is implied that we are entitled to check the files in the studying process but not allowed to make modifications.\n\nTypically, we place a module in a file and then import it by\`import address.module name\`, as described in Chapter 2 of Lesson 1. In this way, it is more convenient for us to maintain, manage and update different module functions.\n\n### **Practical exercise**\n\nNow that we have created a multi-file structure and split the module, please add the previously completed transaction script part to the file.\n\n1. Please browse through the created module and complete the transaction script in the current active tab.`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "//Enter the code here",
                    answer: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lesson4 = {
    lessonserial: "Lesson 4",
    title: "",
    intro: ["In the previous lessons, we made the castle more secure, but that's not enough. We also need to design access controls. In this lesson, we'll continue to reinforce the castle. ","The use of assert();The builtins get_txn_sender()，move_to_sender() and borrow_globla();Borrow and mutable borrow;The use of acquires;The use of dereference"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "Chapter 1 Statistics of Resources",
            instruction: `## Chapter 1 Statistics of Resources\n\nIn the last lesson, we mentioned that the operation on resources needs to guarantee the scarcity trait and meet access control policies. Therefore, the castle, as the most important resource a player holds, has to be guaranteed its reasonable quantity and access right.\n\nTo do this, we can add a counter variable to the system, update its value every time we create a new castle, and set a policy  to access the variable that only administrators are able to use it.\n\nNote: There is an administrator account in Libra with the address \`0xA550C\` that is authorized the privilege to mint or burn Libra Coins and access the market capacity at present. Similarly,  there also exists an administrator in our own castle system that is entitled to access the number of castles.\n\nGiven that the above counter variable requires security and access restrictions, we define its type as a resource and implement a series of related functions through operations on this resource. (Note: The following design idea is modeled after that of the \`LibraCoin\`module. Please read the specific code if you are interested).\n\n### Practical exercise\n\nFirst,  we need to declare a resource indicating the total number of castles.\n\n1. Declare a resource named \`CastleSum\` in the \`BuildCastle\` module, with a member variable \`sum(u64)\`.\n\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //Enter the code here\n\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 2 Access Control for Initialization Process",
            instruction: `## Chapter 2 Access Control for Initialization Process\n\nAccording to Lesson 3, we have realized that resources are required to be initialized before used. Therefore, after declaring the resource \`CastleSum\`, we need to initialize it. At this point, we are faced with two problems:\n\n1. Only administrators are allowed to call the process of initializing CastleSum once when the Blockchain system has just been created. That is, we need to implement the access control for the initialization process.\n2. After initialized, the resource is supposed to be sent to the address of the administrator, instead of being destroyed in a transaction.\n\nWe will figure out how to address the first problem in this chapter and the second in the next chapter.\n\nFor the first question, we need to pick up two new inline processes.\n\n### \`assert()\`\n\n\`assert()\` is an operation widely used in many programming languages to check what \"should not\" happen. \`assert()\` is often used to verify the validity of incoming arguments at the beginning of the function and determine whether the result is correct at the end. (Note: Functions in other languages are equivalent to procedures in Libra Move).\n\nIn Libra Move, \`assert()\` has two arguments. The first one is an expression. When a program runs to the \`assert()\` statement, it checks to see whether the expression is valid or not. If true, it continues to execute; otherwise, it will terminate the program and output an error code, the value of which is the second argument.\n\nA simple instance for \`assert()\`  is as follow.\n\n\`\`\`\nmain() {\n  assert(1 + 2 == 3, 99);\n  return;\n}\n\n\`\`\`\n\nIn this example, the program determines whether \`1+2\` is equal to 3. If true, there will be no information output; otherwise, error code 99 will be printed.\n\n### \`get_txn_sender()\`\n\nIn Libra Move, there are many builtins for accessing system data, one of which is \`get_txn_sender()\` used to obtain the address of the current transaction sender. \n\nHere is an example: \n\n\`\`\`\nmain() {\n    let sender: address;\n    let addr: address;\n    sender = get_txn_sender();\n    addr = 0x0;\n    assert(copy(sender) != copy(addr), 42);\n    return;\n}\n\n\`\`\`\n\nAs you can see from this example, the return value of \`get_txn_sender()\` is an \`address\` variable and we assign the account address currently executing \`main()\` to an \`address\` variable by \`variable name = get_txn_sender()\`.\n\n### Practical exercise\n\nNext, we are going to set up the procedure of initializing the total number of castles and only allow  the administrator account to call this procedure.\n\n1. Declare the procedure of initializing the total amount of castles below  \`desCastle()\` in the \`BuildCastle\` module, named \`iniCastleSum()\`, which is a public\n   procedure without the return value.\n2. Implement the access control of the resource by combining \`assert()\` and \`get_txn_sender()\`. Specifically, it is judged by \`assert()\` to determine whether the current account address is consistent with the administrator address. If not, an error message will be output and the program will be terminated as well. Here we assume that the administrator account address is \`0x0000000\` and the error code is 1.\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    //Enter the code here\n\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 3 Sending Resources",
            instruction: `## Chapter 3 Sending Resources\n\nResource destruction has been covered in lesson 3, then we’re going to introduce how to publish a resource in this chapter.\n\nResource \`CastleSum\` is meant to be published to the administrator address, which can be done by \`move_to_sender()\`.\n\n\`move_to_sender()\` is a module that sends a resource to the address corresponding to the current account for storage, with the following format: \n\n\`move_to_sender<n>(e)\` \n\nwhere \`n\` is the resource type and \`e\` is the resource expression. We will first introduce generics  \`<>\` before providing new insight into this operation.\n\n### Generics \n\nGenerics are a feature for programming languages that allow programmers to define variant parts when coding with a strongly typed programming language. These parts must be specified before they are used.\n\nIn short, generics enable a procedure to be available to multiple types of variables at the same time, without modifying the codes of the procedure.\n\nFor example, a procedure that can access to resource A returns the type of resource A when not using generics. At this time, if we want to do the same for resource B, we need to declare a procedure with exactly the same content but a different return value once again. Such a job is a meaningless repetition for developers, also increasing the complexity and redundancy of the codes. If we apply generics in this case, the same procedure only needs to be implemented once and the same operation can be performed on all resources by specifying the resource type when we are calling.\n\nTherefore, generics can be regarded as a special type that defers type definition until an object is created or methods are called. Generics provide developers with a high-performance programming approach that improves code reusability and type safety.\n\nIn this chapter, we skip how to implement the generic process for the time being, only considering how to apply it. The way to use generics in Move language is simple: \`procedure name <type> (parameter expression)\`\n\n### \`move_to_sender()\`\n\nLet’s learn about \`move_to_sender ()\` through a specific example.\n\n\`\`\`\npublic initialize() {\n        assert(get_txn_sender() == 0xA550C18, 1);\n        move_to_sender<MintCapability>(MintCapability{});\n        move_to_sender<MarketCap>(MarketCap { total_value: 0 });\n        return;\n}\n\`\`\`\n\nThis is a procedure for initializing the  market capacity in \`LibraCoin\`. Line 2 determines whether the current account is an administrator account through \`assert()\`, which is the knowledge point in the last chapter. Both Line 3 and Line 4 are used for \`move_to_sender()\` to send the resources \`MintCapability\` and \`MarketCap\` to the corresponding address of the current account respectively, where \`MintCapability\` is a resource without member variables, representing the mining right while \`total_value\`, the member variable of \`MarketCap\`, is initialized to 0.\n\nIn general, the above process first checks if the current account is an administrator one. If true, the current account is granted the mining right and the market capacity (i.e., the sum of the \`LibraCoin\` in the current system) is set to 0, which is sent to the current account.\n\n### Practical exercise\n\nFinally we initialize the resource for the total number of castles and send it to the administrator account.\n\n1. Initialize the declared resource \`CastleSum\` as 0 through \`move_to_sender()\` in the \`iniCastleSum()\` procedure and send it to the current account (i.e., the administrator account with address \`0x0000000\`). Remember to add \`return\` at the end of the procedure.\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        //Enter the code here\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 4 Borrowing",
            instruction: `## Chapter 4 Borrowing\n\nOnce we’ve initialized the total number of castles, we’d like to see how many of them are in the current system at any time.\n\nThis function seems easy to implement at first glance, since all you have to do is to access the resource \`CastleSum\` and output the value of its member variable \`sum\`. However, we should be aware that resources can’t be operated by \`copy()\`  as only \`move()\`  works. When we pass \`CastleSum\` into the procedure accessing this resource through \`move()\`, the original resource variable will lose ownership, which leads to every time we access the resource, we are required to reinitialize \`CastleSum\` and send it to the administrator account----this is obviously unreasonable.\n\nOwnership, on the one hand, increases resource security，but on the other hand, makes accessing or changing the value of a resource harder. To tackle with such a problem, Libra Move introduces the concept of borrowing.\n\nBorrowing indicates to borrow ownerships, also known as reference, the mechanism of which is similar to that of  \"read-write lock\" in other languages. We can only own one \"write\" lock or multiple \"read\" locks at the same time, that is, \"write\" lock and \"read\" lock are not allowed to appear simultaneously. \n\nLibra Move  will check the security  of borrowing operation during the compiling process rather than the running process, which can also help avoid problems such as deadlock and wild pointer.\n\nWe achieve borrowing by using \`&\`. For example:\n\n\`\`\`\nmain() {\n    let x: u64;\n    let x_ref: &u64;\n    let y: u64;\n    x = 5;\n    x_ref = &x;\n    //y = copy(x);	//error\n    _ = move(x_ref);\n    y = copy(x);	//correct\n    return;\n}\n\`\`\`\n\nWe can learn from above that the way to declare a borrowing is \`let borrowing variable name: &borrowing variable type\`. \n\nOnce declared, borrowing can be realized through \`borrowing variable name: = & borrowed variable name\`. \n\nDuring the borrowing period, the ownership of the original variable is borrowed, implying we are unable to access this variable by \`copy()\` or other means.  \n\nJust as resources need to be explicitly destroyed, borrowing is required to be returned. We also need to explicitly break off borrowing when it is no longer used, or before the end of \`main()\`.  As in this example, we achieve this function through \`_ = move(x_ref)\`, where \`_\` represents a temporary variable in Libra Move. This operation moves the value stored in \`x_ref\` to the temporary variable, which will be destroyed when finishing using it.  By this way,  the borrowing of \`x_ref\` has been removed. \n\n### Mutable borrowing \`mut\`\n\nThe same as the \"read-write lock\" mechanism, divided by \"read” lock and \"write” lock, borrowing is also divided into mutable borrowing \`&mut\` and immutable borrowing \`&\`.\n\nMutable borrowing can modify the value of the original variable during the borrowing period, while immutable borrowing is read-only. \n\nA variable can have at most one mutable borrowing or multiple immutable borrowings at a time, which means the two kinds of borrowings cannot appear concurrently. \n\nFor instance, the following example can be successfully compiled, but if we change \`x_ref = &x;\` to \`x_ref = &mut x;\`, the compilation will fail in the end.\n\n\`\`\`\nmain() {\n    let x: u64;\n    let x_ref: &u64;\n    let x_ref2: &u64;\n    x = 5;\n    x_ref = &x;	//correct\n    //x_ref = &mut x;	//error\n    x_ref2 = &x;	\n    _ = move(x_ref);\n    _ = move(x_ref2);\n    return;\n}\n\`\`\`\n\n### Practical exercise\n\nNext,  we are going to set up a procedure to see how many castles there are in the current system.\n\n1. Declare a procedure named \`castlesum()\` in the \`BuildCastle\` module, which has no parameters and returns a u64 variable representing the total number of castles. Note that we should use lowercase letters for the process name to distinguish it from the resource \`CastleSum\`.\n\n2. Declare a mutable borrowing resource variable named \`CastleSum_ref\` on the first line of the procedure, which we'll refine in the next few chapters.\n\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    //Enter the code here\n\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: " Chapter 5 borrow_global_mut()",
            instruction: `##  Chapter 5 \`borrow_global_mut()\` \n\nIn Chapter 3, we have learned how to use \`move_to_sender()\`.  In this chapter, we’ll move forward to introduce another module \`borrow_global_mut()\`.\n\n\`borrow_global_mut()\` is also a procedure that implements generics, taking an \`address\` variable as the input parameter, which is used globally to return the mutable borrowing of a resource with the corresponding type at the specified address.\n\nWe can use \`borrow_global_mut()\` with the format of \`borrowing resource name=borrow_global_mut<required resource name>(address)\`. For example, the variable \`x_ref\` borrows the resource \`T\` with address \`0x0000\` through \`x_ref = borrow_global_mut<T>(0x0000)\`.\n\nObviously, \`borrow_global_mut()\` requires the target address to have the resources it needs to borrow. If not, the borrowing will consequently fail.\n\nThat is, once we use \`borrow_global_mut ()\` in a procedure, we need to tell the Move\ncompiler what resources the procedure will borrow at the very beginning and Libra Move\nwill implement this operation through \`acquires T\`.\n\nNotice: There is a similar operation in Move: \`borrow_global()\`, which is used to return the immutable borrowing of a resource with the corresponding type at the specified address.\n\n### \`acquires\`\n\n\`acquires\` can be regarded as an annotation that tells the bytecode verifier which types of a procedure (or its callees) may borrow or move from the global state. These annotations allow the bytecode verifier to ensure that there are no dangling references to values in the global state.\n\nNote: The dangling reference is a problem that when two pointers point to an address at the same time, the data at the address is deleted by one of the points, while the other points to an empty address as a result.\n\nFrom a programmer perspective, this means that you must add \`acquires\` for any procedure when: \n\n1. performs \`borrow_global_mut<T>\` ；\n2. performs \`move_from<T>\`  ( which will be introduced in the following lessons) ;\n3. calls a procedure annotated with \`acquires T\` .\n\nLet's learn how to use \`acquires\` with an example:  \n\n\`\`\`\nmodule A {\n    resource T1{v: u64}\n    public test(addr: address) acquires T1 {\n        let x: &mut Self.T1;\n        x = borrow_global_mut<T1>(get_txn_sender());\n        _ = move(x);\n        return;\n    }\n}\n\`\`\`\n\nIn the above example, we borrow the resource \`T1\` from the calling procedure's address and store it in \`x\`. Since we have used \`borrow_global_mut<T1>\`, it is required to check if the resource \`T1\` exists at the beginning. Thus,  we wrote down \`acquires T1\` at the end of  the declaration procedure.\n\n(Reference: https://community.libra.org/t/how-could-i-understand-the-keyword-acquires/1832)\n\n### Practical exercise\n\n1. With mutable borrowing declared,  we need to initialize the \`CastleSum_ref\` via \`borrow_global_mut()\`, the parameter of which is the administrator address, tentatively set to \`0x0000000 \`;\n2. Add \`acquires\` in the declaration part of the procedure due to the use of \`borrow_global_mut()\`.\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    //Add acquires here\n    public castlesum(): u64\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        //Enter the code here\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 6 Dereference",
            instruction: `## Chapter 6 Dereference\n\nIf you are familiar with C language, then when you see the borrowing \`&\` in the previous chapters, I believe dereference \`*\` is likely to occur to you. Dereference can also be implemented in Libra Move, similar to that in C language. \n\nDeference \`Deref\` is the inverse operation of reference \`Ref\`. \n\nIn the Move bytecode, the only way to interact with the fields of a given struct (such as a structure or a resource) is by reference. So in order to get a copy of a value in a struct, a programmer must first borrow a reference to the field, and then a copy of the value bound to that field can be created by using deref \`*\`. \n\nTo put it simply, we can obtain a reference to a resource by borrowing \`&\` and the value of the reference by dereference\`*\`.\n\n\`\`\`\nfield_ref = &move(rsc).field;\nfield_value = *move(field_ref);\n\`\`\`\n\nWhen accessing a resource, we are able to obtain the value of a resource and return the ownership at the end of the borrowing by combining the borrowing and dereference, that is, \`*&\`.\n\nFor example, by using \`*&move(T).value\`, we can get the value of the member variable named \`value\` in the resource \`T\`. When the borrowing ends, the ownership of the resource and its member variables will not be changed.\n\nFinally, we summarize three commonly used operations on variables and fields by analyzing \`*&move(rsc).field\`: \`move()\`, \`&\`, and \`*\`.\n\n\`*&move(rsc).field\` is an operation consisting of three parts: the \`move()\` for variables, the borrowing for some field, and the value obtained by borrowing.\n\n1. \`move(rsc)\`\n\n   Each time we access a local variable, we can perform \`move()\` or \`copy()\`  on it. Using \`copy()\` means we obtain a copy of the variable;  while using \`move()\` indicates that we have transferred the ownership of the value, and aren’t allowed to get access to it again before assigning a new value to this local variable.\n\n2. \`&move(rsc).field\`\n\n   This is a borrowing operation on a field.  The only way to access some field of a given struct is by reference. The original reference to \`move(rsc)\` has been extended to a reference to the field \`field\` through this operation. Specifically, what we are currently referencing to is no longer \`move(rsc)\`, but \`field\`.\n\n3. \`*&move(rsc).field\`\n\n   This is a dereference operation that reads value from a borrowing. When we perform dereference operation, we obtain the copy of this borrowing value, while the original borrowing will not be changed. Specifically, what is currently accessed has changed from \`&move(rsc).field\` to a copy of the value.\n\n(Reference: https://community.libra.org/t/meaning/1253/2)\n\n### Practical exercise \n\nFinally, we need to get the value of the total number of castles and return it.\n\n1. Get the value of the member variable in the resource \`CastleSum_ref\` via \`*&\` and use it as the return value of the procedure.`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        //Enter the code here\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        ]
}

const lesson5 = {
    lessonserial: "Lesson 5",
    title: "",
    intro: ["Previously, we created the Castle Account module, but did not yet implemented specific functions. In this lesson, we shall realize basic functions for the account: creating and publishing.","Declaration of an event;Creation of an event handle;Sending an event message"],
    key: 5,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 Framework Construction for Account",
            instruction: `## Chapter 1 Framework Construction for Account\n\nRemember the \`CastleAccount\` module and the \`CastleAccount\` resource created in lesson 3 for picking up resource creation? In this chapter,  we will implement the basic functionality of the \`CastleAccount \`.\n\nA castle account module should be able to implement the following basic functions:\n\n- Create a new account and corresponding castle simultaneously.\n- Publish the account to the sender’s address.\n\nTherefore, in this chapter, we first construct our framework for the module, namely the declarations of resources and procedures.\n\n### Practical exercise\n\n1. Modify the member variable in the \`CastleAccount\` resource to be \`new_castle\`, with type \`Castle\` in the \`BuildCastle\` module.\n2. Since we are bound to have our own castle as the account is created, we are supposed to provide a castle name for the procedure \`newAccount()\`: Please modify this procedure, adding a parameter \`name\` of type \`bytearray\`.\n3. Considering our castle system won’t delete any accounts, but publish them instead, thus it's imperative to modify the original \`desAccount()\` into a \`public\` procedure named \` publishaccount()\`, which takes \`account\`( type \`CastleAccount\`) as the parameter and doesn't have any return values, that is, only \`return\` is required at the end of the procedure.\n\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        //Modify the code here\n        a: u64\n    }\n    //Add parameters to the procedure\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n    //Add the procedure for publishing account\n\n}",
                    answer: "module CastleAccount {\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle\n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public publishAccount (account: Self.CastleAccount)\n    {\n        return;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 2  Account Creation",
            instruction: `## Chapter 2  Account Creation\n\nIn the following lessons, we will apply the acquired methods to refine several procedures declared in the previous chapter, so as to accomplish account creation with the corresponding castle. \n\nSpecifically, the procedure of creating an account returns a new account resource, the member variable of which is a new castle resource. Accordingly, we need to migrate the castle creation process previously implemented in \`main()\` to the account creation procedure, taking the newly created castle as the member variable of the returned account, thus implementing the castle creation as the account is established.\n\n### Practical exercise\n\n1. Realize the functions originally implemented  in the \`main()\` by \`newAccount()\` procedure and import the other modules you need for implementing these functions at the beginning of the module \`CastleAccount\`. \`main()\` is supposed to remain unchanged, which we will modify in the next chapter. Note that you don’t have to call the \`desCastle()\` procedure to destroy castle resources after \`newCastle()\` is implemented. \n2. Return the new account resource in the \`newAccount()\` procedure.\n\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n     //Import the required modules here\n\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle\n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        //Enter the code here\n\n    }\n    public publishAccount (account: Self.CastleAccount)\n    {\n        return;\n    }\n}",
                    answer: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle\n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        \n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle)};\n    }\n    public publishAccount (account: Self.CastleAccount)\n    {\n        return;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 3 Account Publishment",
            instruction: `## Chapter 3 Account Publishment\n\nWe tend to publish the created account to the address that called the procedure so as to form a correlative connection between the castle and its owner. We have introduced how to publish resources in chapter 3, lesson 4. In the case that you have forgotten, go over it again.  \n\n### Practical exercise\n\n1. Apply \`move_to_sender()\` in the \`publishAccount()\` procedure to publish account resources.\n2. Modify \`main()\`: delete a series of previously defined operations on castle creation and declare a variable named \`account\` of type \`CastleAccount\`. Remember to import the required modules before \`main()\`.\n3. Call the two procedures \`newAccount()\` and \`publishAccount()\` to implement the account creating and publishing.\n\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount 和 main.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle\n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        \n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle)};\n    }\n    //Add acquires here\n    public publishAccount (account: Self.CastleAccount)\n    {\n        //Enter the code here\n\n    }\n}\n\n//Import the account module here\nmain(name: bytearray) {\n    //Enter the code here\n\n    return;\n}",
                    answer: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle\n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        \n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n       move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n}\n\nimport Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
            ]
        },
        {
            title: "Chapter 4 Event",
            instruction: `## Chapter 4 Event\n\nEvent is a mechanism for contract and blockchain communication. By \"listening\" to certain events, your front-end application will react accordingly. In other words, we tend to send desired information to the front-end via events. Libra declares relevant resources and basic operations on events in the \`Event\` module, which can be imported by \`import 0x0.Event;\`.\n\nWe first declare an event by structure declaration, for example:\n\n\`\`\`\nstruct Event {\n        x: u64\n}\n\`\`\`\n\nWe call it \`Event\`, and the message to be sent to the front-end via the event is \`x: u64\`.\n\nNext declare the event handle, saying \`let handle name: Event.Handle< Self.Event name>\`, for example:\n\n\`\`\`\nlet event_handle: Event.Handle<Self.Event>;\n\`\`\`\n\nIt is necessary to add the handle to the member variable of the event-related resource so that it can be accessed when the event needs to be sent, for example:\n\n\`\`\`\nresource T {\n		events: Event.Handle<Self.Event>\n}\n\`\`\`\n\nWe create an event handle through the \`new_event_handle()\` procedure in the \`Event\` module, using the sender's \`HandleIdGenerator\` to generate a unique event handle, to which event can be sent.\n\nThe statement that creates the handle is: \`handle name = Event.new_event_handle<Self.Event name>()\`, for example:\n\n\`\`\`\nevent_handle = Event.new_event_handle<Self.Event>();\n\`\`\`\n\nOnce the handle is created, we can send the event carrying information to the handle through the \`emit_event()\` procedure in the \`Event\` module, and accordingly, the front-end program will get the event information via the handle.\n\nThe statement that sends an event is defined as \`Event.emit_event<Self.Event Name>(&mut move( resource borrowing).event variable in resource, move(event name))\`, for instance:\n\n\`\`\`\nEvent.emit_event<Self.Event>(&mut move(resource_ref).events, move(event));\n\`\`\`\n\nNote that we are supposed to accomplish the resource borrowing before sending the event, and therefore  acquires and relevant parameters are needed to add in the procedure.\n\n### Practical exercise\n\n1. Import \`Event\` module, adding the event handle \`account_events\` , a member variable, to the account resource. \n2. Add a structure \`AccountEvent\` with a member variable \`flag: u64\` below the account resource.\n3. Modify the account creation procedure \`newAccount()\`: create a handle and append the details related to \`account_events\` to the return value.\n4. We intend to send a signal \`flag: u64\`( with value of \`1\`) to the front-end as the account is released. Please add the event handle declaration as well as the event sending in the account publishing procedure \`publishAccount()\`. Don’t forget \`acquires\`!\n\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    //Import the required modules here\n\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        //Add the event handle here\n\n    }\n    //Add the structure here\n\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        //Enter the code here\n\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        //Modify the return value here\n        return CastleAccount { new_castle: move(castle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        //Add the code for sending the event here\n\n       move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n}",
                    answer: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 5 Improvement on Castle creation",
            instruction: `## Chapter 5 Improvement on Castle creation\n\nIn the last lesson, we have created a resource for counting the number of castles and implemented its destruction and release. In this chapter, we shall increase the corresponding number by one as a castle is created.\n\n### Practical exercise\n\n1. Modify the \`newCastle()\` procedure: declare a variable named \`sum_ref\`, which is the mutable borrowing for \`CastleSum\`( \`CastleSum\` is a resource declared in the previous course for counting castles).\n2. In the \`newCastle()\` procedure, declare another variable \`sum_ref_value\`( type \`u64\`) to store the corresponding dereference (def) for \`sum_ref\`.\n3. Add an operation to modify the castle counter right before the \`newCastle()\` procedure returns its value: first use \`borrow_global_mut\` to assign a value to \`sum_ref\`( the administrator’s address is \`0x0000000\`), then perform another assignment operation for \`sum_ref_value\` by def, and finally let the member variable value of borrowed \`sum_ref\` be equal to the current number of castles ( i.e. ,\`sum_ref_value\`) plus one. Since here using the \`borrow_global_mut\`, we need to add \`acquires CastleSum\`. \n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        //Declare related variables\n\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        //Modify the value of the counter\n\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum {\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        ]
}

const lesson6 = {
    lessonserial: "Lesson 6",
    title: "",
    intro: ["Over the last few lessons, we’ve created castles and castle accounts, and realized their basic functions, where we picked up the basic syntactic structure and related operations of the Move language. In this lesson, we are about to add a gameplay feature: castle upgrading.","Declarations, initializations, ownerships and operations of variables;Declarations and operations of modules;Declarations and invocations of procedures;Declarations and access controls of resources"],
    key: 6,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 How to Upgrade The Castle",
            instruction: `## Chapter 1 How to Upgrade The Castle\n\nPreviously, we have realized how to create a castle, with the properties of name, serial number, rank as well as economic and military powers.\n\nEach newly established castle ranks level 1, the initial values for economic and military powers of which are determined by its race bit in the serial number. \n\nIn the next part, we intend to add some functions to the castle, such as upgrades.\n\nSpecifically, our castle is able to level up its economic powers by annexing lands randomly generated by the system, and accordingly, progresses to a higher level when the economic power reaches a certain value.\n\n### Land Types\n\nWhen a player sends a request to the system for land annexation, the system will randomly generate a piece of land for the player. \n\nThere are 4 land types.  The castle’s economic power is expected to increase at different rates depending on the annexed land types.\n\nThe probabilities of these diverse land types and the corresponding economic growths are shown as the following table:\n\n|                                | Type 1 | Type 2 | Type 3 | Type 4 |\n| :----------------------------: | :----: | :----: | :----: | :----: |\n|          Probability           |  75%   |  15%   |   8%   |   2%   |\n| Growth Rate for Economic power |   5%   |  10%   |  20%   |  40%   |\n\n### Castle Level\n\nThe equation \`u(r)=10*r+2ʳ\` reflects the relationship between the castle's level \`r\` and the upper limit of the economic power \`u\`. When the economic power reaches the ceiling through land annexation, the castle will increase by 1 level.\n\n### Practical Exercise\n\nDemonstrate the process of annexing land to increase the power and then upgrade.\n\n`,
            type: 1,
            show() {
                return <L6c1 lang="1"/>
            }
        },
        {
            title: "Chapter 2 Access to the Castle Data",
            instruction: `## Chapter 2 Access to the Castle Data\n\nOur task is divided into the following three steps:\n\n1. Retrieve the current castle data;\n2. Increase the castle’s economic power according to the land type;\n3. Determine whether or not to upgrade the castle level based on the economic power.\n\nIt should be noted that the castle is a resource, and in the Move language, there exist strict access controls and security restrictions on the resource type.  That is, we are not allowed to directly obtain the castle level or modify its power value.\n\nRemember how we modified the member variable’s value of the resource \`CastleSum\` in the 5th chapter of  the previous lesson? Borrowing! In this chapter, we also need to obtain the castle's data by borrowing.\n\nAt this time we are faced with a new problem: we publish the castle account resource to the user address, so what we obtain by using \`borrow_global_mut\` is the resource type of castle account, while the castle resource that we desire is a member variable of the castle account. In other words, it is required to get a child resource.\n\nAccording to the previous lesson, we are able to retrieve the member variable value of a published resource via the following code. However, you’ll find out it’s no longer available if we attempt to **modify** the member variable \`a\` of the resource \`T1\` from \`u64\` to the resource type.\n\n\`\`\`\nmodule T\n{\n    resource T1\n    {\n        a: u64\n    }\n    public fun(): u64 acquires T1\n    {\n        let add: address;\n        let ref: &mut Self.T1;\n        let x: u64;\n        add = get_txn_sender();\n        ref = borrow_global_mut<T1>(move(add));\n        x = *&move(ref).a;\n        return move(x);\n    }\n}\n\`\`\`\n\nThe problem lies in the step of \`x = *&move(ref).a\` . The operation \`*&move(ref).a\` can be decomposed into the borrowing \`ref.a\` and the dereference, where the dereference carries out \`copy\` for \`ref.a\`, which is completely correct when \`ref.a\` is a variable of \`u64\`. Nevertheless, when we change it to a resource type, the dereference step will fail due to the fact that the resource cannot be implemented by the \`copy\` function.\n\nSo how do we get to the child resource? Please try to think about this problem first and then come up with certain new ideas before continuing to read the following methods.\n\nOur purpose is to obtain the castle account  from the current address, then retrieve the corresponding castle resources from the account, and finally modify the member variables (economic power and level) in the castle resources. Therefore, we may consider declaring a process for handling data changes as upgrading in the \`BuildCastle\` module, the parameters of which ought to be borrowing variable for the castle resources, while the process for land annexation is supposed to be declared in the \`CastleAccount\` module. In this way, we can obtain the castle resources by borrowing in the latter (land annexation), and then call the former (upgrade) to modify the member variables of the castle resources.  \n\n### Practical Exercise\n\n1. Declare the land annexation procedure \`annexation()\` in the \`CastleAccount\` module below the \`publishAccount()\` procedure. Since it doesn’t have any parameters or return values, we should add \`return\` to the last statement;\n2. In the \`annexation()\` procedure, follow the example given in the course to obtain the borrowing of the castle resources in the castle account at current address. Name the address variable \`add\`, the borrowing variables for \`CastleAccount\` and \`Castle\` \`ref\` and \`t\` respectively.\n3. Finally, call the \`upgrade()\` procedure in the \`BuildCastle\` module to realize castle upgrading, the parameters of which are the obtained castle borrowing in the previous step and we will implement the procedure in the next few chapters.\n\nHint: a. What we ought to get here is the borrowing of castle resource, so there is no need for dereference; \n\n​          b. Remember to append \`acquires\` to the procedure's name for using \`borrow_global_mut()\` in the process.\n\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    //Enter the code here.\n\n}",
                    answer: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    public annexation () acquires CastleAccount\n    {\n        let add: address;\n        let ref: &mut Self.CastleAccount;\n        let t: &mut BuildCastle.Castle;\n        add = get_txn_sender();\n        ref = borrow_global_mut<CastleAccount>(move(add));\n        t = &mut move(ref).new_castle;\n        BuildCastle.upgrade(move(t));\n        return;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 3 Modify The Power for Your Castle",
            instruction: `## Chapter 3 Modify The Power for Your Castle\n\nIn the last chapter, we have settled the most difficult problem--access to resources and next we are going to implement the castle upgrading procedure \`upgrade()\`.\n\nIn the process, it’s required to realize the following specific functions:\n\n1. Generate random land;\n2. Increase the castles’ economic powers according to their land types.\n\nIn Lesson 2, we have implemented the \`myrand()\` procedure to create random numbers, which will be used in this chapter for random land generation. \n\nSpecifically, we will generate a random integer from 1 to 100. The land type will be set to 4 if the integer is less than or equal to 2. Then we equate the land type with value of 2 or 3 when the integer is between 2 and 8, 8 and 15 respectively. While for other integers, that will be equal to 1.\n\nNext we can modify the economic power with exactly the same way as the instance shown in the last chapter.\n\n### Practical Exercise\n\n1. Declare the \`upgrade()\` procedure below the \`castlesum()\` procedure, without return value, in the \`BuildCastle\` module, the parameter of which is a mutable borrowing for the castle resource \`ref\`;\n2. Declare the economic power \`x: u64\` and the random number \`rand: u64\` in the \`upgrade()\` procedure, and assign the \`economic\` field of \` ref\` to \`x\`;\n3. Determine the corresponding land type via the random number procedure;\n4. Increase the castle’s economic power according to the land type.\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n    //Enter the code here.\n\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n    public upgrade(ref: &mut Self.Castle)\n    {\n        let x: u64;\n        let rand: u64;\n        x = *&copy(ref).economic;\n        if (copy(rand)<=15)\n        {\n            if(copy(rand)<=8)\n            {\n                if(copy(rand)<=2)\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*40/100;\n                }\n                else\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*20/100;\n                }\n            }\n            else\n            {\n                *(&mut copy(ref).economic) = copy(x) + move(x)*10/100;\n            }\n            \n        }\n        else\n        {\n            *(&mut copy(ref).economic) = copy(x) + move(x)*5/100;\n        }\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    public annexation () acquires CastleAccount\n    {\n        let add: address;\n        let ref: &mut Self.CastleAccount;\n        let t: &mut BuildCastle.Castle;\n        add = get_txn_sender();\n        ref = borrow_global_mut<CastleAccount>(move(add));\n        t = &mut move(ref).new_castle;\n        BuildCastle.upgrade(move(t));\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 4 Level Up Your Castle",
            instruction: `## Chapter 4 Level Up Your Castle\n\nNext we are about to implement the castle upgrading function.\n\nIn essence, the logic for upgrading the level and increasing economic power is consistent, both of which are modifications to the certain field value in the resource. \n\nHowever, it should be noted that due to the addition of some variables and operations, we ought to carefully determine the application of \`move\` and\` copy\`.\n\n### Practical Exercise\n\n1. Declare the castle level \`r: u64\` and corresponding upper limit of the economic power \` u: u64\` after the random number declaration in the \`upgrade()\` procedure;\n2. Assign the \`level\` field of \`ref\` to \`r\`, and initialize\` u\` according to the \`r\` below the code for increasing economic power;\n3. Determine whether the castle needs to be increased by one level in accordance with the relationship between the value of the increased economic power and \`u\`. \n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n    public upgrade(ref: &mut Self.Castle)\n    {\n        let x: u64;\n        let rand: u64;\n        //Enter the code here.\n\n        x = *&copy(ref).economic;\n        if (copy(rand)<=15)\n        {\n            if(copy(rand)<=8)\n            {\n                if(copy(rand)<=2)\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*40/100;\n                }\n                else\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*20/100;\n                }\n            }\n            else\n            {\n                *(&mut copy(ref).economic) = copy(x) + move(x)*10/100;\n            }\n            \n        }\n        else\n        {\n            *(&mut copy(ref).economic) = copy(x) + move(x)*5/100;\n        }\n        //Enter the code here.\n\n        return;\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n    public upgrade(ref: &mut Self.Castle)\n    {\n        let x: u64;\n        let rand: u64;\n        let r: u64;\n        let u: u64;\n        x = *&copy(ref).economic;\n        if (copy(rand)<=15)\n        {\n            if(copy(rand)<=8)\n            {\n                if(copy(rand)<=2)\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*40/100;\n                }\n                else\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*20/100;\n                }\n            }\n            else\n            {\n                *(&mut copy(ref).economic) = copy(x) + move(x)*10/100;\n            }\n            \n        }\n        else\n        {\n            *(&mut copy(ref).economic) = copy(x) + move(x)*5/100;\n        }\n        r = *&copy(ref).level;\n        u = 10 * copy(r) + Math.pow (2, copy(r));\n        if ( *(&mut copy(ref).economic) > move(u))\n        {\n            *(&mut move(ref).level) = move(r) + 1;\n        }\n        else\n        {\n            *(&mut move(ref).level) = move(r);\n        }\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    public annexation () acquires CastleAccount\n    {\n        let add: address;\n        let ref: &mut Self.CastleAccount;\n        let t: &mut BuildCastle.Castle;\n        add = get_txn_sender();\n        ref = borrow_global_mut<CastleAccount>(move(add));\n        t = &mut move(ref).new_castle;\n        BuildCastle.upgrade(move(t));\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 5 Impose Constraints",
            instruction: `## Chapter 5 Impose Constraints\n\nSo far, we’ve implemented the castle upgrading function!\n\nHowever, we are reluctant to witness a player increasing the economic power and the castle’s level at will, meaning constraints have to be imposed on castle upgrading.\n\nSince the Move language still has not achieved how to acquire time, we decide to limit the land annexation times by the block height, where every 100 increase in block height renders players a chance to annex land.  \n\nSpecifically, we shall record the block height of the last successful initiation for land annexation in the account. When the player attempts to annex land, we are supposed to examine whether the current block height is 100 higher than that of the last block. If so, carry out the \`upgrade ()\` function; otherwise we won’t perform any operations.  \n\n### Practical Exercise\n\n1. Add \`height: u64\` to the \` CastleAccount\` resource ( below \`new_castle\` ), which is used to record the block height when the last time the account successfully initiated land annexation;\n2. In the \`newAccount()\`  procedure , initialize the variable \`height: u64\` to the account’s block height as the account created ( The declaration is below \`SerialNum\`, and the initial assignment sits right beneath \`castle\` ) and import the module \`Block\` ;  \n3. Declare \`h1: u64\` and \`h2: u64\` ( below \`t\` ) in the \`annexation()\` procedure, where \` h1\` is used to record the block height of the castle account, and \`h2\` for the block height when the procedure is called;  \n4. Retrieve the recorded block height \`h1\` of the castle account and initialize \`h2\` underneath \`t = &mut move(ref).new_castle\`;\n5. Compare the difference between \`h1\` and \`h2\` to determine whether \`upgrade()\` should be called;\n6. Check up whether \`move\` and\` copy\` are applied properly in this procedure.\n`,
            type: 0,
            codes:[
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    //Import the Block module here\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        //Enter the code here.\n\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {\n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        //Enter the code here.\n\n        let castle: BuildCastle.Castle;        \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        //Enter the code here.\n\n        //Modify the code here.\n        return CastleAccount { new_castle: move(castle), account_events: move(event_handle)};\n    }\n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    public annexation () acquires CastleAccount\n    {\n        let add: address;\n        let ref: &mut Self.CastleAccount;\n        let t: &mut BuildCastle.Castle;\n        //Enter the code here.\n\n        add = get_txn_sender();\n        ref = borrow_global_mut<CastleAccount>(move(add));\n        t = &mut move(ref).new_castle;\n        //Modify the code here.\n        BuildCastle.upgrade(move(t));\n        return;\n    }\n}",
                    answer: "module CastleAccount {\n    import Transaction.BuildCastle;\n    import Transaction.Math;\n    import 0x0.Event;\n    import 0x0.Block;\n    resource CastleAccount {\n        new_castle: BuildCastle.Castle,\n        height: u64,\n        account_events: Event.Handle<Self.AccountEvent>\n    }\n    struct AccountEvent {\n        flag: u64 \n    }\n    public newAccount (name:bytearray) : Self.CastleAccount\n    {                \n        let SerialDigits: u64;\n        let SerialLimit: u64;\n        let SerialNum: u64;\n        let height: u64;\n        let castle: BuildCastle.Castle; \n        let event_handle: Event.Handle<Self.AccountEvent>;\n        event_handle = Event.new_event_handle<Self.AccountEvent>();\n        SerialDigits = 8;\n        SerialLimit = Math.pow(10, copy(SerialDigits));\n        SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n        castle = BuildCastle.newCastle(move(name), move(SerialNum));\n        height = Block.get_current_height();\n        return CastleAccount { new_castle: move(castle), height: move(height), account_events: move(event_handle)};\n    }    \n    public publishAccount (account: Self.CastleAccount) acquires CastleAccount\n    {\n        let account_event: Self.AccountEvent;\n        let account_add: address;\n        let account_ref: &mut Self.CastleAccount;        \n        account_add = get_txn_sender();\n        account_ref = borrow_global_mut<CastleAccount>(copy(account_add));\n        account_event = AccountEvent { flag: 1 };\n        Event.emit_event<Self.AccountEvent>(&mut move(account_ref).account_events, move(account_event));\n        move_to_sender<CastleAccount>(move(account));\n        return;\n    }\n    public annexation () acquires CastleAccount\n    {\n        let add: address;\n        let ref: &mut Self.CastleAccount;\n        let t: &mut BuildCastle.Castle;\n        let h1: u64;\n        let h2: u64;\n        add = get_txn_sender();\n        ref = borrow_global_mut<CastleAccount>(move(add));\n        t = &mut copy(ref).new_castle;\n        h1 = *&copy(ref).height;\n        h2 = Block.get_current_height();\n        if (copy(h2)-copy(h1) >= 100)\n        {\n            BuildCastle.upgrade(move(t));\n            *(&mut move(ref).height) = move(h2);\n        }\n        else\n        {\n            _ = move(t);\n            *(&mut move(ref).height) = move(h1);\n        }\n        return;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle acquires CastleSum{\n        let a: u64;\n        let b: u64;\n        let sum_ref: &mut Self.CastleSum;\n        let sum_ref_value: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        sum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        sum_ref_value = *&copy(sum_ref).sum;\n        *(&mut move(sum_ref).sum) = move(sum_ref_value) + 1;\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global_mut<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n    public upgrade(ref: &mut Self.Castle)\n    {\n        let x: u64;\n        let rand: u64;\n        let r: u64;\n        let u: u64;\n        x = *&copy(ref).economic;\n        if (copy(rand)<=15)\n        {\n            if(copy(rand)<=8)\n            {\n                if(copy(rand)<=2)\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*40/100;\n                }\n                else\n                {\n                    *(&mut copy(ref).economic) = copy(x) + move(x)*20/100;\n                }\n            }\n            else\n            {\n                *(&mut copy(ref).economic) = copy(x) + move(x)*10/100;\n            }\n            \n        }\n        else\n        {\n            *(&mut copy(ref).economic) = copy(x) + move(x)*5/100;\n        }\n        r = *&copy(ref).level;\n        u = 10 * copy(r) + Math.pow (2, copy(r));\n        if ( *(&mut copy(ref).economic) > move(u))\n        {\n            *(&mut move(ref).level) = move(r) + 1;\n        }\n        else\n        {\n            *(&mut move(ref).level) = move(r);\n        }\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.CastleAccount;\nmain(name: bytearray) {\n    let account: CastleAccount.CastleAccount;\n    account = CastleAccount.newAccount(move(name));\n    CastleAccount.publishAccount(move(account));\n    return;\n}",
                },
            ]
        },
        ]
}

const lessons = [lesson1, lesson2, lesson3, lesson4, lesson5, lesson6];

export default lessons;

