import React from 'react';
import L1c1 from '../L1C1/L1C1'

const lesson1 = {
    info: {
        name: "Move Castle",
        subname: ["Learning Libra Move within 7 days", "*Based on Libra Commit 61649eb"],
        intro: "In the existing blockchain system, with \"currency\" and \"application\" programmed by Bitcoin and Ethereum respectively, Libra, by contrast, programs \"asset\".\n\nIn Libra,  one can define some types of assets called \"resources\" that are more complex than currency. Libra prevents inappropriate modifications by limiting resource utilization with Move programming language, thereby improving asset security.\n\nMove provides a secure and programmable foundation for Libra blockchain. The way that Move programs  \"assets\" with strict  security restrictions makes it suitable for issuing digital currencies, processing blockchain transactions and managing validators.\n\nIn this course, we build a castle by using Move programming language, implementing castle expansion and battle functions to help beginners learn the language much more effectively.",
        goback: "←Back",
        editor: "Editor",
        lesson: "Lesson",
        copyAnswer: "Copy Answer",
        learnmore: "Learn More",
        start: "Start",
        indexpage:"https://learnlibramove.com/",
        learninide:["The code in the course can be compiled in ChainIDE","Go to ChainIDE"],
        practice: "Start Now",
    },
    local: {
        hint: "HINT",
        previous: "PREVIOUS",
        next: "NEXT",
        catalog: "CONTENT",
        checkcode: "Check Answer",
        showAnswer: "Show Answer",
        hideAnswer: "Hide Answer",
        contitle: ["Congratulations that you have completed this chapter!", "Congratulations that you have completed this LESSON!", "KEEP GOING!"],
        concontent: ["Click \"Continue\" to meet new challenges !", "Click \"Back\" to back to the catalog page ! Click \"next lesson\" to continue to learn new knowledge about the Libra!", "Hi~ congratulations, you have completed all the lessons of the course now. More lessons will be presented soon. Now let's go to ChainIDE and write our own Libra Move contracts to have fun !"],
        concontinue: ["Continue", "Back", "Go to ChainIDE", "Next Lesson"],
        shut: "close",
        target: "Introduction",
        keypoint: "Knowledge Points",
        detail: "View Details"
    },
    lessonserial: "Lesson 1",
    title: "",
    intro: ["In Lesson 1, we will guide you to build your own castle world in a step-by-step way. Your castle will have a unique appearance with unexpected creatures living in it.","How to create a contract;Modules in Move;main() in Move;Variables and data type;Procedures in Move"]
    ,
    key: 1,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 Introduction",
            instruction: `## Chapter 1 Introduction\n\nIn this chapter, we will learn how to build a castle.\n\n​	- We will use modules to build a new castle\n\n​	- Our castle will be stored in the database, i.e., Libra Blockchain\n\nIn the following, we will add more functions to our castle, such as enhancing its power, fighting with other castles. But before that, we should first realize the function of creating a castle.\n\n### What are the properties of the castle?\n\nEach castle has its name, serial number, level, economic  and military powers. The serial number determines the appearance of the castle and the race of creatures in the castle. The level determines the value of the castle. The economic and military powers affect the performance of the castle when interacting with other castles.\n\n### How does the serial number affect the castle?\n\nThe appearance of a castle and its race are decided by an 8-digit integer, which is named as the serial number, such as 83451029.\n\nEach digit of the serial number corresponds to a property of the castle. In particular,\n\n|  1   |   2   |   3   |     4      |     5      |       6       |  7   |     8      |\n| :--: | :---: | :---: | :--------: | :--------: | :-----------: | :--: | :--------: |\n| size | style | color | logo style | logo color | logo position | race | special ID |\n\nThe name of each newly built castle is input by the user; the serial number is randomly generated according to the depth of the current block; the level is initialized as 1; the initial economic and military powers are determined by the race digit in the serial number. The corresponding relationships are defined as follows:\n\n|   Race digit   | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------------: | :--: | :--: | :--: | :--: | :--: |\n| Economic power |  6   |  8   |  3   |  7   |  4   |\n| Military power |  6   |  3   |  8   |  4   |  7   |\n\n### Practical Exercise\n\n1. Please drag the slider on the right side of the page to explore the appearance of the castle corresponding to a specific serial number.\n\n\n **With the above basic knowledge, you can click the Next Chapter button to continue learning Move.**\n\n\n`,
            type: 1, 
            show() {
                return <L1c1 lang="1" />
            }
        },
        {
            title: "Chapter 2 Modules in a Contract",
            instruction: `## Chapter 2 Modules in a Contract\n\nA contract is a computer program that runs on a blockchain. We use a contract to complete a series of operations on the blockchain, such as transferring money, purchasing goods, and so on.\n\nThe overall code of a contract in Move is divided into the following two parts:\n\n​	- module part starting with modules:\n\n​	- \`main()\` starting with script:\n\nWe'll introduce the modules section in this chapter and the script section in the next.\n\n### Modules\n\nThe module part contains the modules needed for a contract. A module is the basic package unit of the Move contract and all modules deployed on Libra are global.\n\nIn a module, we can define \`Struct\`, \`Resource\` and \`Procedure\`, which will be introduced in subsequent chapters.\n\nThe module is similar to the smart contract in Ethereum, as well as the class in Java. We can regard the module as a code block with a certain function, which uses the interface to access the internal information of the module.\n\nFor example, the \`Libracoin\` module is officially released by Libra, which defines Libra Coin and has the process of transferring  Libra Coin as well as recharge. After the developer introduces the module, the interface can be used to implement related functions.\n\n#### How to build a module\n\nWe create a module with the format of \`module module_name { }\`.\n\n#### How to import a module\n\nSimilar to \`package name + class name\` in java, Move employs \`address + module name\` to import a module. For example,\n\n\`import 0x0.LibraCoin\`\n\nwhere \`LibraCoin\` is the module name and  \`0x0\` is the account address for publishing the module.  Each user can publish his or her own module on the blockchain, or import modules published by others in this way. The address of all modules published by Libra are \`0x0\`.\n\nWhen importing modules from the same file, we can use \`import Transaction.module name\` to achieve this goal. For example,\n\n\`import Transaction.LibraCoin\`\n\n### Practical Exercise\n\nTo build our castle, we'll start with a module called \`BuildCastle\`, in which we'll gradually implement a series of castle building functions.\n\n1. Build an empty module \`BuildCastle\`\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "//Enter the code here",
                    answer: "module BuildCastle {\n\n}"
                },
            ]
        },
        {
            title: "Chapter 3 main() in a Contract",
            instruction: `## Chapter 3 \`main()\` in a Contract\n\n### main()\n\nWe learned how to build a module in the previous chapter, and we will complete the contract based on the module in this chapter. \n\nWe can embed a piece of one-time execution code in a contract, which is called Transaction Script and cannot be called by other codes. The Transaction Script starts with \`script:\`.\n\n\`main()\` is the entry to execute the transaction script. We name code blocks like \`main()\` as \"procedures\" and will detail their concepts in subsequent chapters. \`main()\` is actually a special procedure.\n\nNote that all procedures, including \`main()\`, should end with \`return\`. Move compiler is literal: it will translate the source code directly without doing anything else, such as inserting a missing \`return\`.\n\nWhen writing the Move contract, we usually write all operations in the ordinary procedures rather than  \`main()\`, and put the ordinary procedures into the modules. Finally, we import the modules in the script section,  calling the procedures in the module with \`main()\` as the entrance to complete a series of operations. The overall idea is shown in the figure below.\n\n<img src=${require("../../static/images/lesson1/pic_1_2_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\nNotice that when we need to import other modules in a module, the import statement should appear at the first line of the module, i.e., the next line of the module name. And when we need to import a module in the script section, the import statement should appear at the first line of this section, i.e., the next line of \`script:\`, and the first line of \`main()\`.\n\nIn summary, we present a basic example of an empty contract as follows:\n\n\`\`\`\nmodules: \nmodule Contract {\n\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    return;\n}\n\`\`\`\n\n### Practical Exercise\n\nIn order to build our castle, we first need create an empty contract including a module named \`BuildCastle\` and \`main()\`.\n\n1. First, add \`modules:\` and \`script:\`;\n3. Add \`main()\` in the next line of \`script:\`. Remember to add \`return\` in \`main()\`;\n4. Import the module in the script section (at the line before \`main()\`).\n\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "//Enter the code here\nmodule BuildCastle {\n\n}\n//Enter the code here\n",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 4  Variable binding and data type",
            instruction: `## Chapter 4  Variable binding and data type\n\n### Variable binding\n\nVariable binding refers to binding some values to a variable so that they can be used later.\n\nSimilar to Rust, Move uses \`let\` to bind variables, which follows the format of  \`let variable: variable type;\`. For example,\n\n\`\`\`\nlet x: u64;\n\`\`\`\n\nAfter variable binding, we can use \`=\` to initialize the variable. For example,\n\n\`\`\`\nx = 5;\n\`\`\`\n\nIt is worth noting that  variables should be bound at first in any process.  In other words, all \`let\` lines should be put at the very beginning; otherwise, inserting any \`let\` line within the code block will lead to the compilation error.\n\n### Data Types\n\nAt present, Move supports the following data types:\n\n​	- \`boolean\`\n\n​	- \`uint64\`\n\n​	- \`address\`\n\n​	- \`bytes\`\n\n​	- \`struct\`\n\n​	- \`resource\` (a unique data type in Move)\n\nwhere boolean-type data should be declared as \`bool\`, uint64-type data should be declared as \`u64\`, address-type data as \`address\`, and bytes-type data as \`bytearray\`. For example, we can declare variables as follows:\n\n\`\`\`\nmain() {\n    //Variable bindings\n    let a: u64;\n    let b: bool;\n    let c: address;\n    let d: bytearray;\n    //Initialize\n    a = 1;\n    b = true;\n    c = 0x0;\n    d = h \"123abc\";\n    return;\n}\n\`\`\`\n\nWe can also declare resource and struct as follows:\n\n\`\`\`\nmodule Test {\n    resource NonEmpty1 {\n        f1: u64,\n        f2: bool\n    }\n    struct Empty1 {}\n    resource Empty2 {}\n    resource NonEmpty2 {\n        f1: bool,\n        f2: u64\n    }\n}\n\`\`\`\n\nwhere \`f1\` and \`f2\` are two variables.\n\nNote that since Move cannot automatically initialize variables, we should not use variables without initialization.\n\n### Practical Exercise\n\nThe serial number of a castle serial consists of an 8-digit number, so we use a modulo operation (\`%\`) to limit the randomly generated serial numbers to 8-bit integers.  Before that, we first need a variable called \`SerialDigits\`, which is used to represent the number of digits in a serial number. This is the main task in this chapter.\n\nIn the process of \`main()\`, we declare \`SerialDigits\` as \`u64\` and initialize it as 8.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nmain() {\n    let SerialDigits: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 Procedures",
            instruction: `## Chapter 5 Procedures\n\nAs mentioned in Chapter 2,  \`procedures\` can be defined in modules, which are similar to \`functions\` in other programming languages.\n\n### Declaration of a Procedure\n\nTo declare a procedure, we need to declare its visibility, name, parameters, and return value(s) in the following format:\n\n\`Visibility Process name (parameter name): The type of return value\`\n\nIt should be noted that in the case where the procedure has no parameter, there is no need to declare the parameter name; in the case of no return value, there is no need to declare the return type.\n\nThe process in the module has two kinds of visibility:\n\n​	- public: public procedures can be called by other modules\n\n​	- private: private procedures can only be called by procedures in the same module. The resources in the module are private and can only be accessed by other modules through public procedures.\n\nWhen the procedure to be declared has neither parameters nor return values, it should be declared in the following format:\n\n\`\`\`\npublic Procedure() { \n	return;\n}\n\`\`\`\n\nWhen the procedure to be declared has parameters, we should declare it as:\n\n\`\`\`\npublic Procedure(a: u64, b: u64) { //The form is similar when the types of parameters are different or when there are more (or fewer) parameters\n    return;\n}\n\n\n\`\`\`\n\nNote that the procedure itself can also be employed a parameter of other procedures .\n\nIf the procedure to be declared has return values, it should be declared as:<u></u>\n\n\`\`\`\npublic Procedure(a: u64, b: u64) : u64 { //The form is similiar When type of the return value is different\n    return 1;\n}\n\n\n\`\`\`\n\nIn the above examples, we only define public procedures. If you want to declare a private procedure, then just delete \`public\`.\n\n### Call a Procedure \n\nA procedure is called by \`module name.procedure name\`. If a procedure  needs to be called by another procedure in the same module,  we should use the format of  \`Self.procedure name\`.\n\nThe following is an example of declaring and calling a procedure:\n\n\`\`\`\nmodules:\nmodule Contract {\n    public Procedure() { //A public procedure is declared whose name is Procedure\n        return;\n    }\n}\n\nscript: \nimport Transaction.Contract;\nmain() {\n    Contract.Procedure(); //Call the procedure whose module name is Contract\n    return;\n}\n\n\n\`\`\`\n\n### Practical Exercise\n\nAs mentioned in the previous chapter,  we will use the modulo operation (\`%\`) to convert the serial number to an 8-bit integer. Specifically, a number modulo 10<sup>n</sup> results in an n-digit integer, so here we employ a procedure to calculate 10<sup>8</sup>. \n\n1. Create a \`Math\` module before the \`BuildCastle\` module, which will include all the math operations in this course.\n\n2. Declare the procedure \`pow()\` to conduct the power operation in the newly created module as follows:\n\n   ​    - Parameters: the base x and the exponent n of type \`u64\`\n\n   ​    - Return value: the power operation result of type \`u64\`\n\n   ​    - Process content: temporarily empty. In order to compile successfully, let's set its return value as 1. We will implement its function in the next chapter.\n\n3. Import the \`Math\` module before \`main()\` and declare a \`u64\` variable named \`SerialLimit\` after \`SerialDigits\`, which represents the number of digits in the serial number.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \n//Enter the code here\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\n//Enter the code here\n\nmain() {\n    let SerialDigits: u64;\n    //Enter the code here\n\n    SerialDigits = 8;\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\n\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    return;\n}"
                },
            ]
        },
    ]
};

const lesson2 = {
    lessonserial: "Lesson 2",
    title: "",
    intro: ["In the first lesson, we have learned variable-related operations, successfully declaring the serial number of a castle, which lays the first cornerstone for establishing the castle. In Lesson 2, we will guide you to build the framework of the castle,  creating your own castle world. ","Ownership;Program structs  in Move;Structures;Arithmetic operations;Procedures with multiple return values"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "Chapter 1 Ownership",
            instruction: `## Chapter 1 Ownership\n\n### The usage of ownership\n\nIn the previous chapters, we mentioned the word \"binding\". In fact,the word refers to binding of ownership. Only when an identifier has  the ownership of some value can we access this value through the identifier.\n\nWhen binding a value to a name (an identifier), we bind the ownership of this value (resource) to the identifier. For example:\n\n\`\`\`\nlet x: u64;\nx = 3;\n\n\`\`\`\n\nWhen we bind the resource with type (\`u64\`) and value (\`3\`) to identifier \`x\` through the statement \`let\`, \`x\` has the ownership of this resource, during which the identifier retains exclusive ownership of the resource, such as accessing and changing its value. However,  the identifier will no longer have value ownership once the binding has been transferred to another identifier.\n\n### The transfer of ownership\n\nWhen we are going to transfer ownership, we have to use \`move()\` function, instead of equal sign (\`=\`), to implement for reasons of memory safety.\n\nThat is, in Move, identifiers can’t be connected with equal sign (\`=\`), which can only be used between identifiers and values. For example,the following code is incorrect:\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nx = 3;\ny = x; //error\n\n\`\`\`\n\nWe give an example to illustrate how to transfer ownership as follows:\n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = move(x); //Move the ownership of 3 from identifier x to identifier y.\nz = move(x); //error: now, the identifier x has lost ownership and is an uninitialized variable, so move(x) fails\nz = move(y); //Move the ownership of 3 from identifier y to identifier z.\nx = 3; 	//Reinitialize the identifier x.\nz = move(x); //At this point, the ownership of 3 can be transferred from identifier x to identifier z by move().\n\n\`\`\`\n\n### The copy of ownership\n\nBy using \`copy()\` function, the value of an identifier is able to equal to that of another identifier without transferring the ownership.  In this case,  the identifier can still be accessed even after implemented by the function \`copy()\` .  For instance, \n\n\`\`\`\nlet x: u64;\nlet y: u64;\nlet z: u64;\nx = 3;\ny = copy(x); //Copy the onwship of 3 from identifier x to identifier y.\nz = move(x); //Move the onwship of 3 from identifier x to identifier z.\n\n\`\`\`\n\nIt should be noted that when calling a procedure and passing in parameters, we are not allowed to use the parameters directly. Instead, we need transfer ownership to the procedure by using functions of \`move (the parameter name)\` or \`copy(the parameter name) \`, and which one should be implemented depends on how to use the parameters.\n\n### Practical Exercise\n\nIn the previous lesson we declared \`SerialLimit\`. In this chapter,  we would like to set the value of this parameter to 10<sup>SerialDigits</sup>, thereby calling \`pow()\` function to initialize \`SerialLimit\`, which has two parameters, 10 and \`SerialDigits\` respectively.\n\nThe task above requires passing a variable as a parameter to the \`pow()\` procedure, which involves the ownership transfer. Considering \`SerialDigits\` may be used again in the following chapters,  we use \`copy()\` function instead. At this point the \`pow()\` function is still undefined, which will be implemented in the next chapter.\n\nThe parameter \`SerialLimit\` will be initialized by calling the \`pow()\` function in the \`main()\` procedure, in the form of \`module name.function name\`, which has been introduced in the previous chapter. You’d better review if you have forgotten.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        return 1;\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 2 The structs of a program",
            instruction:`## Chapter 2 The structs of a program\n\nSimilar to other languages, Move also has common program structures such as selection and looping.\n\nWe can implement simple selection structure by using if-else statement, with the following specific rules:\n\n1. The branch statements must be enclosed in braces ( \`{}\` ), even if there is only one statement. The following example is incorrect:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;	//Here x = 3 should be in {}.\n       return;\n   }\n   \n   \`\`\`\n\n2. There’s no need for braces to end with semicolon that is added to the end of each branch statement. The following example is also incorrect:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) x = 3;\n       else {\n           x = 5\n       };	//The semicolon here should appear at the end of the previous line.\n       return;\n   }\n   \n   \`\`\`\n\n3. If an identifier is initialized in a branch statement that doesn’t contain all cases, the identifier can’t be accessed after the branch ends. The example as follow is wrong:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       }	//Here, the variable x is initialized only in the if branch, whereas in the case of the else branch, it is uninitialized. so we cannot use copy(x) later.\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \n   \`\`\`\n\n   With the branch containing all cases, the identifier can be accessed after the end of the branch, as shown in the following example:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       if (true) {\n           x = 42;\n       } else {\n           x = 43;\n       }	//The two branches here contain true and false, which means that the variable x will be initialized no matter what happens. So we can use copy(x) later\n       assert(copy(x) == 42, 42);\n       return;\n   }\n   \n   \`\`\`\n\n4. When using the move() function in a branch statement, make sure to be aware of ownership problem. The identifier implemented by this function shouldn’t be accessed again after the branch ends. The following example is incorrect:\n\n   \`\`\`\n   main() {\n       let x: u64;\n       let y: u64;\n       x = 0;\n       if (true) {\n           y = move(x);	//In this branch we transfer ownership of the variable x to the variable y, so in the following code, we cannot access the variable x again by copy(x).\n       }\n       assert(copy(x) == 0, 42);\n       return;\n   }\n   \n   \`\`\`\n\nWe can also implement the looping structure through \`loop\`. This chapter is not going to give detailed information due to limited space, and that will be introduced in subsequent chapter.\n\n### Practical Exercise\n\nRecursion is the most common way to implement power function. Here is an example of power function in C language as follow:\n\n\`\`\`\nint pow(int x, int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return pow(x * x, n / 2);\n    } else {\n        return pow(x * x, n / 2) * x;\n    }\n}\n\n\n\`\`\`\n\nPlease emulate the above program and implement the \`pow()\` function in the \`Math\` module, paying attention to variable ownership problem and using  \`copy()\` and \`move()\` functions appropriately.\n\n\n`
,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        //Enter the code here\n        \n        return 1; //Delete the code here\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n}\nmodule BuildCastle {\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 3 Structs",
            instruction: `## Chapter 3 Structs\n\nStructure in Move, similar to that in other languages, is a data set consisting of a collection of data with the same or different types . We can declare a structure in the form of \`struct name{data: type, data: type, ...}.  \`For instance,\n\n\`\`\`\nmodule Test {\n	//Empty struct\n  	struct Empty1 { }\n  	//Struct with two members\n  	struct T { a: u64, b: u64 }\n}\n\n\`\`\`\n\nNote:\n\n- Structures can only be declared at the very beginning of a module rahter than in a procedure\n- Structures can also be implemented by \`copy ()\` or \`move ()\` functions\n\nMore on structures will be introduced and covered in subsequent chapters.\n\n### Practical Exercise\n\nPlease declare a structure named \`Castle\` in the \`BuildCastle\` module, which contains five members: \`name (bytearray)\`, \`SerialNum (u64)\`, \`level (u64)\`, \`economic (u64)\` and \`military (u64)\`.\n\n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n}\nmodule BuildCastle {\n	//Enter the code here\n	\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n}\nmodule BuildCastle {\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 4  Arithmetic operations",
            instruction: `## Chapter 4  Arithmetic operations\n\nIn the previous sections, we have used some basic arithmetic operations, such as addition and multiplication. In this chapter, we will take a closer look at  the arithmetic operations that Move has implemented.\n\nAt present, Move has realized the following arithmetic operations: addition \`+\`, subtraction \`-\`, multiplication \`*\`, division \`/\` and module \`%\`. The specific examples of using them are as follows:\n\n\`\`\`\nmain() {\n    let a: u64;\n    a = 1 + 2;\n    a = 3 - 2;\n    a = 2 * 3;\n    a = 6 / 2;\n    a = 5 % 2;\n    return;\n}\n\n\n\`\`\`\n\nMove has also implemented the comparison operations, such as  greater than \`>\`, less than \`<\`, equal to \`==\`, greater than or equal to \`>=\`, less than or equal to \`<=\` and not equal to \`!=\`. The corresponding examples are detailed as: \n\n\`\`\`\nmain() {\n    let a: bool;\n    a = (1 == 1);\n    a = (1 == 2);\n\n    a = (1 != 2);\n    a = (1 != 1);;\n\n    a = (2 > 1);\n    a = (1 > 1);;\n\n    a = (1 >= 1);\n    a = (0 >= 1);\n\n    a = (1 < 2);\n    a = (2 < 1);\n\n    a = (1 <= 1);\n    a = (2 <= 1);\n\n    return;\n}\n\n\n\`\`\`\n\nIn addition, several kinds of bit operations and boolean operations are also implemented in Move. We will introduce them in the following chapters in detail.\n\n### Practical Exercise\n\nIn our game, the serial number of a castle is randomly generated according to the height of the current block. \n\nThe most basic algorithm to generate random number is implemented by the modular operation.\n\nThe following is an example that implements a simple pseudo-random number using C programming language. Obviously, the sequence of random numbers produced by such a program depends on the initial value of next.\n\n\`\`\`\nstatic unsigned long next = 1;\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return ((unsigned)(next / 65536) % 32768);\n}\n\n\`\`\`\n\nThrough slightly modifying the above procedure, we can get the following program that generates a random number according to the input seed: \n\n\`\`\`\nint myrand(int seed) {\n    rand = seed * 1103515245 + 12345;\n    return ((unsigned)(rand / 65536) % 32768);\n}\n\n\`\`\`\n\nIn the same way as in any other language, we can take advantage of modular operations to make our program eventually generate random numbers within a specified range. In detail, to generate random numbers from m to n,  we can use the following code:\n\n\`\`\`c\nmyrand(seed) % (n - m + 1) + m;\n\n\`\`\`\n\n1. Following the above random number generation program, please add the random number generation procedure \`myrand()\` in the \`Math\` module, and then implement its specific functions.\n2. Please add and implement the public procedure \`generateSerial()\` in the \`BulidCastle\` module, which calls the \`myrand\` procedure in the \`Math\` module to generate a random 8-bit serial number (i.e., a random number between 10^<sup>7</sup>and 10<sup>8-1</sup>) based on the height of the current block.\n   - The height of the current block can be obtained by the \`get_current_height()\` method in the \`Block\` module.\n   - The address of the module \`Block\` is \`0x0\`.\n   - Import \`Math\` and \`Block\` modules in the correct places.\n3. Declare \`SerialNum\` in main() and initialize it through the \`generateSerial()\` procedure.\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    //Enter the code here\n    \n}\n\nmodule BuildCastle {\n    //Enter the code here\n\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    //Enter the code here\n    \n}\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    //Enter the code here\n    \n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 Procedures with multiple return values",
            instruction: `## Chapter 5 Procedures with multiple return values\n\nIn Chapter 5, we introduced the procedure and illustrated how to use the procedure with a single return value. However, in many scenarios, we need to use a procedure with multiple return values, which will be introduced in this chapter.\n\nAccording to Chapter 5, we can declare a procedure with a single return value as follows:\n\n\`\`\`\npublic procedure name( parameter name 1，parameter name 2，...) : reture type {...}\n\n\`\`\`\n\nSimilarly, we take the procedure with two return values as an example, which can be declared as follows:\n\n\`\`\`\npublic procedure name( parameter name 1，parameter name 2，...) : reture type * reture type {...}\n\n\`\`\`\n\nAnd the calling method is:\n\n\`\`\`\nvariable 1, variable 2, ...  = module name.procedure name( parameter name 1，parameter name 2，... )\n\n\`\`\`\n\nWhen using the procedures with multiple return values, we need to pay attention to the following points:\n\n1. When a procedure with multiple return values is operated with another one having a single return value, only the last return value of the first procedure is involved.\n\n   Take the following code as an example, when Line 2 is called in Line 18 as a procedure with multiple return values, the first two return values are the operation results of this procedure while the last one should be derived after operating with the procedure \`bar()\`.\n\n\`\`\`\nmodule M {\n    public foo(u: u64): u64 * u64 * u64 {\n        let twice: u64;\n        let quadruple: u64;\n        twice = 2 * copy(u);\n        quadruple = 4 * copy(u);\n        return move(u), move(twice), move(quadruple);\n    }\n	public bar(): u64 {\n    	return 2;\n	}\n}\nimport Transaction.M;\nmain() {\n    let x: u64;\n    let y: u64;\n    let z: u64;\n    x, y, z = M.foo(5) + M.bar();\n    return;\n}\n\n\`\`\`\n\n2. A procedure with multiple return values can function as  a parameter of another procedure with multiple parameters.\n\n   For example, in the following code block, the procedure with multiple return values in Line 2 becomes the first two parameters in the procedure in Line 25 with three parameters. \n\n\`\`\`\nmodule Test {\n    public foo(v: u64): u64 * u64 {\n        let one_less: u64;\n        let one_more: u64;\n        one_less = copy(v) - 1;\n        one_more = move(v) + 1;\n        return move(one_less), move(one_more);\n    }\n    public baz(k: u64, l: u64, m: u64) : u64 {\n        let z: u64;\n        z =  move(k) + move(l) + move(m);\n        return move(z);\n    }\n}\nimport Transaction.Test;\nmain() {\n    let x: u64;\n    let y: u64;\n    let x0: u64;\n    let x1 : u64;\n    x = 7;\n    x0, x1 = Test.foo(copy(x));\n    y = Test.baz(Test.foo(move(x)), 0);\n    return;\n}\n\n\`\`\`\n\n3. If the Return statement of a procedure with multiple return values apprears at a Switch statement, it is necessary to check that whether the type and number of return values in each branch are uniform.\n\n   For example, the return value of the procedure \`bar()\` appears in Lines 6 ~10, and both return values are with type \`u64\`, which is consistent with the return type when declaring the procedure.\n\n\`\`\`\nmodule A {\n    public foo(t: u64): u64 * u64 {\n       return (copy(t), 2 * move(t));\n    }\n    public bar(k: u64): u64 * u64 {\n        if (copy(k) != 1) {\n            return Self.foo(copy(k));\n        } else {\n            return 3 * Self.foo(move(k));\n        }\n    }\n}\nimport Transaction.A;\nmain() {\n    let x: u64;\n    let y: u64;\n    let u: u64;\n    let v: u64;\n    x, y = A.bar(10);\n    u, v = A.bar(1);\n    return;\n}\n\n\n\`\`\`\n\n### Practical Exercise\n\nAdd the \`racial_judgment()\` procedure to the \`BuildCastle\` module and realize its function: determine the race of the castle based on the serial number, and return the corresponding initial economic  and military powers.\n\n1. Extract the race digit from the serial number, i.e., the 7th digit of the serial number, by modulo and division operations;\n2. Determine the economic and military powers corresponding to the race through the Switch statement, where the relationship between the race and the values of two powers is as follows:\n\n|   race digit   | 0, 5 | 1, 6 | 2, 7 | 3, 8 | 4, 9 |\n| :------------: | :--: | :--: | :--: | :--: | :--: |\n| economic power |  6   |  8   |  3   |  7   |  4   |\n| military power |  6   |  3   |  8   |  4   |  7   |\n\n3. This procedure has two return values in type u64, one for economic power and the other for military power.\n\nTips: How to extract the m-th digit from an n-digit number?\n\n- For an n-digit Num, if you want to extract the first x digits, you can use rounding division Num / 10<sup>n-x</sup>. The result of this operation is the number corresponding to the first x digits. For example, 54312 / 10<sup>5-2</sup>=54;\n- For an n-digit Num, if you want to extract the last x digits, you can use the modulo operation Num / 10<sup>x</sup>, whose r is the number corresponding to the last x digits. For example, 54312 % 10<sup>2</sup> =12;\n- For an n-digit Num, if you want to take the middle x digits, you should convert the problem to one of the above two problems, and then further calculate the final result.\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    //Enter the code here\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle { \n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 6 Refine the design of a castle",
            instruction: `## Chapter 6 Refine the design of a castle\n\nIn Chapter 3, we learned how to declare a struct. In this chapter, we will continue to learn how to initialize a struct and use it in the \`main()\` procedure.\n\nAs shown in the figure below, we often create a procedure to initialize a struct, which should be declared and initialized in the same module. The return value of the procedure used to initialize the struct is with struct type, which initializes the struct by returning a struct with initial member variable values. \n\n<img src=${require("../../static/images/lesson2/pic_2_6_1_en.png")} style="width:80%;position:relative;left:10%">\n\nFor example,\n\n\`\`\`\nmodule Bar {\n    struct T {\n        baz: u64\n    }\n    public new(m: u64) : Self.T {\n        return T {\n            baz: move(m)\n        };\n    }\n}\n\n\`\`\`\n\nIn this example, we declare a struct \`T\` in the module \`Bar\` and initialize the member variables of the struct with the parameters of the procedure by a procedure named new.\n\nIn the new procedure, we return a struct \`T\` whose value of the member variable \`baz\` is the parameter \`m\` of the procedure.\n\nNote that in the above code, the codes from Line 6 to Line 8 are formally similar to the definition of a struct, which is actually a  return statement. Therefore,  there is a semicolon at the end of it.\n\nWhen we want to use struct \`T\` in \`main()\` or other procedures, we can declare the variable as a struct type using let statement and call the new procedure to initialize it. \n\nFor example, the following code initializes the variable \`x\` to a struct \`T\` with a member variable value 10.\n\n\`\`\`\nlet x: Bar.T;\nx = Bar.new(10)\n\n\n\`\`\`\n\n### Practical Exercise\n\nIn the previous chapters, we have learned several important processes to build a castle, so the next step is to combine them and build the castle in the \`main()\` procedure.\n\n1. Add the \`newCastle\` procedure to the \`BuildCastle\` module to initialize a struct-type \`Castle\` variable, where the procedure has two parameters:\n\n   - \`_name (bytearray)\`, indicating the name of our castle\n   - \`_SerialNum (u64)\`, identifying the serial number of the castle\n\n   Note: In order to distinguish from the name and \`SerialNum\` in \`main()\`, we put an underscore in front of the above parameter names.\n\n   This procedure has a return value of type \`Self.Castle\`.\n\n   Please follow the example in our course to initialize a castle based on two parameters，namely \`_name\`, and \`_SerialNum\`.\n\n   Tips: the castle's name and serial number are initialized to the corresponding values. In addition, the castle's level is initialized to 1. And the castle's economic and military powers are initialized to the values calculated by calling the \`racial_judgment()\` procedure.\n\n2. In the main procedure, the name of the castle is entered by the user, so the name parameter is an external input. In this case, we need to add a parameter named name to the \`main()\` procedure with the type bytearray. \n\n3. Add the castle variable to \`main()\` and initialize it. Note: Remember to insert the let statement in the beginning.\n\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    //Enter the code here\n    \n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\n//Modify the content here\nmain() {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    //Enter the code here\n\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    //Enter the code here\n    \n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
    ]
}


const lesson3 = {
    lessonserial: "Lesson 3",
    title: "",
    intro: ["In the previous lessons, we have created a basic castle framework. In the third lesson, we are going to build a fortified castle. ","The concept of resources;How to create and destroy resources;How to create a multi-file structure"],
    key: 2,
    total: 5,
    chapters: [
        {
            title: "Chapter 1 Resources",
            instruction: `## Chapter 1 Resources\n\nIn the existing Blockchain systems, Bitcoin programs “currencies” and Ethereum programs “applications”; Libra, by contrast, programs “assets”, named as “resources”, which are a more complex assets type than currencies.\n\nMove stipulates that the operation of resources has to meet the following two constraints:\n\n- **Scarcity guarantee**:  The total amount of resources must be under control and users are not allowed to copy, reuse or discard resources arbitrarily.\n\n- **Access control**: Resource access must satisfy certain predefined rules.\n\nTo meet the above two constraints, in a Move contract, a resource can only be created or destroyed by the module that defines it and can only be operated with the  \`move()\` function. That is, we are not allowed to replicate resources with the \`copy()\` function.\n\nMove compiler statically verifies that if the above security constraints are met through bytecode, which will refuse to run a program failed to pass the bytecode validation.\n\nFor beginners, a resource can be regarded as a restricted structure for the time being.\n\nDeclaration of a resource is similar to that of a structure: \`resource name {data: type, data: type, ...} \`.\n\nHere is an instance of declaring the \`LibraCoin\` resource: \n\n\`\`\`\nresource T {\n        value: u64,\n}\n\`\`\`\n\n### **Practical exercise**\n\nFor security reasons, we require the castle structure to be modified into a resource.\n\n1. Please change the type of \`Castle\` from structure to resource.\n\n   \n`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    struct Castle {	//Modify the \"struct\" here\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 2  Resource Creation",
            instruction: `## Chapter 2  Resource Creation\n\nTo use a resource, we first need to implement the procedure of creating a resource, the return value type of which is resource.\n\nFor example, the following code creates the procedure \`LibraCoin\` mentioned in the previous lesson, which creates a resource variable \`T\` with a value of 0. \n\n\`\`\`\nresource T {\n        value: u64,\n}\n\npublic zero(): Self.T {\n        return T{value: 0};\n}\n\`\`\`\n\nAs you can see, the creation of resource is similar to the initialization of structure. \n\n### **Practical exercise**\n\nNext we are going to implement the procedure of creating resources. \n\nIn this chapter, we will introduce the concept of 'account',  where each player has an account with corresponding castle. By this means, we associate the castle with the player.  \n\nSpecific functions and operations of an account will be introduced in subsequent courses. This chapter only focuses on creating modules and resources related to the account. \n\n1. Create a module named \`CastleAccount\` below the \`BuildCastle\` module.\n2. Declare  the \`CastleAccount\` resource in the newly created module. For practice, the resource only has one \`u64\` variable named \`a\` for now, which we will refine in the following chapters.\n3. Implement the procedure \`newAccount\` to create the \`CastleAccount\` resource, which initializes the variable \`a\` in the resource to 0.\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\n//Enter the code here\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Chapter 3 Resource Destruction",
            instruction: `## Chapter 3 Resource Destruction\n\nFor the reason that there is no garbage collection mechanism in Move, resources have to be explicitly destroyed after used.\n\nIn Move, a resource is usually destroyed by setting the resource's binding to null through the \`move()\` function.\n\nLet's take a look at a simple instance as follows, which is the destruction procedure for \`LibraCoin\` :\n\n\`\`\`\npublic destroy_zero(coin: Self.T) {\n        let value: u64;\n        T { value } = move(coin);\n        return;\n}\n\`\`\`\n\nIn this procedure, we first declare a local resource variable \`T\` with a member variable \`value(u64)\`, and then rebind the resource \`coin\`, which we want to destroy, to the local resource variable \`T\` through the \`move()\` function. At the end of the procedure, the local resource variable\`T\`  will be automatically destroyed. Consequently, the \`coin\`resource becomes unbound and can no longer be accessed. Since the system will recycle unbound resources, destruction of the resource \`coin\` is achieved as a result.\n\n\n\n### **Practical exercise**\n\nNow that we have created the \`Castle\` and the \`CastleAccount\` resources, we are about to implement their destruction procedures.\n\n1. Create the \`desCastle\` procedure in the \`BuildCastle\` module according to the example in this lesson. The parameter name in this procedure is \`castle\` and the temporary variable name is the same as that used in the previous lesson.\n2. Create the \`desAccount\` procedure in the \`CastleAccount\` module according to the example in this lesson. The parameter name in this procedure is \`account\` and we name the temporary variable \`num\`.\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    //Enter the code here\n\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    //Enter the code here\n\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    return;\n}\n"
                },
            ]
        },
        {
            title: "Chapter 4 Resource Usage",
            instruction: `## Chapter 4 Resource Usage\n\nWith the resources created, we can use them now.\n\nUsage on resources is almost the same as that on structures, except that we are supposed to destroy a resource after having used it.\n\nIn this chapter, we assume that resources are only used in the current transaction script and will not be sent to any address for the time being, which means that the resources need to be destroyed at the end of  \`main()\`.\n\nNext we are going to understand how to use resources with an example as well as review the creation and destruction of resources.\n\n\`\`\`\nmodules:\nmodule MoneyHolder {\n        import 0x0.LibraCoin;\n        resource T { money: LibraCoin.T }\n        public new(m: LibraCoin.T): Self.T {\n            return T{ money: move(m) };\n        }\n        public destroy_t(t: Self.T) {\n            let money: LibraCoin.T;\n            T{ money } = move(t);\n            LibraCoin.destroy_zero(move(money));\n            return;\n        }\n}\nscript:\nimport Transaction.MoneyHolder;\nimport 0x0.LibraCoin;\nmain() {\n    let coin: LibraCoin.T;\n    let money_holder: MoneyHolder.T;\n    coin = LibraCoin.zero();\n    money_holder = MoneyHolder.new(move(coin));\n    MoneyHolder.destroy_t(move(money_holder));\n    return;\n}\n\n\`\`\`\n\nIn this instance, we declare a module named \`MoneyHolder\` with a resource \`T\` that is created with the procedure in Line 5 and destroyed through the procedure in Line 8.\n\nIt should be noted that the member variable of resource \`T\` is also a resource. Therefore, when destroying \`T\`, two destructions (Line 10 and Line 11) are required, where the second destruction is to call the \`LibraCoin.destroy_zero()\` procedure in the \`LibraCoin\` module to destroy \`coin\`.  What have been mentioned above is the knowledge points involved in the first two chapters. If you have something forgotten, please go back to review them.\n\nNext let’s look at the \`script\` part of this instance. The first two lines in the \`main()\` procedure declare two resource variables, one of which is \`LibraCoin.T\` and the other is \`MoneyHolder.T\` declared by us. After declaring the variables, we will then initialize them on the ground that uninitialized variables cannot be operated.\n\nThe function\`LibraCoin.zero()\` in Line 21 aims  to initialize the resource \`LibraCoin.T\`, which is defined in Libra's official \`LibraCoin\` module and won’t be further analyzed here.\n\n\`MoneyHolder.new(move(coin))\` in Line 22 is the resource creation procedure we defined to initialize \`money_holder\`,  so that we can  use this variable now. \n\nNote: The argument here is \`move(coin)\` instead of \`copy(coin)\`. Even if you might want to use the \`coin\` variable in the following,  you are still not allowed to use the \`copy()\` function, for the reason that \`coin\` is a resource and resources can only be operated by the \`move()\` function rather than the \`copy()\` function.\n\nIn this instance, we are not going to implement any operations on \`money_holder\`, and thereby the next step is to destroy it before terminating the contract. Note that the parameters in this procedure also use the \`move()\` function, instead of \`copy()\`.\n\nIn general, to use a resource, we should first declare the resource variable through  the\`let\` statement, then call the resource creation procedure to initialize the variable, and finally implement the destruction process to destroy it when we have finished to use the resource, as shown in the following figure.\n\n<img src=${require("../../static/images/lesson3/pic_3_4_1_en.png")} style="width:80%;position:relative;left:10%">\n\n\n\n### **Practical exercise**\n\nIn the previous chapter, while we have completed the procedures of creating and destroying the castle, the contract still cannot be compiled successfully, since we are also required to refine  the resource creation and destruction in the \`main()\` procedure.\n\nNote: Since the account resource has no practical effect for the time being, we will not call it in \`main()\` here. If the \`CastleAccount\` resource needs to be used, we are able to create or destroy it with the\`newAccount\` and \`desAccount\` functions respectively.\n\n1. Add a statement to destroy the \`Castle\` resource in \`main()\`.\n\n\n`
            ,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    //Enter the code here\n\n    return;\n}",
                    answer: "modules: \nmodule Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {    \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);  \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}\nmodule BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {	\n        name: bytearray,\n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}\nmodule CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}\n\nscript: \nimport Transaction.BuildCastle;\nimport Transaction.Math;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
            ]
        },
        {
            title: "Chapter 5 Splitting files",
            instruction: `## Chapter 5 Splitting files\n\nBy the time you are here, I believe that you have noticed that the file is getting longer and longer. Thus, it’d be better if we divide it into multiple files for the sake of efficient management and readability improvement.\n\nIn this chapter, we have cleaned up the code on the right. Now as you can see, there are a few more tabs at the top of the editor and you are free to click on each tab to switch files.\n\nAs shown above, the tabs are divided into active and fixed tabs. The active tabs are editable, which are also the files that we are going to modify and check in practical exercise. While the fixed tabs are read-only, it is implied that we are entitled to check the files in the studying process but not allowed to make modifications.\n\nTypically, we place a module in a file and then import it by\`import address.module name\`, as described in Chapter 2 of Lesson 1. In this way, it is more convenient for us to maintain, manage and update different module functions.\n\n### **Practical exercise**\n\nNow that we have created a multi-file structure and split the module, please add the previously completed transaction script part to the file.\n\n1. Please browse through the created module and complete the transaction script in the current active tab.`,
            type: 0, 
            codes: [ 
                {
                    title: "contract.mvir",
                    code: "//Enter the code here",
                    answer: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}"
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {        \n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);    \n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",

                },
            ]
        },
    ]
}

const lesson4 = {
    lessonserial: "Lesson 4",
    title: "",
    intro: ["In the previous lessons, we made the castle more secure, but that's not enough. We also need to design access controls. In this lesson, we'll continue to reinforce the castle. ","The use of assert();The builtins get_txn_sender()，move_to_sender() and borrow_globla();Borrow and mutable borrow;The use of acquires;The use of dereference"],
    key: 2,
    total: 6,
    chapters: [
        {
            title: "Chapter 1 Statistics of Resources",
            instruction: `## Chapter 1 Statistics of Resources\n\nIn the last lesson, we mentioned that the operation on resources needs to guarantee the scarcity trait and meet access control policies. Therefore, the castle, as the most important resource a player holds, has to be guaranteed its reasonable quantity and access right.\n\nTo do this, we can add a counter variable to the system, update its value every time we create a new castle, and set a policy  to access the variable that only administrators are able to use it.\n\nGiven that the above counter variable requires security and access restrictions, we define its type as a resource and implement a series of related functions through operations on this resource. (Note: The following design idea is modeled after that of the \`LibraCoin\`module. Please read the specific code if you are interested).\n\n### Practical exercise\n\nFirst,  we need to declare a resource indicating the total number of castles.\n\n1. Declare a resource named \`CastleSum\` in the \`BuildCastle\` module, with a member variable \`sum(u64)\`.\n\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    // Enter the code here\n\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n    resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 2 Access Control for Initialization Process",
            instruction: `## Chapter 2 Access Control for Initialization Process\n\nAccording to Lesson 3, we have realized that resources are required to be initialized before used. Therefore, after declaring the resource \`CastleSum\`, we need to initialize it. At this point, we are faced with two problems:\n\n1. Only administrators are allowed to call the process of initializing CastleSum once when the Blockchain system has just been created. That is, we need to implement the access control for the initialization process.\n2. After initialized, the resource is supposed to be sent to the address of the administrator, instead of being destroyed in a transaction.\n\nWe will figure out how to address the first problem in this chapter and the second in the next chapter.\n\nFor the first question, we need to pick up two new inline processes.\n\n### \`assert()\`\n\n\`assert()\` is an operation widely used in many programming languages to check what \"should not\" happen. \`assert()\` is often used to verify the validity of incoming arguments at the beginning of the function and determine whether the result is correct at the end. (Note: Functions in other languages are equivalent to procedures in Libra Move).\n\nIn Libra Move, \`assert()\` has two arguments. The first one is an expression. When a program runs to the \`assert()\` statement, it checks to see whether the expression is valid or not. If true, it continues to execute; otherwise, it will terminate the program and output an error code, the value of which is the second argument.\n\nA simple instance for \`assert()\`  is as follow.\n\n\`\`\`\nmain() {\n  assert(1 + 2 == 3, 99);\n  return;\n}\n\n\`\`\`\n\nIn this example, the program determines whether \`1+2\` is equal to 3. If true, there will be no information output; otherwise, error code 99 will be printed.\n\n### \`get_txn_sender()\`\n\nIn Libra Move, there are many builtins for accessing system data, one of which is \`get_txn_sender()\` used to obtain the address of the current transaction sender. \n\nHere is an example: \n\n\`\`\`\nmain() {\n    let sender: address;\n    let addr: address;\n    sender = get_txn_sender();\n    addr = 0x0;\n    assert(copy(sender) != copy(addr), 42);\n    return;\n}\n\n\`\`\`\n\nAs you can see from this example, the return value of \`get_txn_sender()\` is an \`address\` variable and we assign the account address currently executing \`main()\` to an \`address\` variable by \`variable name = get_txn_sender()\`.\n\n### Practical exercise\n\nNext, we are going to set up the procedure of initializing the total number of castles and only allow  the administrator account to call this procedure.\n\n1. Declare the procedure of initializing the total amount of castles below  \`desCastle()\` in the \`BuildCastle\` module, named \`iniCastleSum()\`, which is a publicprocedure without the return value.\n2. Implement the access control of the resource by combining \`assert()\` and \`get_txn_sender()\`. Specifically, it is judged by \`assert()\` to determine whether the current account address is consistent with the administrator address. If not, an error message will be output and the program will be terminated as well. Here we assume that the administrator account address is \`0x0000000\` and the error code is 1.\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    // Enter the code here\n\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 3 Sending Resources",
            instruction: `## Chapter 3 Sending Resources\n\nNext, we're going to send the resource \`castleSum\` to the administrator address, which can be done with \`move_to_sender()\`. \n\n\`move_to_sender()\` is a module that sends a resource to the address corresponding to the current account for storage, with the following format: \n\n\`move_to_sender<n>(e)\` \n\nwhere \`n\` is the resource type and \`e\` is the resource expression. We will first introduce generics  \`<>\` before providing new insight into this operation.\n\n### Generics \n\nGenerics are a feature for programming languages that allow programmers to define variant parts when coding with a strongly typed programming language. These parts must be specified before they are used.\n\nIn short, generics enable a procedure to be available to multiple types of variables at the same time, without modifying the codes of the procedure.\n\nFor example, a procedure that can access to resource A returns the type of resource A when not using generics. At this time, if we want to do the same for resource B, we need to declare a procedure with exactly the same content but a different return value once again. Such a job is a meaningless repetition for developers, also increasing the complexity and redundancy of the codes. If we apply generics in this case, the same procedure only needs to be implemented once and the same operation can be performed on all resources by specifying the resource type when we are calling.\n\nTherefore, generics can be regarded as a special type that defers type definition until an object is created or methods are called. Generics provide developers with a high-performance programming approach that improves code reusability and type safety.\n\nIn this chapter, we skip how to implement the generic process for the time being, only considering how to apply it. The way to use generics in Move language is simple: \`procedure name <type> (parameter expression)\`\n\n### \`move_to_sender()\`\n\nLet’s learn about \`move_to_sender ()\` through a specific example.\n\n\`\`\`\npublic initialize() {\n        assert(get_txn_sender() == 0xA550C18, 1);\n        move_to_sender<MintCapability>(MintCapability{});\n        move_to_sender<MarketCap>(MarketCap { total_value: 0 });\n        return;\n}\n\`\`\`\n\nThis is a procedure for initializing the  market capacity in \`LibraCoin\`. Line 2 determines whether the current account is an administrator account through \`assert()\`, which is the knowledge point in the last chapter. Both Line 3 and Line 4 are used for \`move_to_sender()\` to send the resources \`MintCapability\` and \`MarketCap\` to the corresponding address of the current account respectively, where \`MintCapability\` is a resource without member variables, representing the mining right while \`total_value\`, the member variable of \`MarketCap\`, is initialized to 0.\n\nIn general, the above process first checks if the current account is an administrator one. If true, the current account is granted the mining right and the market capacity (i.e., the sum of the \`LibraCoin\` in the current system) is set to 0, which is sent to the current account.\n\n### Practical exercise\n\nFinally we initialize the resource for the total number of castles and send it to the administrator account.\n\n1. Initialize the declared resource \`CastleSum\` as 0 through \`move_to_sender()\` in the \`iniCastleSum()\` procedure and send it to the current account (i.e., the administrator account with address \`0x0000000\`). Remember to add \`return\` at the end of the procedure.\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        // Enter the code here\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 4 Borrowing",
            instruction: `## Chapter 4 Borrowing\n\nOnce we’ve initialized the total number of castles, we’d like to see how many of them are in the current system at any time.\n\nThis function seems easy to implement at first glance, since all you have to do is to access the resource \`CastleSum\` and output the value of its member variable \`sum\`. However, we should be aware that resources can’t be operated by \`copy()\`  as only \`move()\`  works. When we pass \`CastleSum\` into the procedure accessing this resource through \`move()\`, the original resource variable will lose ownership, which leads to every time we access the resource, we are required to reinitialize \`CastleSum\` and send it to the administrator account----this is obviously unreasonable.\n\nOwnership, on the one hand, increases resource security，but on the other hand, makes accessing or changing the value of a resource harder. To tackle with such a problem, Libra Move introduces the concept of borrowing.\n\nBorrowing indicates to borrow ownerships, also known as reference, the mechanism of which is similar to that of  \"read-write lock\" in other languages. We can only own one \"write\" lock or multiple \"read\" locks at the same time, that is, \"write\" lock and \"read\" lock are not allowed to appear simultaneously. \n\nLibra Move  will check the security  of borrowing operation during the compiling process rather than the running process, which can also help avoid problems such as deadlock and wild pointer.\n\nWe achieve borrowing by using \`&\`. For example:\n\n\`\`\`\nmain() {\n    let x: u64;\n    let x_ref: &u64;\n    let y: u64;\n    x = 5;\n    x_ref = &x;\n    //y = copy(x);	//error\n    _ = move(x_ref);\n    y = copy(x);	//correct\n    return;\n}\n\`\`\`\n\nWe can learn from above that the way to declare a borrowing is \`let borrowing variable name: &borrowing variable type\`. \n\nOnce declared, borrowing can be realized through \`borrowing variable name: = & borrowed variable name\`. \n\nDuring the borrowing period, the ownership of the original variable is borrowed, implying we are unable to access this variable by \`copy()\` or other means.  \n\nJust as resources need to be explicitly destroyed, borrowing is required to be returned. We also need to explicitly break off borrowing when it is no longer used, or before the end of \`main()\`.  As in this example, we achieve this function through \`_ = move(x_ref)\`, where \`_\` represents a temporary variable in Libra Move. This operation moves the value stored in \`x_ref\` to the temporary variable, which will be destroyed when finishing using it.  By this way,  the borrowing of \`x_ref\` has been removed. \n\n### Mutable borrowing \`mut\`\n\nThe same as the \"read-write lock\" mechanism, divided by \"read” lock and \"write” lock, borrowing is also divided into mutable borrowing \`&mut\` and immutable borrowing \`&\`.\n\nMutable borrowing can modify the value of the original variable during the borrowing period, while immutable borrowing is read-only. \n\nA variable can have at most one mutable borrowing or multiple immutable borrowings at a time, which means the two kinds of borrowings cannot appear concurrently. \n\nFor instance, the following example can be successfully compiled, but if we change \`x_ref = &x;\` to \`x_ref = &mut x;\`, the compilation will fail in the end.\n\n\`\`\`\nmain() {\n    let x: u64;\n    let x_ref: &u64;\n    let x_ref2: &u64;\n    x = 5;\n    x_ref = &x;	//correct\n    //x_ref = &mut x;	//error\n    x_ref2 = &x;	\n    _ = move(x_ref);\n    _ = move(x_ref2);\n    return;\n}\n\`\`\`\n\n### Practical exercise\n\nNext,  we are going to set up a procedure to see how many castles there are in the current system.\n\n1. Declare a procedure named \`castlesum()\` in the \`BuildCastle\` module, which has no parameters and returns a u64 variable representing the total number of castles. Note that we should use lowercase letters for the process name to distinguish it from the resource \`CastleSum\`.\n\n2. Declare a mutable borrowing resource variable named \`CastleSum_ref\` on the first line of the procedure, which we'll refine in the next few chapters.\n\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    // Enter the code here\n\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: " Chapter 5 borrow_global()",
            instruction: `##  Chapter 5 \`borrow_global()\` \n\nIn Chapter 3, we have learned how to use \`move_to_sender()\`.  In this chapter, we’ll move forward to introduce another module \`borrow_global()\`.\n\n\`borrow_global()\` is also a procedure that implements generics, taking an \`address\` variable as the input parameter, which is used globally to return the mutable borrowing of a resource with the corresponding type at the specified address.\n\nWe can use \`borrow_global()\` with the format of \`borrowing resource name=borrow_global<required resource name>(address)\`. For example, the variable \`x_ref\` borrows the resource \`T\` with address \`0x0000\` through \`x_ref = borrow_global<T>(0x0000)\`.\n\nObviously, \`borrow_global()\` requires the target address to have the resources it needs to borrow. If not, the borrowing will consequently fail.\n\nThat is, once we use \`borrow_global ()\` in a procedure, we need to tell the Move\ncompiler what resources the procedure will borrow at the very beginning and Libra Move\nwill implement this operation through \`acquires T\`.\n\n### \`acquires\`\n\n\`acquires\` can be regarded as an annotation that tells the bytecode verifier which types of a procedure (or its callees) may borrow or move from the global state. These annotations allow the bytecode verifier to ensure that there are no dangling references to values in the global state.\n\nNote: The dangling reference is a problem that when two pointers point to an address at the same time, the data at the address is deleted by one of the points, while the other points to an empty address as a result.\n\nFrom a programmer perspective, this means that you must add \`acquires\` for any procedure when: \n\n1. performs \`borrow_global<T>\` ；\n2. performs \`move_from<T>\`  ( which will be introduced in the following lessons) ;\n3. calls a procedure annotated with \`acquires T\` .\n\nLet's learn how to use \`acquires\` with an example:  \n\n\`\`\`\nmodule A {\n    resource T1{v: u64}\n    public test(addr: address) acquires T1 {\n        let x: &mut Self.T1;\n        x = borrow_global<T1>(get_txn_sender());\n        _ = move(x);\n        return;\n    }\n}\n\`\`\`\n\nIn the above example, we borrow the resource \`T1\` from the calling procedure's address and store it in \`x\`. Since we have used \`borrow_global<T1>\`, it is required to check if the resource \`T1\` exists at the beginning. Thus,  we wrote down \`acquires T1\` at the end of  the declaration procedure.\n\n(Reference:  https://community.libra.org/t/how-could-i-understand-the-keyword-acquires/1832 )\n\n### Practical exercise\n\n1. With mutable borrowing declared,  we need to initialize the \`CastleSum_ref\` via \`borrow_global()\`, the parameter of which is the administrator address, tentatively set to \`0x0000000 \`;\n2. Add \`acquires\` in the declaration part of the procedure due to the use of \`borrow_global()\`.\n\n`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    //在这里添加acquires\n    public castlesum(): u64\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        // Enter the code here\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global<CastleSum>(0x0000000);\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        {
            title: "Chapter 6 Dereference",
            instruction: `## Chapter 6 Dereference\n\nIf you are familiar with C language, then when you see the borrowing \`&\` in the previous chapters, I believe dereference \`*\` is likely to occur to you. Dereference can also be implemented in Libra Move, similar to that in C language. \n\nDeference \`Deref\` is the inverse operation of reference \`Ref\`. \n\nIn the Move bytecode, the only way to interact with the fields of a given struct (such as a structure or a resource) is by reference. So in order to get a copy of a value in a struct, a programmer must first borrow a reference to the field, and then a copy of the value bound to that field can be created by using deref \`*\`. \n\nTo put it simply, we can obtain a reference to a resource by borrowing \`&\` and the value of the reference by dereference\`*\`.\n\n\`\`\`\nfield_ref = &move(rsc).field;\nfield_value = *move(field_ref);\n\`\`\`\n\nWhen accessing a resource, we are able to obtain the value of a resource and return the ownership at the end of the borrowing by combining the borrowing and dereference, that is, \`*&\`.\n\nFor example, by using \`*&move(T).value\`, we can get the value of the member variable named \`value\` in the resource \`T\`. When the borrowing ends, the ownership of the resource and its member variables will not be changed.\n\nFinally, we summarize three commonly used operations on variables and fields by analyzing \`*&move(rsc).field\`: \`move()\`, \`&\`, and \`*\`.\n\n\`*&move(rsc).field\` is an operation consisting of three parts: the \`move()\` for variables, the borrowing for some field, and the value obtained by borrowing.\n\n1. \`move(rsc)\`\n\n   Each time we access a local variable, we can perform \`move()\` or \`copy()\`  on it. Using \`copy()\` means we obtain a copy of the variable;  while using \`move()\` indicates that we have transferred the ownership of the value, and aren’t allowed to get access to it again before assigning a new value to this local variable.\n\n2. \`&move(rsc).field\`\n\n   This is a borrowing operation on a field.  The only way to access some field of a given struct is by reference. The original reference to \`move(rsc)\` has been extended to a reference to the field \`field\` through this operation. Specifically, what we are currently referencing to is no longer \`move(rsc)\`, but \`field\`.\n\n3. \`*&move(rsc).field\`\n\n   This is a dereference operation that reads value from a borrowing. When we perform dereference operation, we obtain the copy of this borrowing value, while the original borrowing will not be changed. Specifically, what is currently accessed has changed from \`&move(rsc).field\` to a copy of the value.\n\n(Reference:  https://community.libra.org/t/meaning/1253/2 )\n\n### Practical exercise \n\nFinally, we need to get the value of the total number of castles and return it.\n\n1. Get the value of the member variable in the resource \`CastleSum_ref\` via \`*&\` and use it as the return value of the procedure.`,
            type: 0,
            codes:[
                {
                    title: "BuildCastle.mvir",
                    code: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global<CastleSum>(0x0000000);\n        // Enter the code here\n\n    }\n}",
                    answer: "module BuildCastle {\n    import Transaction.Math;\n    import 0x0.Block;\n    resource Castle {\n        name: bytearray, \n        SerialNum: u64,\n        level: u64,\n        economic: u64,\n        military: u64\n    }\n   resource CastleSum {\n        sum: u64\n    }\n    public generateSerial(SerialLimit: u64) : u64 {\n        let SerialNum: u64;\n        SerialNum = Math.myrand(Block.get_current_height()) % (copy(SerialLimit) - copy(SerialLimit) / 10) + copy(SerialLimit) / 10;\n        return move(SerialNum);\n    }\n    public racial_judgment(SerialNum: u64) : u64 * u64 {\n        let race: u64;\n        race = ((move(SerialNum) / 10) % 10) % 5;\n        if (copy(race) == 0) {\n            return 6, 6;\n        }\n        if (copy(race) == 1) {\n            return 8, 3;\n        }\n        if (copy(race) == 2) {\n            return 3, 8;\n        }\n        if (copy(race) == 3) {\n            return 7, 4;\n        } else {\n            return 4, 7;\n        }\n    }\n    public newCastle(_name: bytearray, _SerialNum: u64) : Self.Castle {\n        let a: u64;\n        let b: u64;\n        a, b = Self.racial_judgment(copy(_SerialNum));\n        return Castle {\n            name: move(_name),\n            SerialNum: copy(_SerialNum),\n            level: 1,\n            economic: move(a),\n            military: move(b)\n        };\n    }\n    public desCastle (castle: Self.Castle)\n    {\n        let name: bytearray;\n        let SerialNum: u64;\n        let level: u64;\n        let economic: u64;\n        let military: u64;\n        Castle{name,SerialNum,level,economic,military} = move(castle);\n        return;\n    }\n    public iniCastleSum()\n    {\n        assert(get_txn_sender() == 0x0000000, 1);\n        move_to_sender<CastleSum>(CastleSum { sum: 0 });\n        return;\n    }\n    public castlesum(): u64 acquires CastleSum\n    {\n        let CastleSum_ref: &mut Self.CastleSum;\n        CastleSum_ref = borrow_global<CastleSum>(0x0000000);\n        return *&move(CastleSum_ref).sum;\n    }\n}",
                },
                {
                    title: "Math.mvir",
                    code: "module Math {\n    public pow(x: u64, n: u64) : u64 {\n        if (copy(n) == 0) {\n            return 1;\n        }\n        if (copy(n) == 1) {\n            return move(x);\n        }\n        if (copy(n) % 2 == 0) {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2);\n        } else {\n            return Self.pow(copy(x) * copy(x), copy(n) / 2) * copy(x);\n        }\n    }\n    public myrand(seed: u64) : u64 {\n        let rand: u64;\n        rand = move(seed) * 1103515245 + 12345;\n        return (move(rand) / 65536) % 32768;\n    }\n}",
                },
                {
                    title: "CastleAccount.mvir",
                    code: "module CastleAccount {\n    resource CastleAccount {\n        a: u64\n    }\n    public newAccount () : Self.CastleAccount\n    {\n        return CastleAccount { a: 0 };\n    }\n    public desAccount (account: Self.CastleAccount)\n    {\n        let num: u64;\n        CastleAccount { num } = move(account);\n        return;\n    }\n}",
                },
                {
                    title: "main.mvir",
                    code: "import Transaction.Math;\nimport Transaction.BuildCastle;\nmain(name: bytearray) {\n    let SerialDigits: u64;\n    let SerialLimit: u64;\n    let SerialNum: u64;\n    let castle: BuildCastle.Castle;\n    SerialDigits = 8;\n    SerialLimit = Math.pow(10, copy(SerialDigits));\n    SerialNum = BuildCastle.generateSerial(copy(SerialLimit));\n    castle = BuildCastle.newCastle(move(name), move(SerialNum));\n    BuildCastle.desCastle(move(castle));\n    return;\n}",
                },
            ]
        },
        ]
}

const lessons = [lesson1, lesson2, lesson3, lesson4];

export default lessons;

